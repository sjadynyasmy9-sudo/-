import asyncio
import json
import os
import logging
import hashlib
import secrets
import threading
import time
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (Application, CommandHandler, CallbackQueryHandler,MessageHandler, filters, ContextTypes)
from datetime import datetime, timedelta
from database import DatabaseManager
try:
    from apis import (poll, send_comments_multiple, get_working_accounts_for_comments, 
                     get_active_accounts_count, get_working_accounts, SimpleDB)
    from apis import *
except ImportError:
    def poll(*args, **kwargs):
        return {"success": False, "message": "APIs module not available"}
    def send_comments_multiple(*args, **kwargs):
        return {"success": False, "message": "APIs module not available"}

    def get_working_accounts_for_comments(*args, **kwargs):
        return []

    def get_active_accounts_count(*args, **kwargs):
        return 0

    def get_working_accounts(*args, **kwargs):
        return []
    class SimpleDB:
        def __init__(self, filename):
            self.data = {}

        def get(self, key, default=None):
            return self.data.get(key, default)

        def set(self, key, value):
            self.data[key] = value


db = SimpleDB('simple_data.json')

try:
    import pytz
except ImportError:
    print("ØªØ­Ø°ÙŠØ±: Ù…ÙƒØªØ¨Ø© pytz ØºÙŠØ± Ù…Ø«Ø¨ØªØ©ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªÙˆÙ‚ÙŠØª Ø§Ù„Ù…Ø­Ù„ÙŠ")

try:
    with open('config.json', 'r', encoding='utf-8') as f:
        w = json.load(f)

    token = w['bot_token']
    stypes = ['member', 'administrator', 'creator']
    member_price = w['prices']['member']
    vote_price = w['prices']['vote']
    link_price = w['prices']['link']
    spam_price = w['prices']['spam']
    react_price = w['prices']['react']
    forward_price = w['prices']['forward']
    view_price = w['prices']['view']
    reaction_price = 6  # Ø³Ø¹Ø± Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„ÙˆØ§Ø­Ø¯
    poll_price = w['prices']['poll']
    userbot_price = w['prices']['userbot']
    linkbot_price = w['prices']['linkbot']
    comment_price = w['prices']['comments']
    linkbot2_price = w['prices']['linkbot2']
    userbot_rush_price = 26
    print("ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­")

except Exception as e:
    print(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ config.json: {e}")
    member_price = 12
    vote_price = 5
    link_price = 10
    spam_price = 8
    react_price = 3
    forward_price = 6
    view_price = 2
    poll_price = 50
    reaction_price = 6
    userbot_price = 15
    linkbot_price = 20
    comment_price = 9
    linkbot2_price = 25
    userbot_rush_price = 26
db_manager = DatabaseManager('bot_data.db')
print("SQLite Database System initialized successfully")
def force(channel, userid):
    try:
        x = bot.get_chat_member(channel, userid)
        print(x)
    except:
        return True
    if str(x.status) in stypes:
        print(x)
        return True
    else:
        print(x)
        return False
def addord():
    if not db.get('orders'):
        db.set('orders', 1)
        return True
    else:
        d = db.get('orders')
        d += 1
        db.set('orders', d)
        return True
logging.basicConfig(
    format='%(levelname)s - %(message)s',
    level=logging.WARNING
)
logger = logging.getLogger(__name__)
BOT_TOKEN = "7905405670:AAH9H_RgQYyDLJSj3Ok3mRtELph9zlpWmQU"
ADMIN_ID = 7043243383
MEMBER_PRICE = 12
class TelegramBot:
    def __init__(self):
        self.user_mandatory_messages = {}
        self.db = db_manager
        self.users = self.db.get_all_users()
        self.invite_points = self.db.get_setting('invite_points', 0.75)
        self.mandatory_enabled = self.db.get_setting('mandatory_enabled', True)
        self.member_price = self.db.get_setting('member_price', 8)
        self.bot_member_price = self.db.get_setting('bot_member_price', 30)
        self.wheel_spin_cost = self.db.get_setting('wheel_spin_cost', 500)
        self.min_funding_members = self.db.get_setting('min_funding_members', 50)
        self.daily_gift_amount = self.db.get_setting('daily_gift_amount', 100)
        self.wheel_gift_first = "ğŸªÂ³Â¹â°â°"
        self.wheel_gift_second = "ğŸªÂ²âµâ°â°"
        self.wheel_prizes = ["ğŸªÂ³Â¹â°â°", "ğŸªÂ²âµâ°â°", "ğŸªÂ²â°â°â°", "ğŸªÂ¹âµâ°â°", "ğŸªÂ¹â°â°â°", "ğŸªâµâ°â°"]
        self.stars_prices = {
            15: 15000,
            25: 25000,
            50: 50000,
            100: 100000,
            200: 200000,
            300: 300000
        }
        self.mandatory_channels = self.db.get_mandatory_channels()
        self.paid_channels = self.db.get_paid_channels()
        self.user_channel_subscriptions = self.db.get_user_channel_subscriptions()
        self.invites = self.db.get_invites()
        self.gifts = {}
        self.banned_users = self.db.get_banned_users()
        self.gift_links = self.db.get_gift_links()
        self.gift_codes = {}
        self.top_referrers = []
        self.monitored_channels = {}
        self.mandatory_subscriptions = {}
        self.funded_channels = self.db.get_funded_channels()
        self.daily_gifts = {}
        self.stars_purchases = {}
        self.paid_bots = self.db.get_paid_bots()
        self.funded_bots = {}
        self.user_bot_subscriptions = {}
        self.funding_numbers = self.db.get_funding_numbers()
        self.completed_fundings = {"channels": {}, "bots": {}}
        logger.info("ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª SQLite Ø¨Ù†Ø¬Ø§Ø­")
        self.user_cooldown = {}
        self.cooldown_time = 1
        self.pending_saves = {}
        self.save_delay = 2
        self.pending_checks = {}
        self.check_delay = 30
        self.user_purchases = {}
        self.wheel_spins = {}
        self.maintenance_mode = {
            "fund_channel": False,
            "invite_link": False,
            "collect_stars": False,
            "wheel_luck": False,
            "stars_section": False,
            "rush_services": False,
        }
        self.maintenance_messages = {
            "fund_channel": "ğŸ”§ Ø²Ø± ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù‚Ù†Ø§Ø© ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©\n\nÙ†Ø¹ØªØ°Ø± Ø¹Ù† Ø§Ù„Ø¥Ø²Ø¹Ø§Ø¬ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø© Ù‚Ø±ÙŠØ¨Ø§Ù‹",
            "invite_link": "ğŸ”§ Ø²Ø± Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©\n\nÙ†Ø¹ØªØ°Ø± Ø¹Ù† Ø§Ù„Ø¥Ø²Ø¹Ø§Ø¬ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø© Ù‚Ø±ÙŠØ¨Ø§Ù‹",
            "collect_stars": "ğŸ”§ Ø²Ø± ØªØ¬Ù…ÙŠØ¹ Ø§Ù„ÙƒÙˆÙƒÙŠØ² ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©\n\nÙ†Ø¹ØªØ°Ø± Ø¹Ù† Ø§Ù„Ø¥Ø²Ø¹Ø§Ø¬ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø© Ù‚Ø±ÙŠØ¨Ø§Ù‹",
            "wheel_luck": "ğŸ”§ Ø²Ø± Ø¹Ø¬Ù„Ø© Ø§Ù„Ø­Ø¸ ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©\n\nÙ†Ø¹ØªØ°Ø± Ø¹Ù† Ø§Ù„Ø¥Ø²Ø¹Ø§Ø¬ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø© Ù‚Ø±ÙŠØ¨Ø§Ù‹",
            "stars_section": "ğŸ”§ Ø²Ø± Ù‚Ø³Ù… Ø§Ù„Ù†Ø¬ÙˆÙ… ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©\n\nÙ†Ø¹ØªØ°Ø± Ø¹Ù† Ø§Ù„Ø¥Ø²Ø¹Ø§Ø¬ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø© Ù‚Ø±ÙŠØ¨Ø§Ù‹",
            "rush_services": "ğŸ”§ Ø²Ø± Ù‚Ø³Ù… Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø±Ø´Ù‚ ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©\n\nÙ†Ø¹ØªØ°Ø± Ø¹Ù† Ø§Ù„Ø¥Ø²Ø¹Ø§Ø¬ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø© Ù‚Ø±ÙŠØ¨Ø§Ù‹",
        }
        self.admin_check_running = False
        self.admin_check_thread = None
        self.start_admin_check()

        self.pending_reports = {}  # ØªØ®Ø²ÙŠÙ† Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…Ø¤Ù‚ØªØ©
        self.user_reports = {}  # ØªØªØ¨Ø¹ Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not update.message or not update.effective_user:
            return
        if update.message.chat.type != 'private':
            return
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        await self.delete_old_mandatory_message(context, user_id)
        if user_id_str in self.banned_users:
            await update.message.reply_text(
                "ØªÙ… Ø­Ø¸Ø±Ùƒ Ù…Ù† Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø®Ø·Ø£ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© @cxxov"
            )
            return
        if user_id != ADMIN_ID:
            on_cooldown, remaining_time = self.is_on_cooldown(user_id)
            if on_cooldown:
                return
        waiting_for = context.user_data.get('waiting_for')

        text = update.message.text if update.message.text else ""

        if waiting_for == 'use_gift_code':
            await self.handle_gift_code_usage(update, context, text)
            return
        elif waiting_for in ['transfer_target_id', 'transfer_amount']:
            if waiting_for == 'transfer_target_id':
                await self.handle_transfer_target_id(update, context, text)
            elif waiting_for == 'transfer_amount':
                await self.handle_transfer_amount(update, context, text)
            return
        elif waiting_for == 'fund_channel_members':
            await self.handle_fund_channel_members_input(update, context, text)
            return
        elif waiting_for == 'fund_channel_username':
            await self.handle_fund_channel_username_input(update, context, text)
            return

        # Admin-only message handlers
        if waiting_for and user_id == ADMIN_ID:
            if waiting_for == 'broadcast_message':
                await self.handle_broadcast_message(update, context, text)
            elif waiting_for == 'mandatory_channel_username':
                await self.handle_mandatory_channel_username(update, context, text)
            elif waiting_for == 'mandatory_channel_members':
                await self.handle_mandatory_channel_members(update, context, text)
            elif waiting_for == 'mandatory_channel_invite':
                await self.handle_mandatory_channel_invite(update, context, text)
            elif waiting_for == 'user_info_admin_id':
                await self.handle_user_info_admin(update, context, text)
            elif waiting_for == 'ban_user_id':
                await self.handle_ban_user(update, context, text)
            elif waiting_for == 'unban_user_id':
                await self.handle_unban_user(update, context, text)

    def save_data_to_db(self, data_type, data):
        try:
            if data_type == 'users':
                pass  # Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„Ø­ÙØ¸ ÙÙŠ JSONØŒ ÙÙ‚Ø· SQLite
            elif data_type == 'mandatory_channels':
                self.db.save_mandatory_channels(data)
            elif data_type == 'paid_channels':
                self.db.save_paid_channels(data)
            elif data_type == 'user_channel_subscriptions':
                self.db.save_user_channel_subscriptions(data)
            elif data_type == 'gift_links':
                self.db.save_gift_links(data)
            elif data_type == 'funded_channels':
                self.db.save_funded_channels(data)
            elif data_type == 'funding_numbers':
                self.db.save_funding_numbers(data)
            elif data_type == 'paid_bots':
                self.db.save_paid_bots(data)
            elif data_type == 'banned_users':
                self.db.save_banned_users(data)
            elif data_type == 'invites':
                self.db.save_invites(data)
            else:
                self.db.set_setting(data_type, data, 'json')

            logger.debug(f"Data saved to database: {data_type}")
            return True

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª {data_type}: {e}")
            return False
        try:
            if filename == MANDATORY_CHANNELS_FILE or 'mandatory_channels' in filename:
                self.db.save_mandatory_channels(data)
            elif filename == PAID_CHANNELS_FILE or 'paid_channels' in filename:
                self.db.save_paid_channels(data)
            elif filename == USER_CHANNEL_SUBSCRIPTION_FILE or 'user_channel_subscription' in filename:
                self.db.save_user_channel_subscriptions(data)
            elif filename == GIFT_LINKS_FILE or 'gift_links' in filename:
                self.db.save_gift_links(data)
            elif filename == FUNDED_CHANNELS_FILE or 'funded_channels' in filename:
                self.db.save_funded_channels(data)
            elif filename == FUNDING_NUMBERS_FILE or 'funding_numbers' in filename:
                self.db.save_funding_numbers(data)
            elif filename == PAID_BOTS_FILE or 'paid_bots' in filename:
                self.db.save_paid_bots(data)
            elif filename == BANNED_USERS_FILE or 'banned_users' in filename:
                self.db.save_banned_users(data)
            elif filename == INVITES_FILE or 'invites' in filename:
                self.db.save_invites(data)
            else:
                setting_key = os.path.basename(filename).replace('.json', '')
                self.db.set_setting(setting_key, data, 'json')
            logger.debug(f"Data saved to database instead of {filename}")
            return True
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† {filename}: {e}")
            return False
    def save_user_to_db(self, user_id, user_data=None):
        """Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ù„Ù‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†Ø©"""
        try:
            if user_data is None:
                user_data = self.users.get(str(user_id))
            if user_data:
                success = self.db.save_user(user_id, user_data)
                return success
            return False
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}: {e}")
            return False
    def update_data_in_memory_and_db(self):
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙˆÙ‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
        try:
            self.mandatory_channels = self.db.get_mandatory_channels()
            self.paid_channels = self.db.get_paid_channels()
            self.user_channel_subscriptions = self.db.get_user_channel_subscriptions()
            self.invites = self.db.get_invites()
            self.banned_users = self.db.get_banned_users()
            self.gift_links = self.db.get_gift_links()
            self.funded_channels = self.db.get_funded_channels()
            self.funding_numbers = self.db.get_funding_numbers()
            self.paid_bots = self.db.get_paid_bots()
            return True
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: {e}")
            return False

    def save_users_to_db_only(self):
        """Ø­ÙØ¸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙŠ SQLite ÙÙ‚Ø·"""
        try:
            for user_id, user_data in self.users.items():
                self.db.save_user(user_id, user_data)
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {e}")

    def format_time_12h(self, dt_obj):
        return dt_obj.strftime('%I:%M %p').replace('AM', 'Øµ').replace('PM', 'Ù…')

    def escape_markdown(self, text):
        if not text:
            return "ØºÙŠØ± Ù…ØªØ§Ø­"
        text = str(text)
        escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
        for char in escape_chars:
            text = text.replace(char, f'\\{char}')
        return text

    def get_user(self, user_id):
        user_data = self.db.get_user(user_id)
        if not user_data:
            user_data = {
                "points": 0.0,
                "stars_bought": 0,
                "joined_date": str(datetime.now()),
                "invite_link": self.generate_invite_link(user_id),
                "banned": False,
                "used_invite": None,
                "first_join": True,
                "completed_mandatory": False,
                "referrals_count": 0,
                "last_activity": str(datetime.now()),
                "funded_channels": [],
                "funded_bots": []
            }
            self.db.save_user(user_id, user_data)
            self.users[str(user_id)] = user_data
        else:
            self.users[str(user_id)] = user_data
        return self.users[str(user_id)]

    def generate_invite_link(self, user_id):
        return str(user_id)

    def is_on_cooldown(self, user_id):
        now = datetime.now()
        if user_id in self.user_cooldown:
            time_diff = (now - self.user_cooldown[user_id]).total_seconds()
            if time_diff < self.cooldown_time:
                return True, self.cooldown_time - int(time_diff)

        self.user_cooldown[user_id] = now
        return False, 0

    def can_purchase_today(self, user_id):
        today = datetime.now().date()
        user_purchases_today = self.user_purchases.get(str(user_id), {})

        for date_str in list(user_purchases_today.keys()):
            if datetime.strptime(date_str, '%Y-%m-%d').date() != today:
                del user_purchases_today[date_str]

        today_str = today.strftime('%Y-%m-%d')
        today_purchases = user_purchases_today.get(today_str, 0)

        if isinstance(today_purchases, dict):
            purchases_count = today_purchases.get("count", 0)
        else:
            purchases_count = today_purchases

        return purchases_count < 2

    def can_spin_wheel_today(self, user_id):
        today = datetime.now().date().strftime('%Y-%m-%d')
        user_id_str = str(user_id)

        if user_id_str not in self.wheel_spins:
            self.wheel_spins[user_id_str] = {}

        user_spins_today = self.wheel_spins[user_id_str]

        for date_str in list(user_spins_today.keys()):
            if date_str != today:
                del user_spins_today[date_str]

        spins_count = user_spins_today.get(today, 0)
        return spins_count < 2

    def record_wheel_spin(self, user_id):
        today = datetime.now().date().strftime('%Y-%m-%d')
        user_id_str = str(user_id)

        if user_id_str not in self.wheel_spins:
            self.wheel_spins[user_id_str] = {}

        if today not in self.wheel_spins[user_id_str]:
            self.wheel_spins[user_id_str][today] = 0

        self.wheel_spins[user_id_str][today] += 1

    def get_daily_gift_info(self, user_id):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        try:
            today = datetime.now().date()
            today_str = today.strftime('%Y-%m-%d')
            user_id_str = str(user_id)

            try:
                with self.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute('SELECT * FROM daily_gifts WHERE user_id = ?', (user_id_str,))
                    row = cursor.fetchone()

                    if row:
                        last_claim_date = row['last_claim_date']
                        current_day = row['current_day']
                        claimed_today = row['claimed_today']

                        if last_claim_date and last_claim_date != today_str:
                            claimed_today = False
                            cursor.execute('UPDATE daily_gifts SET claimed_today = 0 WHERE user_id = ?', (user_id_str,))
                            conn.commit()

                        return {
                            'can_claim': not claimed_today,
                            'current_day': current_day,
                            'last_claim_date': last_claim_date
                        }
            except:
                pass

            return {
                'can_claim': True,
                'current_day': 1,
                'last_claim_date': None
            }
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ get_daily_gift_info: {e}")
            return {
                'can_claim': False,
                'current_day': 1,
                'last_claim_date': None
            }

    def can_claim_daily_gift(self, user_id):
        """Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ…"""
        daily_gift_info = self.get_daily_gift_info(user_id)
        return daily_gift_info['can_claim']

    def claim_daily_gift(self, user_id):
        """Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ…"""
        daily_gift_info = self.get_daily_gift_info(user_id)
        if daily_gift_info['can_claim']:
            daily_rewards = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]
            current_day = daily_gift_info['current_day']
            if current_day <= len(daily_rewards):
                try:
                    today_str = datetime.now().date().strftime('%Y-%m-%d')
                    with self.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute('''
                            INSERT OR REPLACE INTO daily_gifts 
                            (user_id, current_day, last_claim_date, claimed_today) 
                            VALUES (?, ?, ?, 1)
                        ''', (str(user_id), current_day + 1, today_str))
                        conn.commit()
                except Exception as e:
                    logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©: {e}")

                return daily_rewards[current_day - 1]
        return self.daily_gift_amount

    def record_purchase(self, user_id, stars_count=0):
        today = datetime.now().date().strftime('%Y-%m-%d')

        if str(user_id) not in self.user_purchases:
            self.user_purchases[str(user_id)] = {}

        if today not in self.user_purchases[str(user_id)]:
            self.user_purchases[str(user_id)][today] = {"count": 0, "stars": 0}

        if isinstance(self.user_purchases[str(user_id)][today], int):
            old_count = self.user_purchases[str(user_id)][today]
            self.user_purchases[str(user_id)][today] = {"count": old_count, "stars": 0}

        self.user_purchases[str(user_id)][today]["count"] += 1
        self.user_purchases[str(user_id)][today]["stars"] += stars_count

    def generate_gift_link(self):
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-"
        return ''.join(secrets.choice(chars) for _ in range(20))

    def create_gift_link(self, points, max_users):
        gift_code = self.generate_gift_link()
        expiry_date = datetime.now() + timedelta(hours=24)

        self.gift_links[gift_code] = {
            "points": points,
            "max_users": max_users,
            "used_users": [],
            "created_date": str(datetime.now()),
            "expiry_date": str(expiry_date),
            "active": True
        }
        self.save_json(GIFT_LINKS_FILE, self.gift_links)
        return gift_code

    def use_gift_link(self, gift_code, user_id):
        if gift_code not in self.gift_links:
            return {"success": False, "message": "Ø±Ø§Ø¨Ø· Ø§Ù„Ù‡Ø¯ÙŠØ© ØºÙŠØ± ØµØ­ÙŠØ­!"}

        gift = self.gift_links[gift_code]

        if not gift["active"]:
            return {"success": False, "message": "ØªÙ… ÙˆØµÙˆÙ„ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø§Ù‚ØµÙ‰ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† !"}

        expiry_date = datetime.strptime(gift["expiry_date"], '%Y-%m-%d %H:%M:%S.%f')
        if datetime.now() > expiry_date:
            gift["active"] = False
            self.save_json(GIFT_LINKS_FILE, self.gift_links)
            return {"success": False, "message": "Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©!"}

        if str(user_id) in gift["used_users"]:
            return {"success": False, "message": "Ù„Ù‚Ø¯ Ø§Ø³ØªØ®Ø¯Ù…Øª Ù‡Ø°Ø§ Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù† Ù‚Ø¨Ù„!"}

        if len(gift["used_users"]) >= gift["max_users"]:
            gift["active"] = False
            self.save_json(GIFT_LINKS_FILE, self.gift_links)
            return {"success": False, "message": "ØªÙ… ÙˆØµÙˆÙ„ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø§Ù‚ØµÙ‰ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† !"}

        user = self.get_user(user_id)
        user["points"] += gift["points"]
        gift["used_users"].append(str(user_id))


        self.save_json(GIFT_LINKS_FILE, self.gift_links)

        return {
            "success": True,
            "points": gift["points"],
            "remaining": gift["max_users"] - len(gift["used_users"])
        }

    def deactivate_gift_link(self, gift_code):
        if gift_code in self.gift_links:
            self.gift_links[gift_code]["active"] = False
            self.save_json(GIFT_LINKS_FILE, self.gift_links)
            return True
        return False

    def update_top_referrers(self):
        referrers = []

        for user_id, user_data in self.users.items():
            referral_count = user_data.get("referrals_count", 0)
            if referral_count > 0:
                referrers.append({
                    "user_id": user_id,
                    "count": referral_count
                })

        referrers.sort(key=lambda x: x["count"], reverse=True)
        self.top_referrers = referrers[:5]
        self.save_json(TOP_REFERRERS_FILE, self.top_referrers)

    async def _delayed_activity_save(self):
        await asyncio.sleep(1)  # Ø§Ù†ØªØ¸Ø§Ø± Ø«Ø§Ù†ÙŠØ© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø· Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
        if hasattr(self, '_activity_save_pending'):

            del self._activity_save_pending

    async def schedule_delayed_check(self, user_id, context):
        user_id_str = str(user_id)

        if user_id_str in self.pending_checks:
            current_task = self.pending_checks[user_id_str]
            if not current_task.done():
                return

        async def delayed_check():
            try:
                await asyncio.sleep(self.check_delay)  # Ø§Ù†ØªØ¸Ø§Ø± 30 Ø«Ø§Ù†ÙŠØ©
                await self.check_paid_subscriptions_and_deduct(user_id, context)
                if user_id_str in self.pending_checks:
                    del self.pending_checks[user_id_str]
            except asyncio.CancelledError:
                pass
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙØ­Øµ Ø§Ù„Ù…Ø¤Ø¬Ù„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}: {e}")
                if user_id_str in self.pending_checks:
                    del self.pending_checks[user_id_str]

        self.pending_checks[user_id_str] = asyncio.create_task(delayed_check())
    def format_points(self, points):
        if points == int(points):
            return str(int(points))
        else:
            return f"{points:.2f}"

    def generate_funding_number(self, funding_type="channel", channel_id=None, bot_id=None, is_cumulative=False):
        """Ø¥Ù†Ø´Ø§Ø¡ Ø±Ù‚Ù… ØªÙ…ÙˆÙŠÙ„ Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Ø§Ù„ØªØ³Ù„Ø³Ù„ - Ø±Ù‚Ù… Ø¬Ø¯ÙŠØ¯ Ù„ÙƒÙ„ ØªÙ…ÙˆÙŠÙ„ Ù…Ø¹ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©"""

        self.cleanup_old_funding_numbers()

        if is_cumulative:
            existing_record = self.get_funding_record_by_id(
                channel_id if funding_type == "channel" else bot_id, 
                funding_type
            )
            if existing_record and existing_record.get("status") != "Ù…ÙƒØªÙ…Ù„":
                funding_number = existing_record.get("funding_number")
                existing_record["last_cumulative_date"] = str(datetime.now())
                existing_record["status"] = "Ù†Ø´Ø·"
                self.save_json(FUNDING_NUMBERS_FILE, self.funding_numbers)
                return funding_number

        self.funding_numbers["last_number"] += 1
        funding_number = self.funding_numbers["last_number"]

        funding_record = {
            "funding_number": funding_number,
            "funding_type": funding_type,
            "date": str(datetime.now()),
            "channel_id": channel_id if funding_type == "channel" else None,
            "bot_id": bot_id if funding_type == "bot" else None,
            "status": "Ù†Ø´Ø·",
            "is_cumulative": is_cumulative
        }

        self.funding_numbers["records"][str(funding_number)] = funding_record
        self.save_json(FUNDING_NUMBERS_FILE, self.funding_numbers)

        return funding_number

    def cleanup_old_funding_numbers(self):
        """ØªÙ†Ø¸ÙŠÙ Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© ÙˆØ§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù…"""
        try:
            current_time = datetime.now()
            records_to_remove = []

            for fund_num, fund_record in self.funding_numbers["records"].items():
                if fund_record.get("status") == "Ù…ÙƒØªÙ…Ù„":
                    try:
                        completion_date = datetime.strptime(
                            fund_record.get("status_update_date", fund_record.get("date")), 
                            '%Y-%m-%d %H:%M:%S.%f'
                        )
                        days_passed = (current_time - completion_date).days
                        if days_passed > 30:
                            records_to_remove.append(fund_num)
                    except:
                        records_to_remove.append(fund_num)

            for record_id in records_to_remove:
                del self.funding_numbers["records"][record_id]

            if records_to_remove:
                self.save_json(FUNDING_NUMBERS_FILE, self.funding_numbers)
                logger.info(f"ØªÙ… ØªÙ†Ø¸ÙŠÙ {len(records_to_remove)} Ø³Ø¬Ù„ ØªÙ…ÙˆÙŠÙ„ Ù‚Ø¯ÙŠÙ…")

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©: {e}")

    def update_funding_status(self, funding_number, status):
        """ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„ (Ù…ÙƒØªÙ…Ù„/Ù…Ù„ØºÙŠ) Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„"""
        if str(funding_number) in self.funding_numbers["records"]:
            self.funding_numbers["records"][str(funding_number)]["status"] = status
            self.funding_numbers["records"][str(funding_number)]["status_update_date"] = str(datetime.now())
            self.save_json(FUNDING_NUMBERS_FILE, self.funding_numbers)
            return True
        return False

    def get_funding_info(self, funding_number):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„"""
        return self.funding_numbers["records"].get(str(funding_number), None)

    def cancel_funding_keep_data(self, funding_id, funding_type="channel", cancellation_reason="Ø¥Ù„ØºØ§Ø¡ ØªÙ„Ù‚Ø§Ø¦ÙŠ"):
        """Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ù…Ø¹ Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªÙ…ÙˆÙŠÙ„ Ø§Ù„ØªØ±Ø§ÙƒÙ…ÙŠ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠ"""
        try:
            if funding_type == "channel":
                if funding_id in self.funded_channels:
                    self.funded_channels[funding_id]['cancellation_date'] = str(datetime.now())
                    self.funded_channels[funding_id]['cancellation_reason'] = cancellation_reason
                    self.funded_channels[funding_id]['status'] = 'Ù…Ù„ØºÙŠ'
                    self.funded_channels[funding_id]['is_cancelled'] = True

                    funding_record = self.get_funding_record_by_id(funding_id, "channel")
                    if funding_record:
                        funding_number = funding_record.get("funding_number")
                        if funding_number:
                            self.update_funding_status(funding_number, "Ù…Ù„ØºÙŠ")

            elif funding_type == "bot":
                if funding_id in self.funded_bots:
                    self.funded_bots[funding_id]['cancellation_date'] = str(datetime.now())
                    self.funded_bots[funding_id]['cancellation_reason'] = cancellation_reason
                    self.funded_bots[funding_id]['status'] = 'Ù…Ù„ØºÙŠ'
                    self.funded_bots[funding_id]['is_cancelled'] = True

                    funding_record = self.get_funding_record_by_id(funding_id, "bot")
                    if funding_record:
                        funding_number = funding_record.get("funding_number")
                        if funding_number:
                            self.update_funding_status(funding_number, "Ù…Ù„ØºÙŠ")

            self.save_json(FUNDED_CHANNELS_FILE if funding_type == "channel" else FUNDED_BOTS_FILE, 
                          self.funded_channels if funding_type == "channel" else self.funded_bots)
            return True

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ {funding_id}: {e}")
            return False

    def reactivate_cumulative_funding(self, funding_id, funding_type="channel", additional_members=0, additional_cost=0):
        """Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù…Ù„ØºÙŠ ÙƒØªÙ…ÙˆÙŠÙ„ ØªØ±Ø§ÙƒÙ…ÙŠ"""
        try:
            if funding_type == "channel":
                if funding_id in self.funded_channels:
                    funding_data = self.funded_channels[funding_id]

                    funding_data['status'] = 'Ù†Ø´Ø·'
                    funding_data['is_cancelled'] = False
                    funding_data['reactivation_date'] = str(datetime.now())

                    current_members = funding_data.get('members_funded', 0)
                    current_cost = funding_data.get('cost_paid', 0)

                    funding_data['members_funded'] = current_members + additional_members
                    funding_data['cost_paid'] = current_cost + additional_cost

                    funding_record = self.get_funding_record_by_id(funding_id, "channel")
                    if funding_record:
                        funding_number = funding_record.get("funding_number")
                        if funding_number:
                            self.update_funding_status(funding_number, "Ù†Ø´Ø·")

                    return funding_record.get("funding_number") if funding_record else None

            elif funding_type == "bot":
                if funding_id in self.funded_bots:
                    funding_data = self.funded_bots[funding_id]

                    funding_data['status'] = 'Ù†Ø´Ø·'
                    funding_data['is_cancelled'] = False
                    funding_data['reactivation_date'] = str(datetime.now())

                    current_members = funding_data.get('members_funded', 0)
                    current_cost = funding_data.get('cost_paid', 0)

                    funding_data['members_funded'] = current_members + additional_members
                    funding_data['cost_paid'] = current_cost + additional_cost

                    funding_record = self.get_funding_record_by_id(funding_id, "bot")
                    if funding_record:
                        funding_number = funding_record.get("funding_number")
                        if funding_number:
                            self.update_funding_status(funding_number, "Ù†Ø´Ø·")

                    return funding_record.get("funding_number") if funding_record else None

            return None

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ {funding_id}: {e}")
            return None

    def move_funding_to_completed(self, funding_id, funding_type="channel"):
        """Ù†Ù‚Ù„ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù…ÙƒØªÙ…Ù„ Ø¥Ù„Ù‰ Ù‚Ø³Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© Ù…Ø¹ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­"""
        try:
            if funding_type == "channel":
                if funding_id in self.funded_channels:
                    funding_data = self.funded_channels[funding_id].copy()
                    funding_data['completion_date'] = str(datetime.now())
                    funding_data['moved_to_completed'] = True
                    funding_data['funding_type'] = funding_type
                    funding_data['status'] = 'Ù…ÙƒØªÙ…Ù„'

                    funding_record = self.get_funding_record_by_id(funding_id, "channel")
                    if funding_record:
                        funding_data['funding_number'] = funding_record.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­")
                        self.update_funding_status(funding_record.get("funding_number"), "Ù…ÙƒØªÙ…Ù„")
                    else:
                        funding_data['funding_number'] = "ØºÙŠØ± Ù…ØªØ§Ø­"

                    if funding_id in self.paid_channels:
                        funding_data['final_members_count'] = self.paid_channels[funding_id].get('total_subscribers_count', 0)
                        funding_data['channel_invite_link'] = self.paid_channels[funding_id].get('invite_link', '')
                        funding_data['channel_name'] = self.paid_channels[funding_id].get('name', funding_data.get('channel_name', ''))

                    timestamp = int(datetime.now().timestamp())
                    unique_key = f"{funding_id}_{timestamp}"

                    self.completed_fundings["channels"][unique_key] = funding_data

                    owner_id = funding_data.get('owner_id')
                    if owner_id and str(owner_id) in self.users:
                        user = self.users[str(owner_id)]
                        if "funded_channels" in user and funding_id in user["funded_channels"]:
                            user["funded_channels"].remove(funding_id)

                    del self.funded_channels[funding_id]

                    self.save_json(COMPLETED_FUNDINGS_FILE, self.completed_fundings)
                    self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)


                    logger.info(f"ØªÙ… Ù†Ù‚Ù„ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ {funding_id} Ø¥Ù„Ù‰ Ù‚Ø³Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© Ø¨Ù…ÙØªØ§Ø­ {unique_key} ÙˆØ±Ù‚Ù… ØªÙ…ÙˆÙŠÙ„ {funding_data['funding_number']} ÙˆØ­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©")
                    return True

            elif funding_type == "bot":
                if funding_id in self.funded_bots:
                    funding_data = self.funded_bots[funding_id].copy()
                    funding_data['completion_date'] = str(datetime.now())
                    funding_data['moved_to_completed'] = True
                    funding_data['funding_type'] = funding_type
                    funding_data['status'] = 'Ù…ÙƒØªÙ…Ù„'

                    funding_record = self.get_funding_record_by_id(funding_id, "bot")
                    if funding_record:
                        funding_data['funding_number'] = funding_record.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­")
                        self.update_funding_status(funding_record.get("funding_number"), "Ù…ÙƒØªÙ…Ù„")
                    else:
                        funding_data['funding_number'] = "ØºÙŠØ± Ù…ØªØ§Ø­"

                    if funding_id in self.paid_bots:
                        funding_data['final_members_count'] = self.paid_bots[funding_id].get('total_subscribers_count', 0)
                        funding_data['bot_username'] = self.paid_bots[funding_id].get('username', '')
                        funding_data['bot_name'] = self.paid_bots[funding_id].get('name', funding_data.get('bot_name', ''))

                    timestamp = int(datetime.now().timestamp())
                    unique_key = f"{funding_id}_{timestamp}"

                    self.completed_fundings["bots"][unique_key] = funding_data

                    owner_id = funding_data.get('owner_id')
                    if owner_id and str(owner_id) in self.users:
                        user = self.users[str(owner_id)]
                        if "funded_bots" in user and funding_id in user["funded_bots"]:
                            user["funded_bots"].remove(funding_id)

                    del self.funded_bots[funding_id]

                    self.save_json(COMPLETED_FUNDINGS_FILE, self.completed_fundings)
                    self.save_json(FUNDED_BOTS_FILE, self.funded_bots)


                    logger.info(f"ØªÙ… Ù†Ù‚Ù„ ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙˆØª {funding_id} Ø¥Ù„Ù‰ Ù‚Ø³Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© Ø¨Ù…ÙØªØ§Ø­ {unique_key} ÙˆØ±Ù‚Ù… ØªÙ…ÙˆÙŠÙ„ {funding_data['funding_number']} ÙˆØ­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©")
                    return True

            return False

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù†Ù‚Ù„ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ {funding_id} Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ù…ÙƒØªÙ…Ù„: {e}")
            return False

    def get_user_fundings_from_permanent_record(self, user_id):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¢Ø®Ø± 5 ØªÙ…ÙˆÙŠÙ„Ø§Øª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„Ø¯Ø§Ø¦Ù…"""
        user_fundings = []

        for channel_id, funding_info in self.funded_channels.items():
            if funding_info.get('owner_id') == user_id:
                funding_record = self.get_funding_record_by_id(channel_id, "channel")
                status, current_count, required_count = self.determine_funding_status(channel_id, funding_info, "channel")

                user_fundings.append({
                    "id": channel_id,
                    "type": "Ù‚Ù†Ø§Ø©",
                    "name": funding_info.get('channel_name', 'Ù‚Ù†Ø§Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©'),
                    "status": status,
                    "current_count": current_count,
                    "required_count": required_count,
                    "funding_number": funding_record.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­") if funding_record else "ØºÙŠØ± Ù…ØªØ§Ø­",
                    "date": funding_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'),
                    "cost": funding_info.get('cost_paid', 0),
                    "funding_date_obj": self.parse_date_string(funding_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'))
                })

        for bot_id, funding_info in self.funded_bots.items():
            if funding_info.get('owner_id') == user_id:
                funding_record = self.get_funding_record_by_id(bot_id, "bot")
                status, current_count, required_count = self.determine_funding_status(bot_id, funding_info, "bot")

                user_fundings.append({
                    "id": bot_id,
                    "type": "Ø¨ÙˆØª",
                    "name": funding_info.get('bot_name', 'Ø¨ÙˆØª ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'),
                    "status": status,
                    "current_count": current_count,
                    "required_count": required_count,
                    "funding_number": funding_record.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­") if funding_record else "ØºÙŠØ± Ù…ØªØ§Ø­",
                    "date": funding_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'),
                    "cost": funding_info.get('cost_paid', 0),
                    "funding_date_obj": self.parse_date_string(funding_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'))
                })

        for unique_key, completed_info in self.completed_fundings.get("channels", {}).items():
            if completed_info.get('owner_id') == user_id:
                user_fundings.append({
                    "id": unique_key,
                    "type": "Ù‚Ù†Ø§Ø©",
                    "name": completed_info.get('channel_name', 'Ù‚Ù†Ø§Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©'),
                    "status": "Ù…ÙƒØªÙ…Ù„ ğŸŸ¢",
                    "current_count": completed_info.get('final_members_count', completed_info.get('members_funded', 0)),
                    "required_count": completed_info.get('members_funded', 0),
                    "funding_number": completed_info.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­"),
                    "date": completed_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'),
                    "cost": completed_info.get('cost_paid', 0),
                    "funding_date_obj": self.parse_date_string(completed_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'))
                })

        for unique_key, completed_info in self.completed_fundings.get("bots", {}).items():
            if completed_info.get('owner_id') == user_id:
                user_fundings.append({
                    "id": unique_key,
                    "type": "Ø¨ÙˆØª", 
                    "name": completed_info.get('bot_name', 'Ø¨ÙˆØª ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'),
                    "status": "Ù…ÙƒØªÙ…Ù„ ğŸŸ¢",
                    "current_count": completed_info.get('final_members_count', completed_info.get('members_funded', 0)),
                    "required_count": completed_info.get('members_funded', 0),
                    "funding_number": completed_info.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­"),
                    "date": completed_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'),
                    "cost": completed_info.get('cost_paid', 0),
                    "funding_date_obj": self.parse_date_string(completed_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'))
                })

        user_fundings.sort(key=lambda x: x['funding_date_obj'], reverse=True)

        self.cleanup_old_completed_fundings(user_id, user_fundings)

        return user_fundings[:5]  # Ø¥Ø±Ø¬Ø§Ø¹ Ø¢Ø®Ø± 5 ØªÙ…ÙˆÙŠÙ„Ø§Øª ÙÙ‚Ø·

    def parse_date_string(self, date_string):
        """ØªØ­ÙˆÙŠÙ„ Ù†Øµ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù† datetime Ù„Ù„ØªØ±ØªÙŠØ¨"""
        try:
            if date_string == 'ØºÙŠØ± Ù…ØªØ§Ø­':
                return datetime.min

            try:
                return datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S.%f')
            except:
                try:
                    return datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S')
                except:
                    try:
                        return datetime.strptime(date_string[:19], '%Y-%m-%d %H:%M:%S')
                    except:
                        return datetime.min
        except:
            return datetime.min

    def cleanup_old_completed_fundings(self, user_id, current_fundings):
        """Ø­Ø°Ù Ø§Ù„ØªÙ…ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© ÙˆØ§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø¢Ø®Ø± 5 ÙÙ‚Ø·"""
        try:
            user_completed_channels = []
            user_completed_bots = []

            for unique_key, completed_info in self.completed_fundings.get("channels", {}).items():
                if completed_info.get('owner_id') == user_id:
                    date_obj = self.parse_date_string(completed_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'))
                    user_completed_channels.append((unique_key, date_obj))

            for unique_key, completed_info in self.completed_fundings.get("bots", {}).items():
                if completed_info.get('owner_id') == user_id:
                    date_obj = self.parse_date_string(completed_info.get('date', 'ØºÙŠØ± Ù…ØªØ§Ø­'))
                    user_completed_bots.append((unique_key, date_obj))

            user_completed_channels.sort(key=lambda x: x[1], reverse=True)
            user_completed_bots.sort(key=lambda x: x[1], reverse=True)

            channels_to_keep = user_completed_channels[:3]
            bots_to_keep = user_completed_bots[:3]

            for unique_key, _ in user_completed_channels[3:]:
                if unique_key in self.completed_fundings.get("channels", {}):
                    del self.completed_fundings["channels"][unique_key]

            for unique_key, _ in user_completed_bots[3:]:
                if unique_key in self.completed_fundings.get("bots", {}):
                    del self.completed_fundings["bots"][unique_key]

            if len(user_completed_channels) > 3 or len(user_completed_bots) > 3:
                self.save_json(COMPLETED_FUNDINGS_FILE, self.completed_fundings)

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø§Ù„ØªÙ…ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©: {e}")

    def get_funding_record_by_id(self, funding_id, funding_type):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø³Ø¬Ù„ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ø±Ù ÙˆØ§Ù„Ù†ÙˆØ¹ - ÙŠØ¹ÙŠØ¯ Ø¢Ø®Ø± Ø³Ø¬Ù„ (Ø§Ù„Ø£Ø­Ø¯Ø«)"""
        matching_records = []

        for fund_num, fund_record in self.funding_numbers["records"].items():
            if funding_type == "channel" and fund_record.get("channel_id") == funding_id:
                matching_records.append((int(fund_num), fund_record))
            elif funding_type == "bot" and fund_record.get("bot_id") == funding_id:
                matching_records.append((int(fund_num), fund_record))

        if matching_records:
            matching_records.sort(key=lambda x: x[0], reverse=True)
            return matching_records[0][1]

        return None

    def determine_funding_status(self, funding_id, funding_info, funding_type):
        """ØªØ­Ø¯ÙŠØ¯ Ø­Ø§Ù„Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ÙˆØ§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙˆØ§Ù„Ù…Ø·Ù„ÙˆØ¨"""
        if funding_type == "channel":
            funding_status = funding_info.get('status', 'Ù†Ø´Ø·')
            is_cancelled = funding_info.get('is_cancelled', False)

            if funding_status == 'Ù…ÙƒØªÙ…Ù„':
                return "Ù…ÙƒØªÙ…Ù„ ğŸŸ¢", funding_info.get('members_funded', 0), funding_info.get('members_funded', 0)
            elif is_cancelled or funding_status == 'Ù…Ù„ØºÙŠ':
                return "Ù…Ù„ØºÙŠ ğŸ”´", 0, funding_info.get('members_funded', 0)
            elif funding_id in self.paid_channels:
                current_count = self.paid_channels[funding_id].get('total_subscribers_count', 0)
                required_count = self.paid_channels[funding_id].get('members_required', 0)
                if current_count >= required_count:
                    return "Ù…ÙƒØªÙ…Ù„ ğŸŸ¢", current_count, required_count
                else:
                    return "Ù†Ø´Ø· ğŸŸ¡", current_count, required_count
            else:
                return "Ù…Ù„ØºÙŠ ğŸ”´", 0, funding_info.get('members_funded', 0)

        elif funding_type == "bot":
            funding_status = funding_info.get('status', 'Ù†Ø´Ø·')
            is_cancelled = funding_info.get('is_cancelled', False)

            if funding_status == 'Ù…ÙƒØªÙ…Ù„':
                return "Ù…ÙƒØªÙ…Ù„ ğŸŸ¢", funding_info.get('members_funded', 0), funding_info.get('members_funded', 0)
            elif is_cancelled or funding_status == 'Ù…Ù„ØºÙŠ':
                return "Ù…Ù„ØºÙŠ ğŸ”´", 0, funding_info.get('members_funded', 0)
            elif funding_id in self.paid_bots:
                current_count = self.paid_bots[funding_id].get('total_subscribers_count', 0)
                required_count = self.paid_bots[funding_id].get('members_required', 0)
                if current_count >= required_count:
                    return "Ù…ÙƒØªÙ…Ù„ ğŸŸ¢", current_count, required_count
                else:
                    return "Ù†Ø´Ø· ğŸŸ¡", current_count, required_count
            else:
                return "Ù…Ù„ØºÙŠ ğŸ”´", 0, funding_info.get('members_funded', 0)

        return "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ", 0, 0


    def start_admin_check(self):
        if self.admin_check_running:
            return
        self.admin_check_running = True
        self.admin_check_thread = threading.Thread(target=self.admin_check_loop, daemon=True)
        self.admin_check_thread.start()
        pass  # Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨ØµÙ…Øª
    def stop_admin_check(self):
        self.admin_check_running = False
        if self.admin_check_thread and self.admin_check_thread.is_alive():
            self.admin_check_thread.join(timeout=5)
        pass  # Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨ØµÙ…Øª
    def admin_check_loop(self):
        while self.admin_check_running:
            try:
                for i in range(3600):
                    if not self.admin_check_running:
                        break
                    time.sleep(1)
                if self.admin_check_running:
                    asyncio.run(self.check_admin_permissions())

            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø´Ø±Ù: {e}")
                time.sleep(300)
    async def check_admin_permissions(self):
        try:
            app = Application.builder().token(BOT_TOKEN).build()
            channels_to_cancel = []

            for channel_id, channel_info in list(self.paid_channels.items()):
                try:
                    bot_member = await app.bot.get_chat_member(channel_id, app.bot.id)
                    if bot_member.status not in ['administrator', 'creator']:
                        channels_to_cancel.append(channel_id)

                        funding_number = None
                        for fund_num, fund_record in self.funding_numbers["records"].items():
                            if fund_record.get("channel_id") == channel_id and fund_record.get("funding_type") == "channel":
                                funding_number = fund_num
                                self.update_funding_status(funding_number, "Ù…Ù„ØºÙŠ")
                                break

                        if channel_id in self.funded_channels:
                            funded_info = self.funded_channels[channel_id]
                            owner_id = funded_info['owner_id']

                            self.cancel_funding_keep_data(channel_id, "channel", "Ø§Ù„Ø¨ÙˆØª Ù„Ù… ÙŠØ¹Ø¯ Ù…Ø´Ø±ÙØ§Ù‹ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©")

                            try:
                                message = f"âš ï¸ ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªÙ…ÙˆÙŠÙ„ Ù‚Ù†Ø§ØªÙƒ!\n\n"
                                message += f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_info['name']}\n"
                                if funding_number:
                                    message += f"ğŸ”¢ Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: #{funding_number}\n"
                                message += f"âŒ Ø§Ù„Ø³Ø¨Ø¨: Ø§Ù„Ø¨ÙˆØª Ù„Ù… ÙŠØ¹Ø¯ Ù…Ø´Ø±ÙØ§Ù‹ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©\n\n"
                                message += f"ğŸ’¡ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„ØŒ ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØª Ù…Ø´Ø±ÙØ§Ù‹ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ ÙˆØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù‚Ù†Ø§Ø© Ù…Ù† Ø¬Ø¯ÙŠØ¯\n"
                                message += f"âœ… Ø³ÙŠÙƒÙˆÙ† Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ØªØ±Ø§ÙƒÙ…ÙŠ ÙÙˆÙ‚ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ø¨Ù†ÙØ³ Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„"

                                await app.bot.send_message(owner_id, message)
                            except Exception as e:
                                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„ØµØ§Ø­Ø¨ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ {owner_id}: {e}")

                        try:
                            admin_message = f"ğŸš¨ ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªÙ…ÙˆÙŠÙ„ Ù‚Ù†Ø§Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹!\n\n"
                            admin_message += f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_info['name']}\n"
                            admin_message += f"ğŸ†” Ù…Ø¹Ø±Ù Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_id}\n"
                            if funding_number:
                                admin_message += f"ğŸ”¢ Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: #{funding_number}\n"
                            admin_message += f"âŒ Ø§Ù„Ø³Ø¨Ø¨: Ø§Ù„Ø¨ÙˆØª Ù„Ù… ÙŠØ¹Ø¯ Ù…Ø´Ø±ÙØ§Ù‹ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©\n"
                            admin_message += f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ø¥Ù„ØºØ§Ø¡: {self.format_time_12h(datetime.now())}"

                            await app.bot.send_message(ADMIN_ID, admin_message)
                        except Exception as e:
                            logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø¥Ù„ØºØ§Ø¡ Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")

                except Exception as e:
                    logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø© {channel_id}: {e}")

            for channel_id in channels_to_cancel:
                if channel_id in self.paid_channels:
                    del self.paid_channels[channel_id]

                if channel_id in self.monitored_channels:
                    del self.monitored_channels[channel_id]

            if channels_to_cancel:
                self.save_data_to_db('paid_channels', self.paid_channels)
                self.save_json(MONITORED_CHANNELS_FILE, self.monitored_channels)
                self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)

                pass  # ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ù„Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø­Ø°ÙˆÙØ©

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø´Ø±Ù: {e}")

    async def delete_old_mandatory_message(self, context, user_id):
        try:
            user_id_str = str(user_id)

            if user_id_str in self.user_mandatory_messages:
                try:
                    message_id = self.user_mandatory_messages[user_id_str]
                    await context.bot.delete_message(chat_id=user_id, message_id=message_id)
                except Exception:
                    pass  # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø¨ØµÙ…Øª
                finally:
                    del self.user_mandatory_messages[user_id_str]
        except Exception:
            pass
    async def get_channel_member_count(self, context, channel_id):
        try:
            chat = await context.bot.get_chat(channel_id)
            return chat.member_count if hasattr(chat, 'member_count') else 0
        except:
            return 0
    async def is_user_member_of_channel(self, context, channel_id, user_id):
        try:
            member = await context.bot.get_chat_member(channel_id, user_id)
            return member.status in ['member', 'administrator', 'creator']
        except Exception:
            return False
    async def get_next_paid_channel(self, user_id, context):
        user_subscriptions = self.user_channel_subscriptions.get(str(user_id), {})
        for channel_id, channel_info in self.paid_channels.items():
            if channel_id not in user_subscriptions:
                is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
                if not is_member:
                    return channel_id, channel_info
        return None, None

    async def get_next_paid_channel_after_skip(self, user_id, current_channel_id, context):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© Ø¨Ø¹Ø¯ ØªØ®Ø·ÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©"""
        user_subscriptions = self.user_channel_subscriptions.get(str(user_id), {})
        channels_list = list(self.paid_channels.items())

        current_index = -1
        for i, (channel_id, channel_info) in enumerate(channels_list):
            if channel_id == current_channel_id:
                current_index = i
                break

        start_index = current_index + 1 if current_index != -1 else 0

        for i in range(start_index, len(channels_list)):
            channel_id, channel_info = channels_list[i]
            if channel_id not in user_subscriptions:
                is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
                if not is_member:
                    return channel_id, channel_info

        for i in range(0, start_index):
            channel_id, channel_info = channels_list[i]
            if channel_id not in user_subscriptions:
                is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
                if not is_member:
                    return channel_id, channel_info

        return None, None
    async def get_top_referrers(self, context):
        referrers_with_usernames = []

        for referrer in self.top_referrers:
            try:
                user_chat = await context.bot.get_chat(int(referrer["user_id"]))
                if user_chat.username:
                    username = f"@{user_chat.username}"
                else:
                    username = user_chat.first_name or "Ù…Ø³ØªØ®Ø¯Ù…"
            except:
                username = "Ù…Ø³ØªØ®Ø¯Ù…"
            referrers_with_usernames.append({
                "user_id": referrer["user_id"],
                "username": username,
                "count": referrer["count"]
            })
        return referrers_with_usernames
    async def check_paid_subscriptions_and_deduct(self, user_id, context):
        user_id_str = str(user_id)
        if user_id_str not in self.user_channel_subscriptions:
            return
        user_subs = self.user_channel_subscriptions[user_id_str]
        if not user_subs:
            return
        last_check_key = f"last_check_{user_id_str}"
        current_time = datetime.now()
        if hasattr(self, 'user_last_checks'):
            last_check = self.user_last_checks.get(last_check_key)
            if last_check and (current_time - last_check).total_seconds() < 30:  # 30 Ø«Ø§Ù†ÙŠØ©
                return
        else:
            self.user_last_checks = {}
        channels_to_check = []
        for channel_id in user_subs.keys():
            if channel_id in self.paid_channels or channel_id in self.monitored_channels:
                channels_to_check.append(channel_id)

        if not channels_to_check:
            return

        self.user_last_checks[last_check_key] = current_time
        max_concurrent = min(2, len(channels_to_check))  # ØªÙ‚Ù„ÙŠÙ„ Ø¥Ù„Ù‰ 2 ÙØ­ÙˆØµØ§Øª ÙÙ‚Ø·

        async def check_single_channel(channel_id):
            try:
                return channel_id, await asyncio.wait_for(
                    self.is_user_member_of_channel(context, channel_id, user_id),
                    timeout=3  # ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ù…Ù‡Ù„Ø© Ø¥Ù„Ù‰ 3 Ø«ÙˆØ§Ù†
                )
            except (asyncio.TimeoutError, Exception):
                return channel_id, True  # Ø§ÙØªØ±Ø§Ø¶ Ø§Ù„Ø¹Ø¶ÙˆÙŠØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£
        results = []
        for i in range(0, len(channels_to_check), max_concurrent):
            batch = channels_to_check[i:i + max_concurrent]
            batch_tasks = [check_single_channel(channel_id) for channel_id in batch]
            try:
                batch_results = await asyncio.wait_for(
                    asyncio.gather(*batch_tasks, return_exceptions=True),
                    timeout=15  # Ø­Ø¯ Ø£Ù‚ØµÙ‰ 15 Ø«Ø§Ù†ÙŠØ© Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
                )
                for result in batch_results:
                    if not isinstance(result, Exception):
                        results.append(result)
            except asyncio.TimeoutError:
                for channel_id in batch:
                    results.append((channel_id, True))
        user = self.get_user(user_id)
        points_deducted = 0
        channels_to_remove = []
        deduction_details = []
        for channel_id, is_member in results:
            if not is_member:
                sub_info = user_subs.get(channel_id)
                if sub_info:
                    points_deducted += sub_info.get('points', 0)
                    channels_to_remove.append(channel_id)
                    channel_name = "Ù‚Ù†Ø§Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©"
                    if channel_id in self.paid_channels:
                        channel_name = self.paid_channels[channel_id]['name']
                    elif channel_id in self.monitored_channels:
                        channel_name = self.monitored_channels[channel_id]['name']
                    deduction_details.append({
                        'channel_name': channel_name,
                        'points': sub_info.get('points', 0)
                    })
        if channels_to_remove:
            user['points'] -= points_deducted
            for channel_id in channels_to_remove:
                if channel_id in self.user_channel_subscriptions[user_id_str]:
                    del self.user_channel_subscriptions[user_id_str][channel_id]
            if not self.user_channel_subscriptions[user_id_str]:
                del self.user_channel_subscriptions[user_id_str]
            for detail in deduction_details:
                try:
                    await context.bot.send_message(
            user_id,
            f"â• ØªÙ… Ø±ØµØ¯ Ù…ØºØ§Ø¯Ø±ØªÙƒ Ù…Ù†: {detail['channel_name']}\n"
                        f"â— ÙˆØªÙ… Ø®ØµÙ… Ù…Ù†Ùƒ {self.format_points(detail['points'])}â­ Ø­Ø³Ø¨ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø©.\n"
                    )
                except Exception as e:
                    logger.error(f"ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®ØµÙ… Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}: {e}")
            await self.delayed_save_data()
    def update_user_activity(self, user_id):
        """ØªØ­Ø¯ÙŠØ« Ù†Ø´Ø§Ø· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨ÙƒÙØ§Ø¡Ø©"""
        user_id_str = str(user_id)
        if user_id_str in self.users:
            self.users[user_id_str]["last_activity"] = str(datetime.now())
            self.save_user_to_db(user_id, self.users[user_id_str])


    async def delayed_save_data(self):
        if not hasattr(self, '_data_save_pending'):
            self._data_save_pending = True
            await asyncio.sleep(2)
            try:
                await asyncio.gather(
                    asyncio.to_thread(self.save_data_to_db, 'users', self.users),
                    asyncio.to_thread(self.save_data_to_db, 'user_channel_subscriptions', self.user_channel_subscriptions)
                )
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù…Ø¤Ø¬Ù„: {e}")
            finally:
                if hasattr(self, '_data_save_pending'):
                    del self._data_save_pending

    async def send_subscription_notification(self, context, user_id, channel_info, current_count, required_count):
        try:
            await context.bot.send_message(
                ADMIN_ID,
                f"ğŸ”” Ø§Ø´ØªØ±Ø§Ùƒ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©!\n\n"
                f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_info['name']}\n"
                f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\n"
                f"ğŸ“Š Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ: {current_count}/{required_count}\n"
                f"ğŸ“ˆ Ø§Ù„ØªÙ‚Ø¯Ù…: {int((current_count/required_count)*100) if required_count > 0 else 0}%"
            )
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ: {e}")

    async def send_completion_notification(self, context, channel_info, required_count, current_count, channel_id):
        try:
            await context.bot.send_message(
                ADMIN_ID,
                f"ğŸ‰ ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©!\n\n"
                f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_info['name']}\n"
                f"ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {required_count}\n"
                f"âœ… Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ: {current_count}\n\n"
                f"ğŸ”„ ØªÙ… Ø­Ø°Ù Ø§Ù„Ù‚Ù†Ø§Ø© Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø§Ø¬Ø¨Ø§Ø±ÙŠ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„Ù‡ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ â™»ï¸."
            )
            if channel_id in self.mandatory_channels:
                del self.mandatory_channels[channel_id]
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ø¹Ø¯Ø¯: {e}")

    async def async_save_mandatory_data(self, user_id_str, user_mandatory_subs):
        try:
            self.mandatory_subscriptions[user_id_str] = user_mandatory_subs
            await asyncio.gather(
                asyncio.to_thread(self.save_json, MANDATORY_SUBSCRIPTIONS_FILE, self.mandatory_subscriptions),
                asyncio.to_thread(self.save_json, MANDATORY_CHANNELS_FILE, self.mandatory_channels)
            )
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª: {e}")

    async def check_mandatory_subscriptions_status(self, user_id, context):
        if not self.mandatory_enabled or not self.mandatory_channels:
            return

        user_id_str = str(user_id)
        user_mandatory_subs = self.mandatory_subscriptions.get(user_id_str, {})

        channel_ids = list(self.mandatory_channels.keys())

        async def check_channel_fast(channel_id):
            try:
                return channel_id, await asyncio.wait_for(
                    self.is_user_member_of_channel(context, channel_id, user_id),
                    timeout=3  # 3 Ø«ÙˆØ§Ù† Ù„ÙƒÙ„ Ù‚Ù†Ø§Ø©
                )
            except:
                return channel_id, True

        results = []
        for i in range(0, len(channel_ids), 2):
            batch = channel_ids[i:i + 2]
            batch_tasks = [check_channel_fast(channel_id) for channel_id in batch]
            try:
                batch_results = await asyncio.wait_for(
                    asyncio.gather(*batch_tasks, return_exceptions=True),
                    timeout=10
                )
                for result in batch_results:
                    if not isinstance(result, Exception):
                        results.append(result)
            except:
                for channel_id in batch:
                    results.append((channel_id, True))

        for channel_id, is_member in results:
            if isinstance(user_mandatory_subs.get(channel_id), dict):
                user_mandatory_subs[channel_id]["subscribed"] = is_member
                user_mandatory_subs[channel_id]["last_check"] = str(datetime.now())
            else:
                was_counted = user_mandatory_subs.get(channel_id, False)
                user_mandatory_subs[channel_id] = {
                    "subscribed": is_member,
                    "counted": bool(was_counted),
                    "last_check": str(datetime.now())
                }

        self.mandatory_subscriptions[user_id_str] = user_mandatory_subs
        asyncio.create_task(asyncio.to_thread(self.save_json, MANDATORY_SUBSCRIPTIONS_FILE, self.mandatory_subscriptions))

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not update.message or not update.effective_user:
            return
        if update.message.chat.type != 'private':
            await update.message.reply_text("ØªÙˆØ§ØµÙ„ Ù…Ø¹ÙŠ ÙÙŠ Ø§Ù„Ø®Ø§Øµ.")
            return
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        self.update_user_activity(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        if str(user_id) in self.banned_users:
            await update.message.reply_text(
                "ğŸš« ØªÙ… Ø­Ø¸Ø±Ùƒ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©\n"
                "Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ¹ØªÙ‚Ø¯ Ø£Ù† Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¸Ø± Ø­Ø¯Ø« Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø®Ø·Ø£ØŒ Ù„Ø§ ØªÙ‚Ù„Ù‚ØŒ Ø¨Ø¥Ù…ÙƒØ§Ù†Ùƒ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø£Ù…Ø± : [@cxxov]\n"
                "Ù†Ø­Ù† Ù‡Ù†Ø§ Ù„Ø¯Ø¹Ù…Ùƒ ÙˆÙ†Ø³Ø¹Ù‰ Ù„ØªÙ‚Ø¯ÙŠÙ… Ø£ÙØ¶Ù„ ØªØ¬Ø±Ø¨Ø© Ù…Ù…ÙƒÙ†Ø©."
            )
            return

        invite_code = None
        gift_code = None
        if context.args:
            arg = context.args[0]
            if arg.startswith("gift_"):
                gift_code = arg.split("gift_")[1]
            else:
                invite_code = arg

        is_new_user = user.get("first_join", True)
        mandatory_result = await self.check_mandatory_subscriptions(update, context)
        if not mandatory_result["all_subscribed"]:
            if invite_code and invite_code != "new":
                context.user_data['pending_invite_code'] = invite_code
            return

        if invite_code == "new" and not is_new_user:
            await self.show_main_menu(update, context)
            return

        if invite_code and invite_code != "new" and not is_new_user:
            await update.message.reply_text("âŒ Ø£Ù†Øª Ù…ÙØ¹Ù„ ÙÙŠ Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ù‚Ø¨Ù„!")
            await self.show_main_menu(update, context)
            return

        if is_new_user:
            inviter_info = None
            inviter_id = None
            if invite_code and invite_code != "new":
                for uid, user_data in self.users.items():
                    if user_data.get("invite_link") == invite_code:
                        inviter_id = uid
                        try:
                            inviter_chat = await context.bot.get_chat(int(uid))
                            if inviter_chat.username:
                                inviter_info = f"@{inviter_chat.username}"
                            else:
                                inviter_info = inviter_chat.first_name or "Ù…Ø³ØªØ®Ø¯Ù…"
                        except:
                            inviter_info = "Ù…Ø³ØªØ®Ø¯Ù…"
                        break

            if inviter_info and inviter_id:
                entry_type = f"Ø¹Ø¨Ø± Ø±Ø§Ø¨Ø· Ø¯Ø¹ÙˆØ© \\([{inviter_id}](tg://user?id={inviter_id})\\)"
            else:
                entry_type = "Ù…Ø¨Ø§Ø´Ø±"

            total_users = len(self.users)
            safe_first_name = self.escape_markdown(update.effective_user.first_name)
            safe_username = ""
            if update.effective_user.username:
                safe_username = self.escape_markdown(f"@{update.effective_user.username}")
            else:
                safe_username = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙŠÙˆØ²Ø±Ù†ÙŠÙ…"

            await context.bot.send_message(
                ADMIN_ID,
                f"ğŸ”” Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯:\n"
                f"ğŸ‘¤ {safe_first_name}\n"
                f"ğŸ“ Ø§Ù„ÙŠÙˆØ²Ø±: {safe_username}\n"
                f"ğŸ†” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: [{user_id}](tg://user?id={user_id})\n"
                f"ğŸ“¥ Ù†ÙˆØ¹ Ø§Ù„Ø¯Ø®ÙˆÙ„: {entry_type}\n"
                f"ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}",
                parse_mode='MarkdownV2'
            )
            user["first_join"] = False
            user["completed_mandatory"] = True

        if gift_code:
            result = self.use_gift_link(gift_code, user_id)
            if result["success"]:
                user_link = f"[{update.effective_user.first_name}](tg://user?id={user_id})"
                await update.message.reply_text(
                    f"ğŸ‰] ØªÙ‡Ø§Ù†ÙŠÙ†Ø§ {user_link}! ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù‡Ø¯ÙŠØ© {self.format_points(result['points'])}  ÙƒÙˆÙƒÙŠØ²!\n"
                    f"ğŸ“Š] Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n\n"
                    f"â˜ºï¸] Ù†Ø´ÙƒØ±ÙƒÙ… Ø¹Ù„Ù‰ Ø«Ù‚ØªÙƒÙ… Ø§Ù„ÙƒØ¨ÙŠØ±Ø©ØŒ ÙˆÙ†Ø³Ø¹Ù‰ Ø¯ÙˆÙ…Ø§Ù‹ Ù„ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø£ÙØ¶Ù„ Ù„ÙƒÙ….",
                    parse_mode='Markdown'
                )
                try:
                    safe_first_name = self.escape_markdown(update.effective_user.first_name)
                    safe_username = ""
                    if update.effective_user.username:
                        safe_username = self.escape_markdown(f"@{update.effective_user.username}")
                    else:
                        safe_username = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙŠÙˆØ²Ø±Ù†ÙŠÙ…"

                    user_link_admin = f"[{user_id}](tg://user?id={user_id})"
                    await context.bot.send_message(
                        ADMIN_ID,
                        f"ğŸ ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø±Ø§Ø¨Ø· Ù‡Ø¯ÙŠØ©\\!\n\n"
                        f"ğŸ‘¤ Ø§Ù„Ø§Ø³Ù…: {safe_first_name}\n"
                        f"ğŸ“ Ø§Ù„ÙŠÙˆØ²Ø±: {safe_username}\n"
                        f"ğŸ†” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {user_link_admin}\n"
                        f"ğŸ’° Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ù…Ø­ØµÙ„Ø©: {self.format_points(result['points'])}\n"
                        f"ğŸ‘¥ Ù…ØªØ¨Ù‚ÙŠ Ù„Ù„Ø±Ø§Ø¨Ø·: {result['remaining']} Ù…Ø³ØªØ®Ø¯Ù…\n"
                        f"ğŸ”— ÙƒÙˆØ¯ Ø§Ù„Ø±Ø§Ø¨Ø·: {gift_code[:10]}\\.\\.\\.\n"
                        f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}",
                        parse_mode='MarkdownV2'
                    )
                except Exception as e:
                    logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø±Ø§Ø¨Ø· Ø§Ù„Ù‡Ø¯ÙŠØ©: {e}")
            else:
                await update.message.reply_text(f"âŒ {result['message']}")
            await self.show_main_menu(update, context)
            return

        if invite_code and invite_code != "new" and is_new_user:
            await self.handle_invite_link(update, context, invite_code)
        elif context.user_data.get('pending_invite_code') and user.get("completed_mandatory"):
            await self.handle_invite_link(update, context, context.user_data['pending_invite_code'])
            del context.user_data['pending_invite_code']

        await self.show_main_menu(update, context)

    async def check_mandatory_subscriptions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.mandatory_enabled or not self.mandatory_channels:
            return {"all_subscribed": True, "unsubscribed": []}
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        unsubscribed_channels = []
        user_mandatory_subs = self.mandatory_subscriptions.get(user_id_str, {})
        channel_ids = list(self.mandatory_channels.keys())
        max_concurrent = min(5, len(channel_ids))  # Ø­Ø¯ Ø£Ù‚ØµÙ‰ 3 ÙØ­ÙˆØµØ§Øª Ù…ØªÙˆØ§Ø²ÙŠØ©
        async def check_single_channel(channel_id):
            try:
                return channel_id, await asyncio.wait_for(
                    self.is_user_member_of_channel(context, channel_id, user_id),
                    timeout=5  # 5 Ø«ÙˆØ§Ù† Ù„ÙƒÙ„ Ù‚Ù†Ø§Ø©
                )
            except (asyncio.TimeoutError, Exception):
                return channel_id, True 
        results = []
        for i in range(0, len(channel_ids), max_concurrent):
            batch = channel_ids[i:i + max_concurrent]
            batch_tasks = [check_single_channel(channel_id) for channel_id in batch]

            try:
                batch_results = await asyncio.wait_for(
                    asyncio.gather(*batch_tasks, return_exceptions=True),
                    timeout=15  # Ø­Ø¯ Ø£Ù‚ØµÙ‰ 15 Ø«Ø§Ù†ÙŠØ© Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
                )
                for result in batch_results:
                    if not isinstance(result, Exception):
                        results.append(result)
            except asyncio.TimeoutError:
                for channel_id in batch:
                    results.append((channel_id, True))

        for channel_id, is_member in results:
            if not is_member:
                unsubscribed_channels.append(self.mandatory_channels[channel_id])
                user_mandatory_subs[channel_id] = {
                    "subscribed": False,
                    "counted": False,
                    "last_check": str(datetime.now())
                }
            else:
                previous_state = user_mandatory_subs.get(channel_id, {})
                was_subscribed_before = previous_state.get("subscribed", False) if isinstance(previous_state, dict) else previous_state
                was_counted_before = previous_state.get("counted", False) if isinstance(previous_state, dict) else False

                user_mandatory_subs[channel_id] = {
                    "subscribed": True,
                    "counted": was_counted_before,
                    "last_check": str(datetime.now())
                }

                if not was_subscribed_before and not was_counted_before:
                    if 'total_subscribers_count' not in self.mandatory_channels[channel_id]:
                        self.mandatory_channels[channel_id]['total_subscribers_count'] = 0

                    self.mandatory_channels[channel_id]['total_subscribers_count'] += 1
                    user_mandatory_subs[channel_id]["counted"] = True
                    user_mandatory_subs[channel_id]["first_count_date"] = str(datetime.now())

                    channel_info = self.mandatory_channels[channel_id]
                    required_count = channel_info.get('members_required', 0)
                    current_count = channel_info['total_subscribers_count']

                    asyncio.create_task(self.send_subscription_notification(context, user_id, channel_info, current_count, required_count))

                    if required_count > 0 and current_count >= required_count:
                        asyncio.create_task(self.send_completion_notification(context, channel_info, required_count, current_count, channel_id))

        asyncio.create_task(self.async_save_mandatory_data(user_id_str, user_mandatory_subs))

        if unsubscribed_channels:
            await self.delete_old_mandatory_message(context, update.effective_user.id)

            text = "âšœï¸ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¨ÙˆØª ÙˆÙ…Ù† Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„ØªØ­Ù‚Ù‚ :\n"
            keyboard = []

            for i, channel in enumerate(unsubscribed_channels, 1):
                if channel.get('username'):
                    channel_username = channel['username']
                keyboard.append([
                    InlineKeyboardButton(f" {channel_username}", url=channel['invite_link']),
                    InlineKeyboardButton("ØºÙŠØ± Ù…Ø´ØªØ±Ùƒ âŒ", callback_data="unsubscribed_status")
                ])

            bot_username = (await context.bot.get_me()).username
            if context.user_data.get('pending_invite_code'):
                invite_code = context.user_data['pending_invite_code']
                continue_url = f"https://t.me/{bot_username}?start={invite_code}"
            elif context.args and context.args[0] != "new":
                continue_url = f"https://t.me/{bot_username}?start={context.args[0]}"
            else:
                continue_url = f"https://t.me/{bot_username}?start=new"

            keyboard.append([InlineKeyboardButton("âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", url=continue_url)])

            sent_message = await update.message.reply_text(
                text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                disable_web_page_preview=True
            )

            self.user_mandatory_messages[str(update.effective_user.id)] = sent_message.message_id

            return {"all_subscribed": False, "unsubscribed": unsubscribed_channels}

        user = self.get_user(user_id)
        user["completed_mandatory"] = True


        return {"all_subscribed": True, "unsubscribed": []}

    async def handle_invite_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, invite_code):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        if user.get("used_invite"):
            return

        inviter_id = None
        inviter_username = None
        for uid, user_data in self.users.items():
            if user_data.get("invite_link") == invite_code:
                inviter_id = int(uid)
                try:
                    inviter_chat = await context.bot.get_chat(inviter_id)
                    if inviter_chat.username:
                        inviter_username = f"@{inviter_chat.username}"
                    else:
                        inviter_username = inviter_chat.first_name or "Ù…Ø³ØªØ®Ø¯Ù…"
                except:
                    inviter_username = "Ù…Ø³ØªØ®Ø¯Ù…"
                break

        if inviter_id and inviter_id != user_id:
            user["used_invite"] = invite_code

            self.users[str(inviter_id)]["points"] += self.invite_points
            self.users[str(inviter_id)]["referrals_count"] = self.users[str(inviter_id)].get("referrals_count", 0) + 1


            self.update_top_referrers()

            invite_data = {
                "inviter_id": inviter_id,
                "invited_id": user_id,
                "date": str(datetime.now()),
                "points_earned": self.invite_points
            }

            if invite_code not in self.invites:
                self.invites[invite_code] = []
            self.invites[invite_code].append(invite_data)
            self.save_json(INVITES_FILE, self.invites)

            await update.message.reply_text(
                f"ğŸ‰ Ù„Ù‚Ø¯ Ø¯Ø®Ù„Øª Ø¹Ø¨Ø± Ø±Ø§Ø¨Ø· Ø¯Ø¹ÙˆØ© Ø®Ø§Øµ Ø¨ØµØ¯ÙŠÙ‚Ùƒ {inviter_username} "
                f"ÙˆØ­ØµÙ„ Ø¹Ù„Ù‰ {self.format_points(self.invite_points)} ğŸª!"
            )

            if update.effective_user.username:
                invited_username = f"@{update.effective_user.username}"
            else:
                invited_username = update.effective_user.first_name or "Ù…Ø³ØªØ®Ø¯ ï¿½"
            await context.bot.send_message(
                inviter_id,
                f"ğŸ‰ Ø¯Ø®Ù„ {invited_username} "
                f"Ø¹Ø¨Ø± Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ ÙˆØ­ØµÙ„Øª Ø¹Ù„Ù‰ {self.format_points(self.invite_points)} ğŸª!"
            )
        elif inviter_id == user_id:
            await update.message.reply_text("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ!")

    async def show_main_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        total_users = len(self.users)

        keyboard = [
            [InlineKeyboardButton("ğŸ› Ø§Ù„Ø®Ù€Ø¯Ù…Ù€Ø§Øªâ† ğŸ“¦", callback_data="services_menu")],
            [InlineKeyboardButton("Ù‚Ø³Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ğŸ”ŠğŸ§¬", callback_data="funding_section")],
            [
                InlineKeyboardButton("ØªØ¬Ù…ÙŠØ¹ ÙƒÙˆÙƒÙŠØ² ğŸª", callback_data="collect_stars"),
                InlineKeyboardButton("ØªØ­ÙˆÙŠÙ„ ÙƒÙˆÙƒÙŠØ² â™»ï¸", callback_data="transfer_cookies")
            ],
            [InlineKeyboardButton("Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒÙˆØ¯ ğŸ", callback_data="use_gift_code")],
            [
                InlineKeyboardButton("Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙŠ ğŸ“‘", callback_data="my_info"),
                InlineKeyboardButton("Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª ğŸ“‹", callback_data="instructions")
            ],
            [                InlineKeyboardButton(f"(Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† :  {total_users} âœ… )", callback_data="users_count_display")
            ]
        ]

        if user_id == ADMIN_ID:
            keyboard.append([InlineKeyboardButton("ğŸ‘¨â€ğŸ’¼ Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", callback_data="admin_panel")])

        self.update_user_activity(user_id)

        text = f"*Ø§Ù‡Ù„Ø§ Ø¨Ùƒ* [{update.effective_user.first_name}](tg://user?id={user_id}) *ÙÙŠ Ø¨ÙˆØª ØªÙŠØ±Ø¨Ùˆ ÙÙˆÙ„Ùˆ ğŸ‘¥*\n" \
               f"            *ÙŠÙˆØ²Ø± Ù‚Ù†Ø§Ø© Ø§Ù„Ø¨ÙˆØª <( @TurboFollow2 )>*       \n" \
               f"           *ğŸªâ€¢ Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙˆÙƒÙŠØ² :* {self.format_points(user['points'])} â€¢ğŸª\n" \
               f"           *ğŸ†”â€¢ Ø§ÙŠØ¯ÙŠÙƒ :* `{user_id}` â€¢ğŸ†”\n" \

        reply_markup = InlineKeyboardMarkup(keyboard)

        if update.callback_query:
            sent_message = await update.callback_query.edit_message_text(
                text,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
        else:
            sent_message = await update.message.reply_text(
                text,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )

    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query

        if not query or not update.effective_user:
            return

        if query.message.chat.type != 'private':
            await query.answer("Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø®Ø§ØµØ© ÙÙ‚Ø·!", show_alert=True)
            return

        data = query.data
        user_id = update.effective_user.id

        if str(user_id) in self.banned_users:
            return

        if user_id != ADMIN_ID:
            on_cooldown, remaining_time = self.is_on_cooldown(user_id)
            if on_cooldown:
                await query.answer(f"Ø§Ù†ØªØ¸Ø± {remaining_time} Ø«Ø§Ù†ÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ø¶ØºØ· Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ ğŸ”´", show_alert=True)
                return

        await query.answer()

        if data in ["collect_stars", "buy_stars"] or data.startswith("buy_") or data.startswith("confirm_buy_"):
            asyncio.create_task(self.schedule_delayed_check(user_id, context))

        self.update_user_activity(user_id)

        if data == "check_subscriptions":
            mandatory_result = await self.check_mandatory_subscriptions(update, context)
            if mandatory_result["all_subscribed"]:
                if context.user_data.get('pending_invite_code'):
                    user = self.get_user(user_id)
                    user["completed_mandatory"] = True


                    await self.handle_invite_link(update, context, context.user_data['pending_invite_code'])
                    del context.user_data['pending_invite_code']

                await self.show_main_menu(update, context)

        elif data == "check_mandatory_smart":
            await self.handle_smart_mandatory_check(update, context)

        elif data == "services_menu":
            await self.show_services_menu(update, context)

        elif data == "funding_section":
            await self.show_funding_section(update, context)

        elif data == "fund_channel":
            if self.maintenance_mode["fund_channel"]:
                await query.edit_message_text(
                    self.maintenance_messages["fund_channel"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
                )
                return
            await self.show_fund_channel_menu(update, context)

        elif data == "fund_bots":
            await self.show_fund_bots_menu(update, context)

        elif data == "bot_subscription":
            await self.show_bot_subscription(update, context)

        elif data == "stars_section":
            if self.maintenance_mode["stars_section"]:
                await query.edit_message_text(
                    self.maintenance_messages["stars_section"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="services_menu")]])
                )
                return
            await self.show_stars_section(update, context)

        elif data == "invite_link":
            if self.maintenance_mode["invite_link"]:
                await query.edit_message_text(
                    self.maintenance_messages["invite_link"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
                )
                return
            await self.show_invite_link(update, context)

        elif data == "collect_stars":
            if self.maintenance_mode["collect_stars"]:
                await query.edit_message_text(
                    self.maintenance_messages["collect_stars"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
                )
                return
            await self.show_collect_cookies(update, context)
        elif data == "collect_single":
            await self.show_single_collect(update, context)
        elif data == "collect_bulk":
            await self.show_bulk_collect(update, context)
        elif data == "check_bulk_subscriptions":
            await self.check_bulk_subscriptions(update, context)
        elif data == "collect_more":
            await self.show_bulk_collect(update, context)
        elif data == "daily_gift":
            await self.handle_daily_gift(update, context)
        elif data.startswith("claim_daily_gift_"):
            await self.claim_daily_gift_new(update, context, data)
        elif data.startswith("daily_gift_claimed_"):
            await update.callback_query.answer()
        elif data.startswith("daily_gift_claimed_today_"):
            await update.callback_query.answer()
        elif data.startswith("daily_gift_future_"):
            day_number = data.split("_")[3]
            await update.callback_query.answer()
        elif data == "wheel_of_luck":
            if self.maintenance_mode["wheel_luck"]:
                await query.edit_message_text(
                    self.maintenance_messages["wheel_luck"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
                )
                return
            await self.show_wheel_menu(update, context)
        elif data == "my_info":
            await self.show_user_info(update, context)
        elif data == "instructions":
            await self.show_instructions(update, context)
        elif data == "bot_updates":
            await self.show_bot_updates(update, context)
        elif data == "my_fundings":
            await self.show_my_fundings(update, context)
        elif data.startswith("funding_details_"):
            await self.show_funding_details(update, context, data)
        elif data.startswith("header_"):
            await query.answer()
        elif data.startswith("funding_status_info_"):
            await query.answer()
        elif data.startswith("funding_progress_"):
            await query.answer()
        elif data.startswith("funding_channel_link_"):
            await self.handle_funding_channel_link(update, context, data)
        elif data.startswith("funding_bot_link_"):
            await self.handle_funding_bot_link(update, context, data)
        elif data == "admin_panel" and user_id == ADMIN_ID:
            await self.show_admin_panel(update, context)
        elif data == "back_to_main":
            await self.show_main_menu(update, context)
        elif data.startswith("buy_stars_"):
            await self.handle_stars_purchase(update, context, data)
        elif data.startswith("confirm_stars_"):
            await self.confirm_stars_purchase(update, context, data)
        elif data.startswith("delivered_stars_") and user_id == ADMIN_ID:
            await self.handle_stars_delivery_confirmation(update, context, data)
        elif data.startswith("quick_fund_"):
            await self.handle_quick_fund(update, context, data)

        elif data.startswith("confirm_fund_"):
            await self.confirm_funding(update, context, data)
        elif data == "cancel_fund":
            await query.edit_message_text("âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªÙ…ÙˆÙŠÙ„.")
        elif data == "spin_wheel":
            await self.handle_wheel_spin(update, context)
        elif data == "confirm_spin_wheel":
            await self.confirm_wheel_spin(update, context)
        elif data.startswith("delivered_") and user_id == ADMIN_ID:
            await self.handle_delivery_confirmation(update, context, data)
        elif data.startswith("check_paid_"):
            await self.check_paid_subscription(update, context, data)
        elif data.startswith("skip_channel_"):
            await self.skip_current_channel(update, context, data)
        elif data == "manage_mandatory" and user_id == ADMIN_ID:
            await self.manage_mandatory_channels(update, context)
        elif data == "toggle_mandatory" and user_id == ADMIN_ID:
            await self.toggle_mandatory_subscription(update, context)
        elif data == "manage_paid" and user_id == ADMIN_ID:
            await self.manage_paid_channels(update, context)
        elif data == "broadcast" and user_id == ADMIN_ID:
            await self.broadcast_menu(update, context)
        elif data == "add_points" and user_id == ADMIN_ID:
            await self.add_points_menu(update, context)
        elif data == "remove_points" and user_id == ADMIN_ID:
            await self.remove_points_menu(update, context)
        elif data == "manage_users" and user_id == ADMIN_ID:
            await self.manage_users_menu(update, context)
        elif data == "gift_link" and user_id == ADMIN_ID:
            await self.gift_link_menu(update, context)
        elif data == "create_gift_code" and user_id == ADMIN_ID:
            await self.create_gift_code_menu(update, context)
        elif data == "create_gift_link" and user_id == ADMIN_ID:
            await self.create_gift_link_menu(update, context)
        elif data == "manage_gift_links" and user_id == ADMIN_ID:
            await self.manage_gift_links_menu(update, context)
        elif data.startswith("deactivate_gift_") and user_id == ADMIN_ID:
            await self.deactivate_gift_link_handler(update, context, data)
        elif data.startswith("gift_"):
            await self.handle_gift_link_usage(update, context, data)
        elif data == "entry_points" and user_id == ADMIN_ID:
            await self.entry_points_menu(update, context)
        elif data == "statistics" and user_id == ADMIN_ID:
            await self.show_statistics(update, context)
        elif data == "user_info_admin" and user_id == ADMIN_ID:
            await self.user_info_admin_menu(update, context)
        elif data == "member_price" and user_id == ADMIN_ID:
            await self.member_price_menu(update, context)
        elif data == "add_mandatory_channel" and user_id == ADMIN_ID:
            await self.add_mandatory_channel(update, context)
        elif data == "delete_mandatory_channel" and user_id == ADMIN_ID:
            await self.delete_mandatory_channel_menu(update, context)
        elif data.startswith("del_mandatory_") and user_id == ADMIN_ID:
            await self.confirm_delete_mandatory_channel(update, context, data)
        elif data == "add_paid_channel" and user_id == ADMIN_ID:
            await self.add_paid_channel(update, context)
        elif data == "delete_paid_channel" and user_id == ADMIN_ID:
            await self.delete_paid_channel_menu(update, context)
        elif data.startswith("del_paid_") and user_id == ADMIN_ID:
            await self.confirm_delete_paid_channel(update, context, data)
        elif data == "manage_paid_count" and user_id == ADMIN_ID:
            await self.manage_paid_count(update, context)
        elif data == "update_paid_status" and user_id == ADMIN_ID:
            await self.update_paid_status(update, context)
        elif data == "update_mandatory_stats" and user_id == ADMIN_ID:
            await self.update_mandatory_stats(update, context)

        elif data == "ban_user" and user_id == ADMIN_ID:
            await self.ban_user_menu(update, context)
        elif data == "unban_user" and user_id == ADMIN_ID:
            await self.unban_user_menu(update, context)
        elif data == "maintenance" and user_id == ADMIN_ID:
            await self.maintenance_menu(update, context)
        elif data.startswith("maintenance_") and user_id == ADMIN_ID:
            if data == "maintenance_fund_channel":
                await self.maintenance_button_menu(update, context, "fund_channel", "ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù‚Ù†Ø§Ø©")
            elif data == "maintenance_invite_link":
                await self.maintenance_button_menu(update, context, "invite_link", "Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ©")
            elif data == "maintenance_collect_stars":
                await self.maintenance_button_menu(update, context, "collect_stars", "ØªØ¬Ù…ÙŠØ¹ Ù†Ø¬ÙˆÙ…")
            elif data == "maintenance_wheel_luck":
                await self.maintenance_button_menu(update, context, "wheel_luck", "Ø¹Ø¬Ù„Ø© Ø§Ù„Ø­Ø¸")
            elif data == "maintenance_stars_section":
                await self.maintenance_button_menu(update, context, "stars_section", "Ù‚Ø³Ù… Ø§Ù„Ù†Ø¬ÙˆÙ…")
            elif data == "maintenance_rush_services":
                await self.maintenance_button_menu(update, context, "rush_services", "Ù‚Ø³Ù… Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø±Ø´Ù‚")
            elif data.startswith("maintenance_on_"):
                button_type = data.split("maintenance_on_")[1]
                await self.toggle_button_maintenance(update, context, button_type, True)
            elif data.startswith("maintenance_off_"):
                button_type = data.split("maintenance_off_")[1]
                await self.toggle_button_maintenance(update, context, button_type, False)
            elif data.startswith("maintenance_message_"):
                button_type = data.split("maintenance_message_")[1]
                await self.maintenance_button_message_menu(update, context, button_type)
        elif data == "subscription_price" and user_id == ADMIN_ID:
            await self.subscription_price_menu(update, context)

        elif data == "transfer_cookies":
            mandatory_result = await self.check_mandatory_subscriptions(update, context)
            if not mandatory_result["all_subscribed"]:
                return
            await self.show_transfer_cookies_menu(update, context)
        elif data == "use_gift_code":
            mandatory_result = await self.check_mandatory_subscriptions(update, context)
            if not mandatory_result["all_subscribed"]:
                return
            await self.show_use_gift_code_menu(update, context)
        elif data == "transparent" and user_id == ADMIN_ID:
            await self.transparent_menu(update, context)
        elif data == "transparent_click":
            await query.answer()
        elif data == "rush_reactions":
            await self.show_rush_reactions_menu(update, context)
        elif data == "min_funding_members" and user_id == ADMIN_ID:
            await self.min_funding_members_menu(update, context)
        elif data == "daily_gift_amount" and user_id == ADMIN_ID:
            await self.daily_gift_amount_menu(update, context)
        elif data == "accounts_info" and user_id == ADMIN_ID:
            await self.show_accounts_info(update, context)
        elif data == "manage_paid_bots" and user_id == ADMIN_ID:
            await self.manage_paid_bots_menu(update, context)
        elif data == "delete_paid_bot" and user_id == ADMIN_ID:
            await self.delete_paid_bot_menu(update, context)
        elif data.startswith("del_bot_") and user_id == ADMIN_ID:
            await self.confirm_delete_paid_bot(update, context, data)
        elif data == "manage_bots_count" and user_id == ADMIN_ID:
            await self.manage_bots_count(update, context)
        elif data == "confirm_leave_all_chats" and user_id == ADMIN_ID:
            await self.execute_leave_all_chats(update, context)
        elif data.startswith("skip_bot_"):
            await self.skip_current_bot(update, context, data)
        elif data == "users_count_display":
            await query.answer()
        elif data == "unsubscribed_status":
            await query.answer()
        elif data == "rush_services":
            if self.maintenance_mode["rush_services"]:
                await query.edit_message_text(
                    self.maintenance_messages["rush_services"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="services_menu")]])
                )
                return
            await self.show_rush_services_menu(update, context)

        elif data == "arab_vote_mandatory":
            await self.show_arab_vote_mandatory_menu(update, context)
        elif data == "admin_settings" and user_id == ADMIN_ID:
            await self.show_admin_settings_menu(update, context)
        elif data == "leave_all_chats" and user_id == ADMIN_ID:
            await self.leave_all_chats_menu(update, context)
        elif data.startswith("report_channel_"):
            await self.handle_channel_report(update, context, data)
        elif data.startswith("report_reason_"):
            await self.handle_report_reason(update, context, data)
        elif data.startswith("report_bot_reason_"):
            await self.handle_bot_report_reason(update, context, data)
        elif data == "report_other_reason":
            await self.handle_other_reason_request(update, context)
        elif data.startswith("admin_report_action_"):
            await self.handle_admin_report_action(update, context, data)
        elif data.startswith("admin_report_delete_") and user_id == ADMIN_ID:
            await self.handle_admin_report_delete(update, context, data)
        elif data.startswith("report_bot_") and not data.startswith("report_bot_reason_") and data != "report_bot_other_reason":
            await self.handle_bot_report(update, context, data)
        elif data.startswith("report_bot_reason_"):
            await self.handle_bot_report_reason(update, context, data)
        elif data == "report_bot_other_reason":
            await self.handle_bot_other_reason_request(update, context)
        elif data == "positive_reactions":
            await self.handle_positive_reactions(update, context)
        elif data == "negative_reactions":
            await self.handle_negative_reactions(update, context)
        elif data == "random_reactions":
            await self.handle_random_reactions(update, context)

        elif data.startswith("arab_vote_speed_"):
            await self.handle_arab_vote_speed_callback(update, context, data)
        elif data == "comments_service":
            await self.show_comments_service_menu(update, context)
        elif data == "comments_service_2":
            await self.show_comments_service_2_menu(update, context)
        elif data.startswith("comments_speed_"):
            await self.handle_comments_speed_callback(update, context, data)
        elif data == "poll_service":
            await self.show_poll_service_menu(update, context)

async def main():
    """Start the bot"""
    application = None
    try:
        telegram_bot = TelegramBot()

        application = Application.builder().token(BOT_TOKEN).build()

        application.add_handler(CommandHandler("start", telegram_bot.start))
        application.add_handler(CallbackQueryHandler(telegram_bot.handle_callback))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, telegram_bot.handle_message))

        print("ğŸ¤– ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­ØŒ Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ù„Ø±Ø³Ø§Ø¦Ù„...")
        
        # Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙØ¶Ù„ Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù
        await application.run_polling(
            drop_pending_updates=True,
            close_loop=False
        )

    except KeyboardInterrupt:
        print("ğŸ›‘ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}")
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}")
    finally:
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…ÙˆØ§Ø±Ø¯
        if application:
            try:
                await application.shutdown()
                print("âœ… ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­")
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¨ÙˆØª: {e}")

if __name__ == "__main__":
    try:
        print("ğŸ¤– Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø­Ù„Ù‚Ø© Ø£Ø­Ø¯Ø§Ø« Ù†Ø´Ø·Ø©
        try:
            loop = asyncio.get_running_loop()
            print("âš ï¸ ÙŠÙˆØ¬Ø¯ event loop Ù†Ø´Ø· Ø¨Ø§Ù„ÙØ¹Ù„")
        except RuntimeError:
            # Ù„Ø§ ÙŠÙˆØ¬Ø¯ event loop Ù†Ø´Ø·ØŒ ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ§Ø­Ø¯ Ø¬Ø¯ÙŠØ¯
            pass
        
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… asyncio.run Ù…Ø¹ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ø§Ù„ØµØ­ÙŠØ­ Ù„Ù„Ù€ event loop
        asyncio.run(main())
        
    except KeyboardInterrupt:
        print("ğŸ›‘ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
    except RuntimeError as e:
        if "cannot be called from a running event loop" in str(e):
            # Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ event loop Ù†Ø´Ø·ØŒ Ù†Ø³ØªØ®Ø¯Ù…Ù‡
            import nest_asyncio
            nest_asyncio.apply()
            asyncio.run(main())
        else:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}")
            print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}")
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}")
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}")

    async def handle_mandatory_channel_username(self, update: Update, context: ContextTypes.DEFAULT_TYPE, username_text):
        try:
            username = username_text.strip()

            if username.startswith('@'):
                username = username[1:]

            if not username:
                await update.message.reply_text("âŒ ÙŠÙˆØ²Ø±Ù†ÙŠÙ… Ø§Ù„Ù‚Ù†Ø§Ø© ØºÙŠØ± ØµØ­ÙŠØ­!")
                return

            try:
                chat = await context.bot.get_chat(f"@{username}")
                channel_id = str(chat.id)
                channel_name = chat.title or username

                bot_member = await context.bot.get_chat_member(channel_id, context.bot.id)
                if bot_member.status not in ['administrator', 'creator']:
                    await update.message.reply_text(
                        f"âŒ Ø§Ù„Ø¨ÙˆØª Ù„ÙŠØ³ Ù…Ø´Ø±ÙØ§Ù‹ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©!\n\n"
                        f"âš ï¸ ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØª Ù…Ø´Ø±ÙØ§Ù‹ ÙÙŠ @{username} Ø«Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰"
                    )
                    return

                context.user_data['temp_mandatory_channel_username'] = f"@{username}"
                context.user_data['waiting_for'] = 'mandatory_channel_members'

                await update.message.reply_text(
                    f"âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_name}\n\n"
                    f"ğŸ“¢ Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù…Ù† Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ù„Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©:"
                )

            except Exception as e:
                await update.message.reply_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø©: {str(e)}")
                context.user_data['waiting_for'] = None

        except Exception as e:
            await update.message.reply_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")
            context.user_data['waiting_for'] = None

    async def handle_mandatory_channel_members(self, update: Update, context: ContextTypes.DEFAULT_TYPE, members_text):
        try:
            members_count = int(members_text.strip())

            if members_count <= 0:
                await update.message.reply_text("âŒ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±!")
                return

            context.user_data['temp_mandatory_channel_members'] = members_count
            context.user_data['waiting_for'] = 'mandatory_channel_invite'
            await update.message.reply_text(
                f"âœ… ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {members_count} Ø¹Ø¶Ùˆ\n\n"
                f"ğŸ”— Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© Ù„Ù„Ù‚Ù†Ø§Ø©:"
            )
        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")
        except Exception as e:
            await update.message.reply_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")
            context.user_data['waiting_for'] = None

    async def handle_mandatory_channel_invite(self, update: Update, context: ContextTypes.DEFAULT_TYPE, invite_text):
        try:
            invite_link = invite_text.strip()
            if not invite_link.startswith(('https://t.me/', 'http://t.me/', 't.me/')):
                await update.message.reply_text("âŒ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© ØºÙŠØ± ØµØ­ÙŠØ­!")
                return
            if invite_link.startswith('t.me/'):
                invite_link = 'https://' + invite_link
            elif invite_link.startswith('http://'):
                invite_link = invite_link.replace('http://', 'https://')
            channel_username = context.user_data.get('temp_mandatory_channel_username')
            members_required = context.user_data.get('temp_mandatory_channel_members')
            if not channel_username or not members_required:
                await update.message.reply_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
                context.user_data['waiting_for'] = None
                return
            try:
                chat = await context.bot.get_chat(channel_username)
                channel_id = str(chat.id)
                channel_name = chat.title or channel_username
                bot_member = await context.bot.get_chat_member(channel_id, context.bot.id)
                if bot_member.status not in ['administrator', 'creator']:
                    await update.message.reply_text(
                        f"âŒ Ø§Ù„Ø¨ÙˆØª Ù„ÙŠØ³ Ù…Ø´Ø±ÙØ§Ù‹ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©!\n\n"
                        f"âš ï¸ ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØª Ù…Ø´Ø±ÙØ§Ù‹ ÙÙŠ {channel_username} Ø«Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰"
                    )
                    return
                self.mandatory_channels[channel_id] = {
                    "name": channel_name,
                    "username": channel_username,
                    "invite_link": invite_link,
                    "members_required": members_required,
                    "total_subscribers_count": 0,
                    "added_date": str(datetime.now()),
                    "added_by": update.effective_user.id
                }
                self.save_data_to_db('mandatory_channels', self.mandatory_channels)
                context.user_data['waiting_for'] = None
                if 'temp_mandatory_channel_username' in context.user_data:
                    del context.user_data['temp_mandatory_channel_username']
                if 'temp_mandatory_channel_members' in context.user_data:
                    del context.user_data['temp_mandatory_channel_members']
                await update.message.reply_text(
                    f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                    f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_name}\n"
                    f"ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {members_required}\n"
                    f"ğŸ”— Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ©: {invite_link}\n\n"
                    f"ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ø¶Ø§ÙØ©: {self.format_time_12h(datetime.now())}"
                )
            except Exception as e:
                await update.message.reply_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø©: {str(e)}")
                context.user_data['waiting_for'] = None
        except Exception as e:
            await update.message.reply_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")
            context.user_data['waiting_for'] = None
    async def show_services_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        keyboard = [
            [InlineKeyboardButton("Ø´Ø±Ø§Ø¡ Ù†Ø¬ÙˆÙ…", callback_data="stars_section"),
            InlineKeyboardButton("Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø±Ø´Ù‚", callback_data="rush_services"),],
            [InlineKeyboardButton(" Ø§Ù„Ù‚Ø§Ø¦Ù€Ù€Ù…Ø© Ø§Ù„Ù€Ø±Ø¦Ù€ÙŠÙ€Ø³Ù€ÙŠØ© ğŸ”™ ", callback_data="back_to_main")]
        ]
        await update.callback_query.edit_message_text(
            "ğŸ›ï¸ Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:\n",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def show_funding_section(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        keyboard = [
            [InlineKeyboardButton("ØªÙ…ÙˆÙŠÙ„ Ù‚Ù†Ø§Ø© Ø£Ùˆ Ù…Ø¬Ù…ÙˆØ¹Ø© ğŸ“£", callback_data="fund_channel"),
            InlineKeyboardButton("ØªÙ…ÙˆÙŠÙ„ Ø¨ÙˆØªØ§Øª ğŸ¤–", callback_data="fund_bots")],
            [InlineKeyboardButton("ØªÙ…ÙˆÙŠÙ„Ø§ØªÙŠ (ğŸ’¼)", callback_data="my_fundings")],
        ]
        await update.callback_query.edit_message_text(
            "ğŸ’¥| Ø§Ù‡Ù„Ø§ Ø¨Ùƒ ÙÙŠ Ù‚Ø³Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„ \n"
            "ğŸ²|ÙŠÙ…ÙƒÙ†Ùƒ ØªÙ…ÙˆÙŠÙ„ Ø£Ø¹Ø¶Ø§Ø¡ Ø­Ù‚ÙŠÙ‚ÙŠÙ† 100% Ù„Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ø¨ÙˆØªØ§\n"
            "ğŸš|ÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ø§ Ù…Ø¹Ø±ÙØ© Ø­Ø§Ù„Ø§Øª ØªÙ…ÙˆÙŠÙ„Ø§ØªÙƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ©",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def show_stars_section(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        keyboard = [
            [
                InlineKeyboardButton("â­ 15", callback_data="buy_stars_15"),
                InlineKeyboardButton("â­ 25", callback_data="buy_stars_25"),
                InlineKeyboardButton("â­ 50", callback_data="buy_stars_50")
            ],
            [
                InlineKeyboardButton("â­ 100", callback_data="buy_stars_100"),
                InlineKeyboardButton("â­ 200", callback_data="buy_stars_200"),
                InlineKeyboardButton("â­ 300", callback_data="buy_stars_300")
            ],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="services_menu")]
        ]
        await update.callback_query.edit_message_text(
            "ğŸ”» Ø§Ø®ØªØ± Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø¬ÙˆÙ… Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‡Ø¯ÙŠØ© Ù…Ù‚Ø§Ø¨Ù„Ù‡Ø§:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def handle_stars_purchase(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        stars = int(data.split("_")[2])
        price = self.stars_prices[stars]
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        if user["points"] < price:
            await update.callback_query.edit_message_text(
                f"âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                f"ğŸ’° ØªØ­ØªØ§Ø¬: {self.format_points(price)} ğŸª\n"
                f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n\n"
                f"ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙƒÙˆÙƒÙŠØ² Ù…Ù† Ø®Ù„Ø§Ù„:\n"
                f"ğŸ”— Ø¯Ø¹ÙˆØ© Ø§Ù„Ø£ØµØ¯Ù‚Ø§Ø¡\n"
                f"ğŸ“º Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="stars_section")]])
            )
            return
        keyboard = [
            [
                InlineKeyboardButton("Ø¥Ù„ØºØ§Ø¡", callback_data="stars_section"),
                InlineKeyboardButton("ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø´Ø±Ø§Ø¡", callback_data=f"confirm_stars_{stars}")
            ]
        ]
        await update.callback_query.edit_message_text(
            f"ğŸ“® ØªØ£ÙƒÙŠØ¯ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø´Ø±Ø§Ø¡!\n\n"
            f"â­ Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø¬ÙˆÙ…: {stars}\n"
            f"ğŸª Ø§Ù„ØªÙƒÙ„ÙØ©: {self.format_points(price)}\n\n"
            f"Ø¹Ù†Ø¯ ØªØ£ÙƒÙŠØ¯Ùƒ Ù„Ù„Ø´Ø±Ø§Ø¡ Ø³ÙŠØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Ø¬ÙˆÙ… Ù„Ø­Ø³Ø§Ø¨Ùƒ Ù‡Ø°Ø§ ÙÙˆØ±Ø§Ù‹",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def confirm_stars_purchase(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        stars = int(data.split("_")[2])
        price = self.stars_prices[stars]
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        user["points"] -= price

        purchase_id = f"{user_id}_{int(datetime.now().timestamp())}"
        self.stars_purchases[purchase_id] = {
            "user_id": user_id,
            "stars": stars,
            "price": price,
            "date": str(datetime.now()),
            "delivered": False
        }
        self.save_json(STARS_PURCHASES_FILE, self.stars_purchases)
        await update.callback_query.edit_message_text(
            f"ğŸ¯ ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø´Ø±Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­!\n\n"
            f"â­ Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø¬ÙˆÙ…: {stars}\n"
            f"ğŸª Ø§Ù„ØªÙƒÙ„ÙØ©: {self.format_points(price)}\n\n"
            f"ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ§Ù„ÙŠ: @cxxov\n"
            f"ğŸ“© Ù„Ø§ ØªÙ†ØªØ¸Ø± Ø§Ù„Ø±Ø¯ØŒ ÙÙ‚Ø· Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„ÙŠØªÙ…ÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ù…ØªØ§Ø¨Ø¹Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù‡Ø¯ÙŠØ©.\n\n"
            f"ÙƒÙ„ Ø§Ù„Ø§Ù…ØªÙ†Ø§Ù† Ù„Ø«Ù‚ØªÙƒ Ø¨Ù†Ø§ØŒ ÙˆÙ†Ø£Ù…Ù„ Ø£Ù† Ù†ÙƒÙˆÙ† Ø¹Ù†Ø¯ Ø­Ø³Ù† Ø§Ù„Ø¸Ù†."
        )
        try:
            safe_first_name = self.escape_markdown(update.effective_user.first_name)
            safe_username = ""
            if update.effective_user.username:
                safe_username = self.escape_markdown(f"@{update.effective_user.username}")
            else:
                safe_username = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙŠÙˆØ²Ø±Ù†ÙŠÙ…"
            user_link_admin = f"[{user_id}](tg://user?id={user_id})"
            keyboard = [[InlineKeyboardButton("ØªÙ… Ø§Ù„ØªØ³Ù„ÙŠÙ… â˜‘ï¸", callback_data=f"delivered_stars_{purchase_id}")]]
            await context.bot.send_message(
                ADMIN_ID,
                f"ğŸ”” Ø·Ù„Ø¨ Ø´Ø±Ø§Ø¡ Ù†Ø¬ÙˆÙ… Ø¬Ø¯ÙŠØ¯:\n\n"
                f"ğŸ‘¤ Ø§Ù„Ø¹Ù…ÙŠÙ„: {safe_first_name}\n"
                f"ğŸ“ Ø§Ù„ÙŠÙˆØ²Ø±: {safe_username}\n"
                f"ğŸ†” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {user_link_admin}\n"
                f"â­ Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø¬ÙˆÙ…: {stars}\n"
                f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ø·Ù„Ø¨: {self.format_time_12h(datetime.now())}",
                parse_mode='MarkdownV2',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        except Exception as e:
            logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø´Ø±Ø§Ø¡ Ø§Ù„Ù†Ø¬ÙˆÙ…: {e}")
    async def handle_stars_delivery_confirmation(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        purchase_id = data.split("_", 2)[2]
        if purchase_id not in self.stars_purchases:
            await update.callback_query.edit_message_text("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø´Ø±Ø§Ø¡!")
            return
        purchase = self.stars_purchases[purchase_id]
        customer_user_id = purchase["user_id"]
        stars = purchase["stars"]
        self.stars_purchases[purchase_id]["delivered"] = True
        self.stars_purchases[purchase_id]["delivery_date"] = str(datetime.now())
        self.save_json(STARS_PURCHASES_FILE, self.stars_purchases)
        user = self.get_user(customer_user_id)
        try:
            await context.bot.send_message(
                customer_user_id,
                f"ğŸŒŸ ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø¢Ø®Ø± Ø´Ø±Ø§Ø¡ Ù„Ùƒ Ø¨Ù…Ø¨Ù„Øº {stars} Ù†Ø¬Ù…Ø©!\n\n"
                f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª! ğŸ’«"
            )
            await update.callback_query.edit_message_text(
                f"âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„ØªØ³Ù„ÙŠÙ… Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ‘¤ Ø§Ù„Ø¹Ù…ÙŠÙ„: {customer_user_id}\n"
                f"â­ Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø¬ÙˆÙ…: {stars}\n"
                f"ğŸ“Š Ø±ØµÙŠØ¯Ù‡ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n"
                f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„ØªØ£ÙƒÙŠØ¯: {self.format_time_12h(datetime.now())}"
            )
        except Exception as e:
            await update.callback_query.edit_message_text(
                f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {customer_user_id}\n\n"
                f"Ø§Ù„Ø®Ø·Ø£: {str(e)}"
            )
    async def show_fund_channel_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        if self.maintenance_mode["fund_channel"]:
            await update.callback_query.edit_message_text(
                self.maintenance_messages["fund_channel"],
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
            )
            return
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        context.user_data['waiting_for'] = 'fund_channel_members'
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="funding_section")]]
        max_affordable_members_channel = int(user['points'] // self.member_price)
        await update.callback_query.edit_message_text(
            text=f"*ØªÙ…ÙˆÙŠÙ„ Ø§Ø¹Ø¶Ø§Ø¡ Ø­Ù‚ÙŠÙ‚ÙŠØ© 100% ğŸ“£\n\n*"
                 f"> â€¢ ÙƒÙ„ 1 Ø¹Ø¶Ùˆ ğŸ‘¤ \\= 8 ÙƒÙˆÙƒÙŠØ²\n\n"
                    f">ğŸª« Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ Ù„Ù„ØªÙ…ÙˆÙŠÙ„: {self.min_funding_members} Ø¹Ø¶Ùˆ\n\n"
                 f">ğŸ–ï¸ ÙŠÙ…ÙƒÙ†Ùƒ ØªÙ…ÙˆÙŠÙ„: {max_affordable_members_channel} Ø¹Ø¶Ùˆ\n\n"
                f"*â€¢ Ø§Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ø¯ ØªÙ…ÙˆÙŠÙ„Ù‡Ø§ ğŸ“¬:*\n",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='MarkdownV2'
        )
    async def handle_quick_fund(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        members = int(data.split("_")[2])
        if members < self.min_funding_members:
            return
        required_points = float(members * self.member_price)
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        if user["points"] < required_points:
            await update.callback_query.edit_message_text(
                f"âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                f"ğŸ’° ØªØ­ØªØ§Ø¬: {self.format_points(required_points)} ğŸª\n"
                f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n\n"
                f"ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙƒÙˆÙƒÙŠØ² Ù…Ù† Ø®Ù„Ø§Ù„:\n"
                f"ğŸ”— Ø¯Ø¹ÙˆØ© Ø§Ù„Ø£ØµØ¯Ù‚Ø§Ø¡\n"
                f"ğŸ“º Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="fund_channel")]])
            )
            return
        context.user_data['temp_fund_members'] = members
        context.user_data['temp_fund_cost'] = required_points
        context.user_data['waiting_for'] = 'fund_channel_username'
        bot_info = await update.get_bot().get_me()
        bot_username = f"@{bot_info.username}" if bot_info.username else "Ø§Ù„Ø¨ÙˆØª"
        await update.callback_query.edit_message_text(
            f"ğŸ‘¥] Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡: {members}\n"
            f"ğŸ’°] Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©: {self.format_points(required_points)} ğŸª\n\n"
            f"âš ï¸] Ø§Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØª {bot_username} Ø£Ø¯Ù…Ù† ÙÙŠ Ù‚Ù†Ø§ØªÙƒ Ø£Ùˆ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ\n\n"
            f"â€¢ Ø«Ù… Ø£Ø±Ø³Ù„ ÙŠÙˆØ²Ø± Ø§Ù„Ù‚Ù†Ø§Ø© Ù…Ø¹ @",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="fund_channel")]])
        )
    async def confirm_funding(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        members = int(data.split("_")[2])
        required_points = float(members * self.member_price)
        user["points"] -= required_points

    async def show_wheel_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        await self.delete_old_mandatory_message(context, user_id)
        today = datetime.now().date().strftime('%Y-%m-%d')
        user_spins_today = self.wheel_spins.get(str(user_id), {}).get(today, 0)
        remaining_spins = 2 - user_spins_today
        if remaining_spins <= 0:
            await update.callback_query.edit_message_text(
                "âš ï¸ Ù„Ù‚Ø¯ Ø§Ø³ØªÙ†ÙØ¯Øª Ù…Ø±Ø§Øª Ø§Ù„ØªØ¯ÙˆÙŠØ± Ø§Ù„ÙŠÙˆÙ…!\n\n"
                "ğŸ¡ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø¹Ø¬Ù„Ø© Ù…Ø±ØªÙŠÙ† ÙÙ‚Ø· ÙƒÙ„ ÙŠÙˆÙ…\n"
                "â° Ø¹Ø¯ ØºØ¯Ø§Ù‹ Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©\n\n"
                f"ğŸ“Š Ø§Ù„ØªØ¯ÙˆÙŠØ±Ø§Øª Ø§Ù„ÙŠÙˆÙ…: {user_spins_today}/2",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
            )
            return
        if user["points"] < self.wheel_spin_cost:
            await update.callback_query.edit_message_text(
                f"âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                f"ğŸ’° ØªØ­ØªØ§Ø¬: {self.wheel_spin_cost} ğŸª Ù„ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø¹Ø¬Ù„Ø©\n"
                f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n"
                f"ğŸ¡ Ø§Ù„ØªØ¯ÙˆÙŠØ±Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© Ø§Ù„ÙŠÙˆÙ…: {remaining_spins}/2",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
            )
            return
        user_link = f"[{update.effective_user.first_name}](tg://user?id={user_id})"
        next_prize = self.wheel_gift_first if user_spins_today == 0 else self.wheel_gift_second
        keyboard = [
            [InlineKeyboardButton(f"ğŸ¡ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø¹Ø¬Ù„Ø© ({self.wheel_spin_cost} ğŸª)", callback_data="spin_wheel")],
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="back_to_main")]
        ]
        await update.callback_query.edit_message_text(
            f"ğŸ¡ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ Ø¹Ø²ÙŠØ²ÙŠ {user_link} ÙÙŠ Ø¹Ø¬Ù„Ø© Ø§Ù„Ø­Ø¸\n\n"
            f"ğŸ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©: {next_prize}\n"
            f"ğŸ”„ Ø§Ù„ØªØ¯ÙˆÙŠØ± Ø±Ù‚Ù…: {user_spins_today + 1}/2\n"
            f"ğŸ“Š Ø§Ù„ØªØ¯ÙˆÙŠØ±Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: {remaining_spins}\n\n"
            f"ğŸ’° Ø³Ø¹Ø± Ø§Ù„ØªØ¯ÙˆÙŠØ±: {self.wheel_spin_cost} ğŸª\n"
            f"âœ¨ Ø§Ù„Ø¬ÙˆØ§Ø¦Ø² ÙŠØªÙ… ØªØ³Ù„ÙŠÙ…Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙÙˆØ± Ø§Ù„ÙÙˆØ²! ğŸ‰",
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def handle_wheel_spin(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        user["points"] -= self.wheel_spin_cost
        self.record_wheel_spin(user_id)

        await update.callback_query.edit_message_text(
            f"ØªÙ… Ø®ØµÙ… {self.wheel_spin_cost} ğŸª ÙˆØ¬Ø§Ø±ÙŠ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø¹Ø¬Ù„Ø©...",
            reply_markup=None
        )
        await asyncio.sleep(1)
        await self.wheel_animation(update, context)
    async def wheel_animation(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        prizes = self.wheel_prizes
        spins = 2
        for spin in range(spins):
            for prize_idx in range(len(prizes)):
                display_text = "ğŸ¡ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø¹Ø¬Ù„Ø©...\n"
                for idx, prize in enumerate(prizes):
                    if idx == prize_idx:
                        display_text += f"{prize} â˜š\n"
                    else:
                        display_text += f"{prize}\n"
                try:
                    await update.callback_query.edit_message_text(display_text)
                    await asyncio.sleep(0.20)  # 250 Ù…Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©
                except:
                    pass 
        await self.show_wheel_result(update, context)
    async def show_wheel_result(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        today = datetime.now().date().strftime('%Y-%m-%d')
        user_spins_today = self.wheel_spins.get(str(user_id), {}).get(today, 0)
        won_prize = self.wheel_gift_first if user_spins_today == 1 else self.wheel_gift_second
        user_link = f"[{update.effective_user.first_name}](tg://user?id={user_id})"
        try:
            prize_text = won_prize.replace("ğŸª", "")
            prize_text = prize_text.replace("Â³", "3").replace("Â²", "2").replace("Â¹", "1").replace("â°", "0")
            stars_won = int(prize_text)
            user["points"] += stars_won

            remaining_spins = 2 - user_spins_today
            spin_text = "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø§Ù„ÙŠÙˆÙ…!" if remaining_spins > 0 else "Ø§Ù†ØªÙ‡Øª Ù…Ø­Ø§ÙˆÙ„Ø§ØªÙƒ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ…ØŒ Ø¹Ø¯ ØºØ¯Ø§Ù‹!"
            await update.callback_query.edit_message_text(
                f"ğŸŠ Ù…Ø¨Ø±ÙˆÙƒ Ø¹Ø²ÙŠØ²ÙŠ {user_link}!\n"
                f"ğŸ Ù„Ù‚Ø¯ Ø±Ø¨Ø­Øª: {won_prize}\n"
                f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© {stars_won} ÙƒÙˆÙƒÙŠØ² Ø¥Ù„Ù‰ Ø±ØµÙŠØ¯Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹\n"
                f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n\n"
                f"ğŸ¡ {spin_text}",
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
            )
            try:
                user_link_admin = f"[{user_id}](tg://user?id={user_id})"
                safe_first_name = self.escape_markdown(update.effective_user.first_name)
                safe_username = ""
                if update.effective_user.username:
                    safe_username = self.escape_markdown(f"@{update.effective_user.username}")
                else:
                    safe_username = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙŠÙˆØ²Ø±Ù†ÙŠÙ…"
                await context.bot.send_message(
                    ADMIN_ID,
                    f"ğŸ¡ Ø¬Ø§Ø¦Ø²Ø© Ø¹Ø¬Ù„Ø© Ø§Ù„Ø­Ø¸ \\(ØªÙ„Ù‚Ø§Ø¦ÙŠ\\)\\!\n\n"
                    f"ğŸ‘¤ Ø§Ù„ÙØ§Ø¦Ø²: {safe_first_name}\n"
                    f"ğŸ“ Ø§Ù„ÙŠÙˆØ²Ø±: {safe_username}\n"
                    f"ğŸ†” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {user_link_admin}\n"
                    f"ğŸ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: {won_prize} \\({stars_won} ÙƒÙˆÙƒÙŠØ²\\)\n"
                    f"ğŸ”„ Ø§Ù„ØªØ¯ÙˆÙŠØ± Ø±Ù‚Ù…: {user_spins_today}/2\n"
                    f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}",
                    parse_mode='MarkdownV2'
                )
            except Exception as e:
                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¹Ø¬Ù„Ø© Ø§Ù„Ø­Ø¸: {e}")

        except Exception as e:
            logger.error(f"Error processing wheel prize: {e}")
            await update.callback_query.edit_message_text(
                f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©!\n"
                f"ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©: @cxxov",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
            )

    async def show_invite_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        try:
            bot_username = (await context.bot.get_me()).username
            invite_link = f"https://t.me/{bot_username}?start={user['invite_link']}"

            successful_invites = user.get("referrals_count", 0)

            share_message = (
                f"@s1x2bot âŒï¸™ Ø£Ù†Ø¶Ù… Ø§Ù„Ù‰ Ø¨ÙˆØª ØªÙŠØ±Ø¨Ùˆ ÙÙˆÙ„Ùˆ  â†«â¤ˆ\n"
                f"âŒï¸™Ø¹Ù†Ø¯Ù…Ø§ ØªÙ‚ÙˆÙ… Ø¨ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª \n"
                f"âŒï¸™ Ø³ÙˆÙ ØªØ­ØµÙ„ Ø¹Ù„Ù‰ â†« 100 ÙƒÙˆÙƒÙŠØ²\n"
                f"âŒï¸™Ø±Ø´Ù‚ Ù„Ø§ÙŠÙƒØ§Øª Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ø´ØªØ±Ø§Ùƒ Ø¥Ø¬Ø¨Ø§Ø±ÙŠ Ø­Ø³Ø§Ø¨Ø§Øª Ø¹Ø±Ø¨ÙŠØ©\n"
                f"âŒï¸™ÙŠÙˆÙØ± ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙˆØ§Ù„Ø¨ÙˆØªØ§Øª Ø­Ù‚ÙŠÙ‚ÙŠ 100%\n"
                f"âŒï¸™ ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ù†Ø¬ÙˆÙ… ØªØ³Ù„ÙŠÙ… ØªÙ„Ù‚Ø§Ø¦ÙŠ\n"
                f"âŒï¸™Ø§Ù„Ø¨ÙˆØª ÙŠÙ…ØªØ§Ø² Ø¨Ø³Ø±Ø¹Ø© ØªÙ†ÙÙŠØ° Ø§Ù„Ø·Ù„Ø¨ âœ“ .\n"
                f"âŒï¸™ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨ÙˆØª â†«â¤ˆ\n"
                f"{invite_link}"
            )

            import urllib.parse
            encoded_message = urllib.parse.quote(share_message)
            share_url = f"https://t.me/share/url?url={encoded_message}"

            message_text = (
                  f"ğŸ—³ï¸ Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ {self.format_points(self.invite_points)} ğŸª Ù…Ù‚Ø§Ø¨Ù„ ÙƒÙ„ Ø¯Ø¹ÙˆØ©!\n"
                f"ğŸ”— Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ:\n\n"
                f"`{invite_link}`\n\n"

                f"ğŸ“® Ø¹Ø¯Ø¯ Ø¯Ø¹ÙˆØ§ØªÙƒ: {successful_invites}\n\n"
            )

            try:
                if self.top_referrers and len(self.top_referrers) > 0:
                    message_text += "ğŸ† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø§ÙƒØ«Ø± Ù…Ø´Ø§Ø±ÙƒØ© Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ©:\n"
                    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
                    for i, referrer in enumerate(self.top_referrers[:3]):
                        medal = medals[i] if i < len(medals) else "ğŸ–ï¸"
                        try:
                            user_chat = await context.bot.get_chat(int(referrer["user_id"]))
                            if user_chat.username:
                                user_link = f"[{referrer['user_id']}](tg://user?id={referrer['user_id']})"
                            else:
                                user_link = f"`{referrer['user_id']}`"
                            message_text += f"{medal} {user_link} - {referrer['count']}\n"
                        except:
                            message_text += f"{medal} `{referrer['user_id']}` - {referrer['count']}\n"
            except Exception as e:
                pass

            keyboard = [
            [InlineKeyboardButton("Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© ğŸ“¤", url=share_url)],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]
        ]

            await update.callback_query.edit_message_text(
                message_text,
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )

        except Exception as e:
            try:
                bot_username = (await context.bot.get_me()).username
                invite_link = f"https://t.me/{bot_username}?start={user['invite_link']}"
                successful_invites = user.get("referrals_count", 0)

                simple_text = (
                    f"ğŸ”— Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ©:\n\n"
                    f"`{invite_link}`\n\n"
                    f"ğŸª {self.format_points(self.invite_points)} ÙƒÙˆÙƒÙŠØ² Ù„ÙƒÙ„ Ø¯Ø¹ÙˆØ©\n"
                    f"ğŸ¯ Ø¯Ø¹ÙˆØ§ØªÙƒ: {successful_invites}"
                )

                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]]

                await update.callback_query.edit_message_text(
                    simple_text,
                    parse_mode='Markdown',
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            except Exception as e2:
                await self.show_main_menu(update, context)

    async def show_collect_cookies(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        if not self.paid_channels:
            keyboard = [
                [
                    InlineKeyboardButton("Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© (ğŸ”—)", callback_data="invite_link")
                ],
                [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]
            ]

            await update.callback_query.edit_message_text(
                "âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„Ù„ØªØ¬Ù…ÙŠØ¹.\n\n"
                "ØªØ­Ù‚Ù‚ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙØ±Øµ Ø¬Ø¯ÙŠØ¯Ø© Ù„ÙƒØ³Ø¨ Ø§Ù„ÙƒÙˆÙƒÙŠØ²!",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return

        keyboard = [
            [
                InlineKeyboardButton("ğŸ“£ (Ã—10) â¬…ï¸", callback_data="collect_bulk"),
                InlineKeyboardButton("Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø§Ù„Ù‚Ù†ÙˆØ§Øª ğŸ“£", callback_data="collect_single")
            ],
            [
                InlineKeyboardButton("( - ğŸ¤– Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø§Ù„Ø¨ÙˆØªØ§Øª ğŸ¤– - )", callback_data="bot_subscription"),
            ],
            [
               InlineKeyboardButton("Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© (ğŸ)", callback_data="daily_gift"),

               InlineKeyboardButton(" Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© (ğŸ”—)", callback_data="invite_link")
            ],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            "â€¢ Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Ù‚Ø³Ù… ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù‚Ø§Ø· ã€½ï¸\n"
            "- ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ø£ÙƒØ«Ø± Ù…Ù† Ø·Ø±ÙŠÙ‚Ø©. ğŸ“¢\n",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_single_collect(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id

        channel_id, channel_info = await self.get_next_paid_channel(user_id, context)

        if not channel_id:
            await update.callback_query.edit_message_text(
                "â³ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠØŒ Ù‚Ù… Ø¨ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ø®ØªÙ„ÙØ©\n"
                "ğŸš« Ø¥Ø°Ø§ Ù‚Ù…Øª Ø¨Ù…ØºØ§Ø¯Ø±Ø© Ø£ÙŠ Ù‚Ù†Ø§Ø© Ø³ÙŠØªÙ… Ø®ØµÙ… Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ù…Ù†Ùƒ.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]])
            )
            return

        channel_username = channel_info['name']
        invite_link = channel_info.get('invite_link', '')

        if 't.me/' in invite_link:
            try:
                username_part = invite_link.split('t.me/')[-1]
                if not username_part.startswith('+') and '/' not in username_part:
                    channel_username = f"@{username_part}"
            except:
                pass

        keyboard = [
            [InlineKeyboardButton(f"{channel_info['name']}", url=channel_info.get('invite_link', ''))],
            [InlineKeyboardButton("ØªØ­Ù‚Ù‚ âœ…", callback_data=f"check_paid_{channel_id}")],
            [InlineKeyboardButton("ØªØ®Ø·ÙŠ ğŸ”‚", callback_data=f"skip_channel_{channel_id}")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]
        ]
        await update.callback_query.edit_message_text(
            f"Ø§Ø´ØªØ±Ùƒ Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© : {channel_username}\n"
            f"ï¿½Ø³ï¿½|â€¢ ÙˆØ£ÙØ­ØµÙ„ Ø¹Ù„Ù‰ :  {self.format_points(channel_info['points'])} ğŸª\n\n",
            reply_markup=InlineKeyboardMarkup(keyboard),
            disable_web_page_preview=True
        )
    async def show_bulk_collect(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        available_channels = []
        user_subscriptions = self.user_channel_subscriptions.get(str(user_id), {})

        for channel_id, channel_info in self.paid_channels.items():
            if channel_id not in user_subscriptions and len(available_channels) < 10:
                available_channels.append((channel_id, channel_info))
        if not available_channels:
            await update.callback_query.edit_message_text(
                "ğŸ¯ Ù„Ù‚Ø¯ Ø§Ø´ØªØ±ÙƒØª ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©!\n\n"
                "ğŸ”° Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø±ØµÙŠØ¯ÙƒØŒ ÙŠÙØ±Ø¬Ù‰ Ø¹Ø¯Ù… Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]])
            )
            return
        total_cookies = sum(channel_info['points'] for _, channel_info in available_channels)
        text = f"â€¢ Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø£Ø¯Ù†Ø§Ù‡ ğŸš¸ Ù„ÙƒÙŠ ØªØ­ØµÙ„ Ø¹Ù„Ù‰ : {self.format_points(total_cookies)} ÙƒÙˆÙƒÙŠØ² ğŸª\n\ï¿½n"
        keyboard = []
        user_reports = getattr(self, 'user_reports', {})
        user_id_str = str(user_id)
        if user_id_str not in user_reports:
            user_reports[user_id_str] = {'bots': set(), 'channels': set()}
        self.user_reports = user_reports
        for channel_id, channel_info in available_channels:
            row = [InlineKeyboardButton(f"ğŸ“º {channel_info['name']}", url=channel_info['invite_link'])]
        for channel_id, channel_info in available_channels:
            row = [InlineKeyboardButton(f"{channel_info['name']}", url=channel_info['invite_link'])]
            if channel_id not in user_reports[user_id_str]['channels']:
                row.append(InlineKeyboardButton("Ø§Ø¨Ù„Ø§Øº âš ï¸", callback_data=f"report_channel_{channel_id}"))
            else:
                row.append(InlineKeyboardButton("ØªÙ… Ø§Ù„Ø¨Ù„Ø§Øº âš ï¸", callback_data="already_reported"))
            keyboard.append(row)
        keyboard.append([InlineKeyboardButton("Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…", callback_data="check_bulk_subscriptions")])
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")])
        context.user_data['bulk_channels'] = available_channels
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            disable_web_page_preview=True
        )
    async def check_bulk_subscriptions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        await update.callback_query.edit_message_text("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§ÙƒØ§ØªÙƒ...")
        bulk_channels = context.user_data.get('bulk_channels', [])
        if not bulk_channels:
            await update.callback_query.edit_message_text(
                "âŒ Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]])
            )
            return
        successful_subscriptions = 0
        total_cookies_earned = 0
        for channel_id, channel_info in bulk_channels:
            try:
                is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
                if is_member:
                    if str(user_id) not in self.user_channel_subscriptions:
                        self.user_channel_subscriptions[str(user_id)] = {}
                    if channel_id not in self.user_channel_subscriptions[str(user_id)]:
                        user['points'] += channel_info['points']
                        total_cookies_earned += channel_info['points']
                        successful_subscriptions += 1
                        self.user_channel_subscriptions[str(user_id)][channel_id] = {
                            "points": channel_info['points'],
                            "date": str(datetime.now())
                        }
                        if 'total_subscribers_count' not in self.paid_channels[channel_id]:
                            self.paid_channels[channel_id]['total_subscribers_count'] = 0
                        self.paid_channels[channel_id]['total_subscribers_count'] += 1

                        if channel_id in self.funded_channels:
                            funded_info = self.funded_channels[channel_id]
                            owner_id = funded_info['owner_id']
                            current_count = self.paid_channels[channel_id].get('total_subscribers_count', 0)
                            required_count = self.paid_channels[channel_id]['members_required']
                            remaining = max(0, required_count - current_count)
                            try:
                                channel_link = f"[{channel_info['name']}]({channel_info['invite_link']})"
                                await context.bot.send_message(
                                    owner_id,
                                    f"ğŸ–ï¸ Ø§Ø´ØªØ±Ùƒ Ø´Ø®Øµ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ù‚Ù†Ø§ØªÙƒ {channel_link}\n\n"
                                    f"ğŸ‘¥] Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {remaining}",
                                    parse_mode='Markdown',
                                    disable_web_page_preview=True
                                )
                            except:
                                try:
                                    await context.bot.send_message(
                                        owner_id,
                                        f"ğŸ–ï¸ Ø§Ø´ØªØ±Ùƒ Ø´Ø®Øµ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ù‚Ù†Ø§ØªÙƒ!\n"
                                        f"ğŸ“® {channel_info['name']}\n"
                                        f"Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {remaining}"
                                    )
                                except:
                                    pass
                        if self.paid_channels[channel_id]['total_subscribers_count'] >= channel_info['members_required']:
                            funding_number = None
                            for fund_num, fund_record in self.funding_numbers["records"].items():
                                if fund_record.get("channel_id") == channel_id and fund_record.get("funding_type") == "channel":
                                    funding_number = fund_num
                                    self.update_funding_status(fund_num, "Ù…ÙƒØªÙ…Ù„")
                                    break

                            if channel_id in self.funded_channels:
                                funded_info = self.funded_channels[channel_id]
                                owner_id = funded_info['owner_id']
                                current_count = self.paid_channels[channel_id]['total_subscribers_count']

                                funding_record = self.get_funding_record_by_id(channel_id, "channel")
                                correct_funding_number = funding_record.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­") if funding_record else "ØºÙŠØ± Ù…ØªØ§Ø­"

                                try:
                                    await context.bot.send_message(
                                        owner_id,
                                        f"ğŸ‰] ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ØªÙ… Ø§ÙƒØªÙ…Ø§Ù„ ØªÙ…ÙˆÙŠÙ„ Ù‚Ù†Ø§ØªÙƒ {current_count} Ø¹Ø¶Ùˆ Ø¨Ù†Ø¬Ø§Ø­!\n"
                                        f"ğŸ“£] Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_info['name']}\n"
                                        f"ğŸ†”] Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: #{correct_funding_number}\n"
                                        f"ğŸ’¼] ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ÙÙŠ Ù‚Ø³Ù… 'ØªÙ…ÙˆÙŠÙ„Ø§ØªÙŠ'\n"
                                    )
                                except Exception as e:
                                    print(f"Error sending message to owner: {e}")

                                try:
                                    await context.bot.send_message(
                                        ADMIN_ID,
                                        f"âœ… ØªÙ… Ø¥Ø´Ø¹Ø§Ø± ØµØ§Ø­Ø¨ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ({owner_id}) Ø¨Ø¥ÙƒØªÙ…Ø§Ù„ ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù‚Ù†Ø§Ø© {channel_info['name']} Ø¨Ù†Ø¬Ø§Ø­"
                                    )
                                except Exception as e:
                                    print(f"Error sending message to admin: {e}")
                                except Exception as e:
                                    logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")

                                    try:
                                        await context.bot.send_message(
                                            ADMIN_ID,
                                            f"âŒ ÙØ´Ù„ Ø¥Ø´Ø¹Ø§Ø± ØµØ§Ø­Ø¨ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ({owner_id}) Ø¨Ø¥ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù‚Ù†Ø§Ø© {channel_info['name']}\n"
                                            f"Ø§Ù„Ø³Ø¨Ø¨: {str(e)}"
                                        )
                                    except:
                                        pass

                            if channel_id in self.funded_channels:
                                self.funded_channels[channel_id]['status'] = 'Ù…ÙƒØªÙ…Ù„'
                                self.funded_channels[channel_id]['completion_date'] = str(datetime.now())
                                self.funded_channels[channel_id]['final_members_count'] = self.paid_channels[channel_id]['total_subscribers_count']

                                self.move_funding_to_completed(channel_id, "channel")

                            try:
                                funding_record = self.get_funding_record_by_id(channel_id, "channel")
                                correct_funding_number = funding_record.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­") if funding_record else "ØºÙŠØ± Ù…ØªØ§Ø­"

                                await context.bot.send_message(
                                    ADMIN_ID,
                                    f"ğŸ‰ ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ù‚Ù†Ø§Ø©!\n\n"
                                    f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_info['name']}\n"
                                    f"ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {channel_info['members_required']}\n"
                                    f"âœ… Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.paid_channels[channel_id]['total_subscribers_count']}\n"
                                    f"ğŸ”¢ Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: #{correct_funding_number}\n\n"
                                    f"âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ÙÙŠ Ø§Ù„Ø£Ø±Ø´ÙŠÙ ÙˆØ¥Ø²Ø§Ù„ØªÙ‡ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø´Ø·Ø©."
                                )
                            except Exception as e:
                                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø§ÙƒØªÙ…Ø§Ù„ Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")

                            if channel_id in self.paid_channels:
                                del self.paid_channels[channel_id]
                            if channel_id in self.monitored_channels:
                                del self.monitored_channels[channel_id]
                            if channel_id in self.funded_channels:
                                del self.funded_channels[channel_id]
                            for user_id_loop, user_data_loop in self.users.items():
                                if "funded_channels" in user_data_loop and channel_id in user_data_loop["funded_channels"]:
                                    user_data_loop["funded_channels"].remove(channel_id)
                        if channel_id in self.funded_channels:
                            funded_info = self.funded_channels[channel_id]
                            owner_id = funded_info['owner_id']
                            current_count = self.paid_channels[channel_id].get('total_subscribers_count', 0)
                            required_count = self.paid_channels[channel_id]['members_required']
                            remaining = max(0, required_count - current_count)
                            try:
                                channel_link = f"[{channel_info['name']}]({channel_info['invite_link']})"
                                await context.bot.send_message(
                                    owner_id,
                                    f"ğŸ–ï¸ Ø§Ø´ØªØ±Ùƒ Ø´Ø®Øµ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ù‚Ù†Ø§ØªÙƒ {channel_link}\n\n"
                                    f"ğŸ‘¥] Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {remaining}",
                                    parse_mode='Markdown',
                                    disable_web_page_preview=True
                                )
                            except:
                                try:
                                    await context.bot.send_message(
                                        owner_id,
                                        f"ğŸ–ï¸ Ø§Ø´ØªØ±Ùƒ Ø´Ø®Øµ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ù‚Ù†Ø§ØªÙƒ!\n"
                                        f"ğŸ“® {channel_info['name']}\n"
                                        f"Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {remaining}"
                                    )
                                except:
                                    pass
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ Ø§Ù„Ù‚Ù†Ø§Ø© {channel_id}: {e}")

        self.save_json(USER_CHANNEL_SUBSCRIPTION_FILE, self.user_channel_subscriptions)
        self.save_data_to_db('paid_channels', self.paid_channels)
        self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)
        self.save_json(MONITORED_CHANNELS_FILE, self.monitored_channels)
        if 'bulk_channels' in context.user_data:
            del context.user_data['bulk_channels']
        if successful_subscriptions > 0:
            keyboard = [
                [InlineKeyboardButton("ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø²ÙŠØ¯", callback_data="collect_more")],
                [InlineKeyboardButton("Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (ğŸ”™)", callback_data="back_to_main")]
            ]
            await update.callback_query.edit_message_text(
                f"ğŸ‰ Ù„Ù‚Ø¯ Ø§Ø´ØªØ±ÙƒØª ÙÙŠ {successful_subscriptions} Ù‚Ù†Ø§Ø© ÙˆØªÙ… Ø§Ø¹Ø·Ø§Ø¤Ùƒ {self.format_points(total_cookies_earned)} ğŸª\n"
                f"âš ï¸ Ø§Ø°Ø§ ØºØ§Ø¯Ø±Øª Ø³ÙŠØªÙ… Ø®ØµÙ… Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ù…Ù†Ùƒ",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            keyboard = [
                [InlineKeyboardButton("(ğŸ§) ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø²ÙŠØ¯ (ğŸ§)", callback_data="collect_more")],
                [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™) Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©", callback_data="back_to_main")]
            ]
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ø´ØªØ±Ø§ÙƒØ§Øª Ø¬Ø¯ÙŠØ¯Ø©\n\n"
                "ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø£ÙˆÙ„Ø§Ù‹",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
    async def skip_current_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        user_id = update.effective_user.id
        current_channel_id = data.split("_")[2]

        next_channel_id, next_channel_info = await self.get_next_paid_channel_after_skip(user_id, current_channel_id, context)

        if next_channel_id:
            keyboard = [
                [InlineKeyboardButton("ØªØ­Ù‚Ù‚ âœ…", callback_data=f"check_paid_{next_channel_id}")],
                [InlineKeyboardButton("ØªØ®Ø·ÙŠ ğŸ”‚", callback_data=f"skip_channel_{next_channel_id}")],
                [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]
            ]
            await update.callback_query.edit_message_text(
                f"ğŸ›ï¸|â€¢ Ø§Ø´ØªØ±Ùƒ ÙÙŠ : {next_channel_info['name']}\n"
                f"ğŸ|â€¢ ÙˆØ£ÙØ­ØµÙ„ Ø¹Ù„Ù‰ :  {self.format_points(next_channel_info['points'])} ğŸª\n\n",
                reply_markup=InlineKeyboardMarkup(keyboard),
                disable_web_page_preview=True
            )
        else:
            await update.callback_query.edit_message_text(
                "âœ… Ù„Ù‚Ø¯ Ù…Ø±Ø±Øª Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©!\n\n"
                "ğŸ”’ Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø±ØµÙŠØ¯ÙƒØŒ ÙŠÙØ±Ø¬Ù‰ Ø¹Ø¯Ù… Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]])
            )
    async def check_paid_subscription(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        channel_id = data.split("_")[2]
        if channel_id not in self.paid_channels:
            await update.callback_query.edit_message_text(
                "âŒ Ø§Ù„Ù‚Ù†Ø§Ø© ØºÙŠØ± Ù…ØªØ§Ø­Ø©!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]])
            )
            return
        channel_info = self.paid_channels[channel_id]
        is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
        if is_member:
            if str(user_id) not in self.user_channel_subscriptions:
                self.user_channel_subscriptions[str(user_id)] = {}
            if channel_id not in self.user_channel_subscriptions[str(user_id)]:
                user['points'] += channel_info['points']


                self.user_channel_subscriptions[str(user_id)][channel_id] = {
                    "points": channel_info['points'],
                    "date": str(datetime.now())
                }
                self.save_json(USER_CHANNEL_SUBSCRIPTION_FILE, self.user_channel_subscriptions)
                if 'total_subscribers_count' not in self.paid_channels[channel_id]:
                    self.paid_channels[channel_id]['total_subscribers_count'] = 0
                self.paid_channels[channel_id]['total_subscribers_count'] += 1
                self.save_data_to_db('paid_channels', self.paid_channels)
                if channel_id in self.funded_channels:
                    funded_info = self.funded_channels[channel_id]
                    owner_id = funded_info['owner_id']
                    current_count = self.paid_channels[channel_id]['total_subscribers_count']
                    required_count = channel_info['members_required']
                    remaining = max(0, required_count - current_count)

                    try:
                        channel_link = f"[{channel_info['name']}]({channel_info['invite_link']})"
                        await context.bot.send_message(
                            owner_id,
                            f"ğŸ–ï¸ Ø§Ø´ØªØ±Ùƒ Ø´Ø®Øµ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ù‚Ù†Ø§ØªÙƒ {channel_link}\n\n"
                            f"ğŸ‘¥] Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {remaining}",
                            parse_mode='Markdown',
                            disable_web_page_preview=True
                        )
                    except:
                        try:
                            await context.bot.send_message(
                                owner_id,
                                f"ğŸ–ï¸ Ø§Ø´ØªØ±Ùƒ Ø´Ø®Øµ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ù‚Ù†Ø§ØªÙƒ!\n"
                                f"ğŸ“® {channel_info['name']}\n"
                                f"Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {remaining}"
                            )
                        except:
                            pass
                if self.paid_channels[channel_id]['total_subscribers_count'] >= channel_info['members_required']:
                    funding_number = None
                    for fund_num, fund_record in self.funding_numbers["records"].items():
                        if fund_record.get("channel_id") == channel_id and fund_record.get("funding_type") == "channel":
                            funding_number = fund_num
                            self.update_funding_status(fund_num, "Ù…ÙƒØªÙ…Ù„")
                            break

                    if channel_id in self.funded_channels:
                        funded_info = self.funded_channels[channel_id]
                        owner_id = funded_info['owner_id']
                        current_count = self.paid_channels[channel_id]['total_subscribers_count']

                        funding_record = self.get_funding_record_by_id(channel_id, "channel")
                        correct_funding_number = funding_record.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­") if funding_record else "ØºÙŠØ± Ù…ØªØ§Ø­"

                        try:
                            await context.bot.send_message(
                                owner_id,
                                f"ğŸ‰ ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ØªÙ… Ø§ÙƒØªÙ…Ø§Ù„ ØªÙ…ÙˆÙŠÙ„ Ù‚Ù†Ø§ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                                f"ğŸ“£ Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_info['name']}\n"
                                f"ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ÙƒØªÙ…Ù„: {current_count}\n"
                                f"ğŸ†” Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: #{correct_funding_number}\n"
                                f"ğŸ’° Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø©: {self.format_points(funded_info.get('cost_paid', 0))} ğŸª\n\n"
                                f"ğŸ’¼ ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ÙÙŠ Ù‚Ø³Ù… 'ØªÙ…ÙˆÙŠÙ„Ø§ØªÙŠ'\n"
                                f"âœ… ÙŠÙ…ÙƒÙ†Ùƒ ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù‚Ù†Ø§Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ±ÙŠØ¯ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡"
                            )

                            try:
                                await context.bot.send_message(
                                    ADMIN_ID,
                                    f"âœ… ØªÙ… Ø¥Ø´Ø¹Ø§Ø± ØµØ§Ø­Ø¨ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ({owner_id}) Ø¨Ø¥ÙƒØªÙ…Ø§Ù„ ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù‚Ù†Ø§Ø© {channel_info['name']} Ø¨Ù†Ø¬Ø§Ø­"
                                )
                            except Exception as e:
                                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")

                        except Exception as e:
                            logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø§ÙƒØªÙ…Ø§Ù„ Ù„ØµØ§Ø­Ø¨ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ {owner_id}: {e}")
                            try:
                                await context.bot.send_message(
                                    ADMIN_ID,
                                    f"âŒ ÙØ´Ù„ Ø¥Ø´Ø¹Ø§Ø± ØµØ§Ø­Ø¨ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ({owner_id}) Ø¨Ø¥ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù‚Ù†Ø§Ø© {channel_info['name']}\n"
                                    f"Ø§Ù„Ø³Ø¨Ø¨: {str(e)}"
                                )
                            except:
                                pass

                    if channel_id in self.funded_channels:
                        self.funded_channels[channel_id]['status'] = 'Ù…ÙƒØªÙ…Ù„'
                        self.funded_channels[channel_id]['completion_date'] = str(datetime.now())
                        self.funded_channels[channel_id]['final_members_count'] = self.paid_channels[channel_id]['total_subscribers_count']

                        self.move_funding_to_completed(channel_id, "channel")

                    funding_record = self.get_funding_record_by_id(channel_id, "channel")
                    correct_funding_number = funding_record.get("funding_number", "ØºÙŠØ± Ù…ØªØ§Ø­") if funding_record else "ØºÙŠØ± Ù…ØªØ§Ø­"

                    await context.bot.send_message(
                        ADMIN_ID,
                        f"ğŸ‰ ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ù‚Ù†Ø§Ø©!\n\n"
                        f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_info['name']}\n"
                        f"ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {channel_info['members_required']}\n"
                        f"âœ… Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.paid_channels[channel_id]['total_subscribers_count']}\n"
                        f"ğŸ”¢ Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: #{correct_funding_number}\n\n"
                        f"âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ÙÙŠ Ø§Ù„Ø£Ø±Ø´ÙŠÙ ÙˆØ¥Ø²Ø§Ù„ØªÙ‡ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø´Ø·Ø©."
                    )

                    if channel_id in self.paid_channels:
                        del self.paid_channels[channel_id]
                        self.save_data_to_db('paid_channels', self.paid_channels)

                    if channel_id in self.monitored_channels:
                        del self.monitored_channels[channel_id]
                        self.save_json(MONITORED_CHANNELS_FILE, self.monitored_channels)

                    self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)


                await update.callback_query.edit_message_text(
                    f"ğŸ›ï¸â€¢| ØªÙ… Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­ ÙˆØ­ØµÙ„Øª Ø¹Ù„Ù‰ {self.format_points(channel_info['points'])} ğŸª\n"
                    f"â€¼ï¸â€¢| Ø§Ø°Ø§ ØºØ§Ø¯Ø±Øª Ø³ÙŠØªÙ… Ø®ØµÙ… Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ù…Ù†Ùƒ"
                )
                await asyncio.sleep(1)  # ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ·

                next_channel_id, next_channel_info = await self.get_next_paid_channel(user_id, context)

                if next_channel_id:
                    keyboard = [
                        [
                            InlineKeyboardButton("ğŸ“º Ø§Ø´ØªØ±Ùƒ", url=next_channel_info['invite_link']),
                            InlineKeyboardButton("ØªØ­Ù‚Ù‚ âœ…", callback_data=f"check_paid_{next_channel_id}")
                        ],
                        [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]
                    ]
                    await context.bot.send_message(
                        user_id,
                        f"ğŸ›ï¸|â€¢ Ø§Ø´ØªØ±Ùƒ ÙÙŠ : {next_channel_info['name']}\n"
                        f"â–«ï¸|â€¢ ÙˆØ£ÙØ­ØµÙ„ Ø¹Ù„Ù‰ :  {self.format_points(next_channel_info['points'])} ğŸª\n\n",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        disable_web_page_preview=True
                    )

                else:
                    await context.bot.send_message(
                        user_id,
                        "âœ… Ù„Ù‚Ø¯ Ø§Ø´ØªØ±ÙƒØª ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©!\n\n"
                        "ğŸ”’ Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø±ØµÙŠØ¯ÙƒØŒ ÙŠÙØ±Ø¬Ù‰ Ø¹Ø¯Ù… Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª.",
                        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
                    )

            else:
                await update.callback_query.answer()
        else:
            await update.callback_query.answer()

    async def track_mandatory_subscription(self, user_id, channel_id, context=None):
        pass

    async def show_user_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        successful_invites = user.get("referrals_count", 0)

        funded_channels_count = len(user.get("funded_channels", []))

        used_cookies = 0
        if str(user_id) in self.user_channel_subscriptions:
            for sub_info in self.user_channel_subscriptions[str(user_id)].values():
                used_cookies += sub_info.get('points', 0)

        for channel_id in user.get("funded_channels", []):
            if channel_id in self.funded_channels:
                used_cookies += self.funded_channels[channel_id].get('cost_paid', 0)

        try:
            bot_username = (await context.bot.get_me()).username
            invite_link = f"https://t.me/{bot_username}?start={user['invite_link']}"
        except:
            invite_link = "ØºÙŠØ± Ù…ØªØ§Ø­"

        text = f"â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©:\n\n" \
               f"ğŸ†” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: `{user_id}`\n" \
               f"ğŸª Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ø­Ø§Ù„ÙŠØ©: {self.format_points(user['points'])}\n" \
               f"ğŸª Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©: {self.format_points(used_cookies)}\n" \
               f"ğŸ’° Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ù…ÙˆÙ„Ø©: {funded_channels_count}\n" \
               f"ğŸ”— Ø§Ù„Ø¯Ø¹ÙˆØ§Øª: {successful_invites}\n" \
               f"ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…: {user['joined_date'][:10]}\n\n" \
               f"ğŸ”— Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ:\n`{invite_link}`"

        share_message = (
            f"@s1x2bot âŒï¸™ Ø£Ù†Ø¶Ù… Ø§Ù„Ù‰ Ø¨ÙˆØª ØªÙŠØ±Ø¨Ùˆ ÙÙˆÙ„Ùˆ  â†«â¤ˆ\n"
            f"âŒï¸™Ø¹Ù†Ø¯Ù…Ø§ ØªÙ‚ÙˆÙ… Ø¨ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª \n"
            f"âŒï¸™ Ø³ÙˆÙ ØªØ­ØµÙ„ Ø¹Ù„Ù‰ â†« 100 ÙƒÙˆÙƒÙŠØ²\n"
            f"âŒï¸™Ø±Ø´Ù‚ Ù„Ø§ÙŠÙƒØ§Øª Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ø´ØªØ±Ø§Ùƒ Ø¥Ø¬Ø¨Ø§Ø±ÙŠ Ø­Ø³Ø§Ø¨Ø§Øª Ø¹Ø±Ø¨ÙŠØ©\n"
            f"âŒï¸™ÙŠÙˆÙØ± ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙˆØ§Ù„Ø¨ÙˆØªØ§Øª Ø­Ù‚ÙŠÙ‚ÙŠ 100%\n"
            f"âŒï¸™ ÙŠÙ…ÙƒÙ†Ùƒ Ø´Ø±Ø§Ø¡ Ù†Ø¬ÙˆÙ… ØªØ³Ù„ÙŠÙ… ØªÙ„Ù‚Ø§Ø¦ÙŠ\n"
            f"âŒï¸™Ø§Ù„Ø¨ÙˆØª ÙŠÙ…ØªØ§Ø² Ø¨Ø³Ø±Ø¹Ø© ØªÙ†ÙÙŠØ° Ø§Ù„Ø·Ù„Ø¨ âœ“ .\n"
            f"âŒï¸™ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨ÙˆØª â†«â¤ˆ\n"
            f"{invite_link}"
        )

        import urllib.parse
        encoded_message = urllib.parse.quote(share_message)
        share_url = f"https://t.me/share/url?url={encoded_message}"

        keyboard = [
            [InlineKeyboardButton("Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© ğŸ“¤", url=share_url)],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_instructions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        text = """ğŸ“Œ ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… - ÙŠÙØ±Ø¬Ù‰ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ø¨Ø¹Ù†Ø§ÙŠØ©

ÙÙŠ Ø³Ø¹ÙŠÙ†Ø§ Ø§Ù„Ù…Ø³ØªÙ…Ø± Ù„ØªÙ‚Ø¯ÙŠÙ… Ø£ÙØ¶Ù„ ØªØ¬Ø±Ø¨Ø© Ù…Ù…ÙƒÙ†Ø© Ù„Ø¬Ù…ÙŠØ¹ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†Ø§ØŒ Ù†Ø¤ÙƒØ¯ Ø¹Ù„Ù‰ Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø§Ù„ØªØ²Ø§Ù… Ø¨Ø³ÙŠØ§Ø³Ø§Øª Ø§Ù„Ø¨ÙˆØª ÙˆÙ‚ÙˆØ§Ø¹Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ØŒ ÙˆØ°Ù„Ùƒ Ù„Ø¶Ù…Ø§Ù† Ø¨ÙŠØ¦Ø© Ø¹Ø§Ø¯Ù„Ø© ÙˆØ¢Ù…Ù†Ø© Ù„Ù„Ø¬Ù…ÙŠØ¹.

ğŸš« ÙŠÙÙ…Ù†Ø¹ Ø¨Ø´ÙƒÙ„ Ù‚Ø§Ø·Ø¹:

-Ø¯Ø¹ÙˆØ© Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø³Ø§Ø¨Ø§Øª ÙˆÙ‡Ù…ÙŠØ© Ù„Ø£ÙŠ ØºØ±Ø¶ ÙƒØ§Ù†.
-Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ­Ø§ÙŠÙ„ Ø¹Ù„Ù‰ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ø£Ùˆ Ø¥Ø³Ø§Ø¡Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡.
-Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ø§Ù„Ø¨ÙˆØª Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ.

ğŸ—³ï¸ Ù…Ù…Ù†ÙˆØ¹ Ø·Ù„Ø¨ Ø§ÙƒØ«Ø± Ù…Ù† Ø®Ø¯Ù…Ø© Ù…Ù† Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø±Ø´Ù‚ Ù„Ù†ÙØ³ Ø§Ù„Ø±Ø§Ø¨Ø· Ø¨Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª 
- Ø§Ù„Ø³Ø¨Ø¨ :  Ù…Ù† Ø§Ù„Ù…Ù…ÙƒÙ† ØªØ­Ø¯Ø« Ù…Ø´Ø§ÙƒÙ„ ÙˆÙŠØªÙ… Ø³Ø­Ø¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ÙˆÙ„Ø§ ÙŠØªÙ… Ø§Ø±Ø¬Ø§Ø¹ Ø±ØµÙŠØ¯Ùƒ!
- Ø£Ù† ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø±Ø´Ù‚ Ø¨Ø§ÙŠ Ø·Ø±ÙŠÙ‚Ø© ÙƒØ§Ù†Øª Ø³ÙŠØ¤Ø¯ÙŠ Ù‡Ø°Ø§ Ø§Ù„ÙØ¹Ù„ Ø¢Ù„Ù‰ Ø®ØµÙ… Ø±ØµÙŠØ¯Ùƒ Ø¨Ø¯ÙˆÙ† ØªÙ†ÙÙŠØ° Ø£ÙŠ Ø¹Ù…Ù„ÙŠØ© 

âš ï¸ Ø¥Ù† Ø§Ø±ØªÙƒØ§Ø¨ Ø£ÙŠ Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø®Ø§Ù„ÙØ§Øª ÙŠÙØ¹Ø¯Ù‘ Ø®Ø±Ù‚Ù‹Ø§ ØµØ±ÙŠØ­Ù‹Ø§ Ù„Ø´Ø±ÙˆØ· Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…ØŒ ÙˆÙŠØ¤Ø¯ÙŠ Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø¸Ø± Ø§Ù„Ø¯Ø§Ø¦Ù… Ù…Ù† Ø§Ù„Ø¨ÙˆØª Ø¯ÙˆÙ† Ø³Ø§Ø¨Ù‚ Ø¥Ù†Ø°Ø§Ø±.

Ù†Ø­Ù† Ù†Ø«Ù‚ Ø¨ÙƒÙ… ÙˆÙ†Ø¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ÙˆØ¹ÙŠÙƒÙ… ÙÙŠ Ø§Ù„Ø§Ù„ØªØ²Ø§Ù…ØŒ ÙˆÙ†Ø¹Ù…Ù„ Ø¨Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø¹Ù„Ù‰ ØªØ·ÙˆÙŠØ± Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØªØ­Ø³ÙŠÙ† Ø¬ÙˆØ¯Ø© Ø§Ù„Ø®Ø¯Ù…Ø©. ØªØ¹Ø§ÙˆÙ†ÙƒÙ… Ù…Ø¹Ù†Ø§ Ù‡Ùˆ Ø§Ù„Ø£Ø³Ø§Ø³ Ø§Ù„Ø°ÙŠ Ù†Ø¨Ù†ÙŠ Ø¹Ù„ÙŠÙ‡ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù†Ø¸ÙˆÙ…Ø©.

ğŸ’¡ ÙÙŠ Ø­Ø§Ù„ ÙˆØ¬ÙˆØ¯ Ø£ÙŠ Ø§Ø³ØªÙØ³Ø§Ø± Ø£Ùˆ Ø´ÙƒÙˆÙ‰ØŒ ÙŠÙ…ÙƒÙ†ÙƒÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©. @cxxov

Ù…Ø¹ Ø®Ø§Ù„Øµ Ø§Ù„ØªÙ‚Ø¯ÙŠØ± ÙˆØ§Ù„Ø§Ø­ØªØ±Ø§Ù…ØŒ ÙØ±ÙŠÙ‚ Ø¥Ø¯Ø§Ø±Ø©    Ø¨ÙˆØª ØªÙŠØ±Ø¨Ùˆ ÙÙˆÙ„Ùˆ ğŸª"""

        keyboard = [
            [InlineKeyboardButton("ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ø¨ÙˆØª ğŸ› ", callback_data="bot_updates")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_my_fundings(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        await self.delete_old_mandatory_message(context, user_id)

        user_fundings = self.get_user_fundings_from_permanent_record(user_id)

        if not user_fundings:
            await update.callback_query.edit_message_text(
                "ğŸ’¼ ØªÙ…ÙˆÙŠÙ„Ø§ØªÙŠ\n\n"
                "âŒ Ù„Ù… ØªÙ‚Ù… Ø¨Ø£ÙŠ Ø¹Ù…Ù„ÙŠØ§Øª ØªÙ…ÙˆÙŠÙ„ Ø¨Ø¹Ø¯\n\n"
                "ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø¨Ø¯Ø¡ ØªÙ…ÙˆÙŠÙ„ Ù‚Ù†Ø§Ø© Ø£Ùˆ Ø¨ÙˆØª Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]])
            )
            return

        keyboard = []
        text = f"ğŸ’¼ ØªÙ…ÙˆÙŠÙ„Ø§ØªÙŠ ({len(user_fundings)} ØªÙ…ÙˆÙŠÙ„):\n\n"

        keyboard.append([
            InlineKeyboardButton("Ø§Ù„Ø­Ø§Ù„Ø©", callback_data="header_status"),
            InlineKeyboardButton("Ø§Ù„Ø¹Ø¯Ø¯", callback_data="header_count"), 
            InlineKeyboardButton("Ø§Ù„Ù†ÙˆØ¹", callback_data="header_type"),
            InlineKeyboardButton("Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„", callback_data="header_number")
        ])

        for funding in user_fundings:
            if funding['status'] == "Ù…ÙƒØªÙ…Ù„ ğŸŸ¢":
                status_icon = "ğŸŸ¢ Ù…ÙƒØªÙ…Ù„"
                status_text = "Ù…ÙƒØªÙ…Ù„"
            elif funding['status'] == "Ù†Ø´Ø· ğŸŸ¡":
                status_icon = "ğŸŸ¡ Ù†Ø´Ø·" 
                status_text = "Ù†Ø´Ø·"
            elif funding['status'] == "Ù…Ù„ØºÙŠ ğŸ”´":
                status_icon = "ğŸ”´ Ù…Ù„ØºÙŠ"
                status_text = "Ù…Ù„ØºÙŠ"
            else:
                status_icon = "âšª"
                status_text = "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"

            progress = f"{funding['current_count']}/{funding['required_count']}"
            if funding['type'] == "Ù‚Ù†Ø§Ø©":
                type_callback = f"funding_channel_link_{funding['id']}"
            else: 
                type_callback = f"funding_bot_link_{funding['id']}"

            keyboard.append([
                InlineKeyboardButton(f"{status_icon}", callback_data=f"funding_status_info_{funding['id']}"),
                InlineKeyboardButton(progress, callback_data=f"funding_progress_{funding['id']}"),
                InlineKeyboardButton(funding['type'], callback_data=type_callback),
                InlineKeyboardButton(f"#{funding['funding_number']}", callback_data=f"funding_details_{funding['id']}_{funding['type']}")
            ])

        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")])

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_funding_details(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        parts = data.split("_")
        funding_id = parts[2]
        funding_type_param = parts[3] if len(parts) > 3 else "channel"

        user_id = update.effective_user.id
        user_fundings = self.get_user_fundings_from_permanent_record(user_id)

        selected_funding = None
        for funding in user_fundings:
            if funding['id'] == funding_id:
                selected_funding = funding
                break

        if not selected_funding:
            await update.callback_query.answer("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…ÙˆÙŠÙ„!")
            return

        status_details = {
            "Ù…ÙƒØªÙ…Ù„ ğŸŸ¢": "ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø¨Ù†Ø¬Ø§Ø­ âœ…",
            "Ù†Ø´Ø· ğŸŸ¡": "Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ù‚ÙŠØ¯ Ø§Ù„ØªÙ†ÙÙŠØ° ÙˆØ§Ù„Ø¹Ù…Ù„ Ø¬Ø§Ø±ÙŠ ğŸ”„", 
            "Ù…Ù„ØºÙŠ ğŸ”´": "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ù„Ø£Ø³Ø¨Ø§Ø¨ ÙÙ†ÙŠØ© âŒ"
        }

        status_detail = status_details.get(selected_funding['status'], "Ø­Ø§Ù„Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©")
        if selected_funding['required_count'] > 0:
            completion_percentage = (selected_funding['current_count'] / selected_funding['required_count']) * 100
        else:
            completion_percentage = 0
        try:
            funding_date = datetime.strptime(selected_funding['date'], '%Y-%m-%d %H:%M:%S.%f')
            formatted_date = funding_date.strftime('%Y-%m-%d %I:%M %p').replace('AM', 'Øµ').replace('PM', 'Ù…')
        except:
            formatted_date = selected_funding['date'][:16] if selected_funding['date'] else 'ØºÙŠØ± Ù…ØªØ§Ø­'

        details_text = f"ğŸ’¼ ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ #{selected_funding['funding_number']}\n\n"
        details_text += f"ğŸ“º Ø§Ù„Ø§Ø³Ù…: {selected_funding['name']}\n"
        details_text += f"ğŸ·ï¸ Ø§Ù„Ù†ÙˆØ¹: {selected_funding['type']}\n"
        details_text += f"ğŸ“Š Ø§Ù„Ø­Ø§Ù„Ø©: {selected_funding['status']}\n"
        details_text += f"ğŸ’¡ {status_detail}\n\n"
        details_text += f"ğŸ‘¥ Ø§Ù„ØªÙ‚Ø¯Ù…: {selected_funding['current_count']}/{selected_funding['required_count']}\n"
        details_text += f"ğŸ“ˆ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²: {completion_percentage:.1f}%\n"
        details_text += f"ğŸ’° Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø©: {self.format_points(selected_funding['cost'])} ğŸª\n"
        details_text += f"ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„ØªÙ…ÙˆÙŠÙ„: {formatted_date}\n\n"

        if selected_funding['status'] == "Ù†Ø´Ø· ğŸŸ¡":
            remaining = selected_funding['required_count'] - selected_funding['current_count']
            details_text += f"â³ Ù…ØªØ¨Ù‚ÙŠ: {remaining} Ø¹Ø¶Ùˆ\n"
            details_text += f"ğŸ¯ Ø³ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ø¥Ø´Ø¹Ø§Ø± Ø¹Ù†Ø¯ ÙƒÙ„ Ø§Ø´ØªØ±Ø§Ùƒ Ø¬Ø¯ÙŠØ¯"
        elif selected_funding['status'] == "Ù…ÙƒØªÙ…Ù„ ğŸŸ¢":
            details_text += f"ğŸ‰ ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­!\n"
            details_text += f"âœ… Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„"

        keyboard = [
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ØªÙ…ÙˆÙŠÙ„Ø§Øª", callback_data="my_fundings")],
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            details_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def handle_funding_channel_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        funding_id = data.split("_")[-1]
        user_id = update.effective_user.id
        user_fundings = self.get_user_fundings_from_permanent_record(user_id)
        selected_funding = None
        for funding in user_fundings:
            if funding['id'] == funding_id:
                selected_funding = funding
                break

        if not selected_funding:
            await update.callback_query.answer("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…ÙˆÙŠÙ„!")
            return

        channel_link = None
        if funding_id in self.paid_channels:
            channel_link = self.paid_channels[funding_id].get('invite_link')
        elif funding_id in self.completed_fundings.get("channels", {}):
            channel_link = self.completed_fundings["channels"][funding_id].get('channel_invite_link')

        if channel_link:
            await update.callback_query.answer(url=channel_link)
        else:
            await update.callback_query.answer("âŒ Ø§Ù„Ø±Ø§Ø¨Ø· ØºÙŠØ± Ù…ØªØ§Ø­ Ø­Ø§Ù„ÙŠØ§Ù‹", show_alert=True)

    async def handle_funding_bot_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        funding_id = data.split("_")[-1]
        user_id = update.effective_user.id
        user_fundings = self.get_user_fundings_from_permanent_record(user_id)
        selected_funding = None
        for funding in user_fundings:
            if funding['id'] == funding_id:
                selected_funding = funding
                break

        if not selected_funding:
            await update.callback_query.answer("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…ÙˆÙŠÙ„!")
            return

        bot_username = None
        if funding_id in self.paid_bots:
            bot_username = self.paid_bots[funding_id].get('username')
        elif funding_id in self.completed_fundings.get("bots", {}):
            bot_username = self.completed_fundings["bots"][funding_id].get('bot_username')

        if bot_username:
            bot_link = f"https://t.me/{bot_username}"
            await update.callback_query.answer(url=bot_link)
        else:
            await update.callback_query.answer("âŒ Ø§Ù„Ø±Ø§Ø¨Ø· ØºÙŠØ± Ù…ØªØ§Ø­ Ø­Ø§Ù„ÙŠØ§Ù‹", show_alert=True)

    async def show_bot_updates(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        keyboard = [
            [InlineKeyboardButton("Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ğŸ“¢", url="https://t.me/TurboFollow2")],
            [InlineKeyboardButton("Ù‚Ù†Ø§Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ğŸ’°", url="https://t.me/TurboFollow4"),
            InlineKeyboardButton("Ù‚Ù†Ø§Ø© Ø§Ù„Ù†Ø¬ÙˆÙ… â­", url="https://t.me/TurboFollow3")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]
        ]

        text = """ğŸ“¢ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ø¨ÙˆØª"""

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            disable_web_page_preview=True
        )
    async def show_transfer_cookies_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        await update.callback_query.edit_message_text(
            f"ğŸ”„ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙƒÙˆÙƒÙŠØ²\n\n"
            f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n"
            f"âš ï¸ Ø£Ù‚Ù„ Ù…Ø¨Ù„Øº Ù„Ù„ØªØ­ÙˆÙŠÙ„: 5000 ÙƒÙˆÙƒÙŠØ²\n\n"
            f"ğŸ“ Ø£Ø±Ø³Ù„ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„ÙŠÙ‡:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="back_to_main")]])
        )
        context.user_data['waiting_for'] = 'transfer_target_id'

    async def handle_transfer_target_id(self, update: Update, context: ContextTypes.DEFAULT_TYPE, target_id_text):
        try:
            target_id = int(target_id_text.strip())
            sender_id = update.effective_user.id

            if target_id == sender_id:
                await update.message.reply_text("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ù„Ù†ÙØ³Ùƒ!")
                return
            if str(target_id) not in self.users:
                await update.message.reply_text("âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…!")
                return
            context.user_data['transfer_target_id'] = target_id
            context.user_data['waiting_for'] = 'transfer_amount'
            sender = self.get_user(sender_id)
            await update.message.reply_text(
                f"âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù: {target_id}\n\n"
                f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(sender['points'])} ğŸª\n"
                f"âš ï¸ Ø£Ù‚Ù„ Ù…Ø¨Ù„Øº Ù„Ù„ØªØ­ÙˆÙŠÙ„: 5000 ÙƒÙˆÙƒÙŠØ²\n\n"
                f"ğŸ“ Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªØ­ÙˆÙŠÙ„Ù‡Ø§:"
            )
        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø¢ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)!")
    async def handle_transfer_amount(self, update: Update, context: ContextTypes.DEFAULT_TYPE, amount_text):
        try:
            amount = float(amount_text.strip())
            sender_id = update.effective_user.id
            target_id = context.user_data.get('transfer_target_id')

            if amount <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ø¨Ù„Øº Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return
            if amount < 5000:
                await update.message.reply_text("âŒ Ø£Ù‚Ù„ Ù…Ø¨Ù„Øº ÙŠÙ…ÙƒÙ† ØªØ­ÙˆÙŠÙ„Ù‡ Ù‡Ùˆ 5000 ÙƒÙˆÙƒÙŠØ²!")
                return
            sender = self.get_user(sender_id)
            target = self.get_user(target_id)
            if sender['points'] < amount:
                await update.message.reply_text(
                    f"âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                    f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(sender['points'])} ğŸª\n"
                    f"ğŸ“ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {self.format_points(amount)} ğŸª"
                )
                return
            sender['points'] -= amount
            target['points'] += amount

            context.user_data['waiting_for'] = None
            if 'transfer_target_id' in context.user_data:
                del context.user_data['transfer_target_id']
            await update.message.reply_text(
                f"âœ… ØªÙ… ØªØ­ÙˆÙŠÙ„ {self.format_points(amount)} ğŸª Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ‘¤ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {target_id}\n"
                f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(sender['points'])} ğŸª"
            )
            try:
                await context.bot.send_message(
                    target_id,
                    f"ğŸ‰ ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… ØªØ­ÙˆÙŠÙ„!\n\n"
                    f"ğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: {self.format_points(amount)} ğŸª\n"
                    f"ğŸ‘¤ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {sender_id}\n"
                    f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(target['points'])} ğŸª"
                )
            except:
                pass
            try:
                await context.bot.send_message(
                    ADMIN_ID,
                    f"ğŸ”„ Ø¹Ù…Ù„ÙŠØ© ØªØ­ÙˆÙŠÙ„ ÙƒÙˆÙƒÙŠØ²\n\n"
                    f"ğŸ‘¤ Ø§Ù„Ù…Ø±Ø³Ù„: {sender_id}\n"
                    f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„: {target_id}\n"
                    f"ğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: {self.format_points(amount)} ğŸª\n"
                    f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}"
                )
            except:
                pass
        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")
    async def show_admin_panel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [
                InlineKeyboardButton("ğŸ“º Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ", callback_data="manage_mandatory"),
                InlineKeyboardButton("ğŸ’° Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø¯ÙÙˆØ¹", callback_data="manage_paid")
            ],
            [InlineKeyboardButton("ğŸ“¢ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©", callback_data="broadcast")],
            [
                InlineKeyboardButton("â• Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø·", callback_data="add_points"),
                InlineKeyboardButton("â– Ø®ØµÙ… Ù†Ù‚Ø§Ø·", callback_data="remove_points")
            ],
            [
                InlineKeyboardButton("ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†", callback_data="manage_users"),
                InlineKeyboardButton("ğŸ Ø±Ø§Ø¨Ø· Ø§Ù„Ù‡Ø¯ÙŠØ©", callback_data="gift_link")
            ],
            [InlineKeyboardButton("ğŸ« Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ù‡Ø¯ÙŠØ©", callback_data="create_gift_code")],
            [
                InlineKeyboardButton("ğŸ”¢ Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø®ÙˆÙ„", callback_data="entry_points"),
                InlineKeyboardButton("ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="statistics")
            ],
            [
                InlineKeyboardButton("ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¹Ø¶Ùˆ", callback_data="member_price"),
                InlineKeyboardButton("âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª", callback_data="admin_settings")
            ],
            [
                InlineKeyboardButton("ğŸ”§ Ø§Ù„ØµÙŠØ§Ù†Ø©", callback_data="maintenance"),
                InlineKeyboardButton("ğŸ§¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª", callback_data="user_info_admin")
            ],
            [
                InlineKeyboardButton("ğŸ’° Ø³Ø¹Ø± Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù‚Ù†ÙˆØ§Øª", callback_data="subscription_price")
            ],
            [
                InlineKeyboardButton("ğŸ”¢ Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ ÙŠÙ…ÙƒÙ† ØªÙ…ÙˆÙŠÙ„Ù‡", callback_data="min_funding_members")
            ],
            [
                InlineKeyboardButton("ğŸ Ø¹Ø¯Ø¯ Ø§Ù„Ù‡Ø¯ÙŠØ©", callback_data="daily_gift_amount"),
                InlineKeyboardButton("ğŸ‘¥ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª", callback_data="accounts_info")
            ],
            [
                InlineKeyboardButton("ğŸ¤– Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø©", callback_data="manage_paid_bots"),
                InlineKeyboardButton("Ø´ÙØ§Ù", callback_data="transparent")
            ],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            "ğŸ‘¨â€ğŸ’¼ Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©:\n\n"
            "Ø§Ø®ØªØ± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def user_info_admin_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'user_info_admin_id'
        await update.callback_query.edit_message_text(
            "ğŸ§¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:\n\n"
            "Ø£Ø±Ø³Ù„ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙ‡ Ø§Ù„ÙƒØ§Ù…Ù„Ø©:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )
    async def delivery_username_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'delivery_username_value'
        await update.callback_query.edit_message_text(
            f"ğŸ‘¤ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø±Ø³Ù„:\n\n"
            f"Ø£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ù…Ø±Ø³Ù„ (Ù…Ø«Ø§Ù„: @username):",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )
    async def manage_mandatory_channels(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        status_icon = "ğŸŸ¢" if self.mandatory_enabled else "ğŸ”´"
        status_text = "Ù…ÙØ¹Ù„" if self.mandatory_enabled else "Ù…Ø¹Ø·Ù„"
        toggle_text = "ğŸ”´ Ø¥ÙŠÙ‚Ø§Ù" if self.mandatory_enabled else "ğŸŸ¢ ØªØ´ØºÙŠÙ„"

        keyboard = [
            [InlineKeyboardButton(toggle_text, callback_data="toggle_mandatory")],
            [
                InlineKeyboardButton("â• Ø£Ø¶Ø§ÙØ© Ù‚Ù†Ø§Ø© Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©", callback_data="add_mandatory_channel"),
                InlineKeyboardButton("ğŸ—‘ï¸ Ø­Ø°Ù Ù‚Ù†Ø§Ø© Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©", callback_data="delete_mandatory_channel")
            ],
            [InlineKeyboardButton("ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="update_mandatory_stats")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")]
        ]
        text = "ğŸ“º Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©:\n\n"
        text += f"ğŸ“Š Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ: {status_icon} {status_text}\n\n"
        if self.mandatory_channels:
            text += "ğŸ“‹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:\n\n"
            for i, (channel_id, info) in enumerate(self.mandatory_channels.items(), 1):
                current_count = info.get('total_subscribers_count', 0)
                required_count = info.get('members_required', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')
                progress_percentage = f"({int((current_count/required_count)*100)}%)" if isinstance(required_count, int) and required_count > 0 else ""
                text += f"ğŸ”¸ Ø§Ù„Ù‚Ù†Ø§Ø© {i}:\n"
                text += f"   ğŸ“º Ø§Ù„Ø§Ø³Ù…: {info['name']}\n"
                text += f"   ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯: {current_count}/{required_count} {progress_percentage}\n"
                text += f"   ğŸ†” Ø§Ù„Ù…Ø¹Ø±Ù: {channel_id}\n\n"
        else:
            text += "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ© Ø­Ø§Ù„ÙŠØ§Ù‹.\n\n"
            text += "ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ù‚Ù†Ø§Ø© Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡."
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def delete_mandatory_channel_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.mandatory_channels:
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ© Ù„Ù„Ø­Ø°Ù!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_mandatory")]])
            )
            return
        keyboard = []
        for channel_id, info in self.mandatory_channels.items():
            keyboard.append([InlineKeyboardButton(f"ğŸ—‘ï¸ {info['name']}", callback_data=f"del_mandatory_{channel_id}")])
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_mandatory")])

        await update.callback_query.edit_message_text(
            "ğŸ—‘ï¸ Ø§Ø®ØªØ± Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø­Ø°ÙÙ‡Ø§:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def confirm_delete_mandatory_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        channel_id = data.split("_")[2]
        if channel_id in self.mandatory_channels:
            channel_name = self.mandatory_channels[channel_id]['name']
            del self.mandatory_channels[channel_id]
            self.save_data_to_db('mandatory_channels', self.mandatory_channels)
            await update.callback_query.edit_message_text(
                f"âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ© '{channel_name}' Ø¨Ù†Ø¬Ø§Ø­!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_mandatory")]])
            )
        else:
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù†Ø§Ø©!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_mandatory")]])
            )
    async def manage_paid_channels(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [
                InlineKeyboardButton("â• Ø¥Ø¶Ø§ÙØ© Ù‚Ù†Ø§Ø© Ù…Ø¯ÙÙˆØ¹Ø©", callback_data="add_paid_channel"),
                InlineKeyboardButton("ğŸ—‘ï¸ Ø­Ø°Ù Ù‚Ù†Ø§Ø© Ù…Ø¯ÙÙˆØ¹Ø©", callback_data="delete_paid_channel")
            ],
            [InlineKeyboardButton("ğŸ“Š Ø¥Ø¯Ø§Ø±Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¯ÙÙˆØ¹", callback_data="manage_paid_count")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")]
        ]
        text = "ğŸ’° Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø©:\n\n"
        if self.paid_channels:
            text += "Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©:\n"
            for channel_id, info in self.paid_channels.items():
                text += f"â€¢ {info['name']} - {self.format_points(info['points'])} ğŸª ({channel_id})\n"
        else:
            text += "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª Ù…Ø¯ÙÙˆØ¹Ø© Ø­Ø§Ù„ÙŠØ§Ù‹."
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def delete_paid_channel_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.paid_channels:
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª Ù…Ø¯ÙÙˆØ¹Ø© Ù„Ù„Ø­Ø°Ù!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_paid")]])
            )
            return

        keyboard = []
        for channel_id, info in self.paid_channels.items():
            keyboard.append([InlineKeyboardButton(f"ğŸ—‘ï¸ {info['name']}", callback_data=f"del_paid_{channel_id}")])

        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_paid")])

        await update.callback_query.edit_message_text(
            "ğŸ—‘ï¸ Ø§Ø®ØªØ± Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø­Ø°ÙÙ‡Ø§:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def confirm_delete_paid_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        channel_id = data.split("_")[2]

        if channel_id in self.paid_channels:
            channel_name = self.paid_channels[channel_id]['name']

            del self.paid_channels[channel_id]
            self.save_data_to_db('paid_channels', self.paid_channels)

            if channel_id in self.monitored_channels:
                del self.monitored_channels[channel_id]
                self.save_json(MONITORED_CHANNELS_FILE, self.monitored_channels)

            if channel_id in self.funded_channels:
                del self.funded_channels[channel_id]
                self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)

            await update.callback_query.edit_message_text(
                f"âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ù‚Ù†Ø§Ø© '{channel_name}' Ø¨Ù†Ø¬Ø§Ø­ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù‚Ø³Ø§Ù…!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_paid")]])
            )
        else:
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù†Ø§Ø©!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_paid")]])
            )
    async def manage_paid_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.paid_channels:
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª Ù…Ø¯ÙÙˆØ¹Ø©!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")]])
            )
            return
        keyboard = []
        text = "ğŸ“Š Ø¥Ø¯Ø§Ø±Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¯ÙÙˆØ¹:\n\n"
        for channel_id, info in self.paid_channels.items():
            total_subscribers = info.get('total_subscribers_count', 0)
            required = info['members_required']
            keyboard.append([
                InlineKeyboardButton(f"ğŸ“º {info['name']}", callback_data=f"channel_info_{channel_id}"),       InlineKeyboardButton(f"{total_subscribers}/{required}", callback_data=f"count_info_{channel_id}")
            ])
            text += f"ğŸ“º {info['name']}\n"
            text += f"ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯: {total_subscribers}/{required}\n\n"
        keyboard.append([InlineKeyboardButton("ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©", callback_data="update_paid_status")])
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")])
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def update_paid_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.callback_query.edit_message_text("ğŸ”„ Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©...")
        await asyncio.sleep(1)
        await self.manage_paid_count(update, context)
    async def update_mandatory_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.callback_query.edit_message_text("ğŸ”„ Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©...")
        total_updated = 0
        for channel_id, channel_info in self.mandatory_channels.items():
            try:
                chat = await context.bot.get_chat(channel_id)
                real_member_count = getattr(chat, 'member_count', None)
                if real_member_count:                channel_info['real_member_count'] = real_member_count
                total_updated += 1
            except Exception as e:
                logger.error(f"ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù‚Ù†Ø§Ø© {channel_id}: {e}")
        self.save_data_to_db('mandatory_channels', self.mandatory_channels)
        await asyncio.sleep(1)
        await self.manage_mandatory_channels(update, context)
    async def add_mandatory_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'mandatory_channel_username'
        await update.callback_query.edit_message_text(
            "ğŸ“º Ø¥Ø¶Ø§ÙØ© Ù‚Ù†Ø§Ø© Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©:\n\n"
            "Ø£Ø±Ø³Ù„ ÙŠÙˆØ²Ø±Ù†ÙŠÙ… Ø§Ù„Ù‚Ù†Ø§Ø© (ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ @):\n"
            "Ù…Ø«Ø§Ù„: @mychannel",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="manage_mandatory")]])
        )
    async def add_paid_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'paid_channel_id'
        await update.callback_query.edit_message_text(
            "ğŸ’° Ø¥Ø¶Ø§ÙØ© Ù‚Ù†Ø§Ø© Ù…Ø¯ÙÙˆØ¹Ø©:\n\n"
            "Ø£Ø±Ø³Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù‚Ù†Ø§Ø© (ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ -):\n"
            "Ù…Ø«Ø§Ù„: -1001234567890",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="manage_paid")]])
        )
    async def toggle_mandatory_subscription(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        self.mandatory_enabled = not self.mandatory_enabled
        self.db.set_setting('mandatory_enabled', self.mandatory_enabled)

        status = "Ù…ÙØ¹Ù„" if self.mandatory_enabled else "Ù…Ø¹Ø·Ù„"
        await update.callback_query.edit_message_text(
            f"âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ Ø¥Ù„Ù‰: {status}",
          reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="manage_mandatory")]])
        )
    async def broadcast_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'broadcast_message'
        await update.callback_query.edit_message_text(
            "ğŸ“¢ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©:\n\n"
            "Ø£Ø±Ø³Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø°Ø§Ø¹ØªÙ‡ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )
    async def add_points_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'add_points_user_id'
        await update.callback_query.edit_message_text(
            "â• Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø·:\n\n"
            "Ø£Ø±Ø³Ù„ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )
    async def remove_points_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'remove_points_user_id'
        await update.callback_query.edit_message_text(
            "â– Ø®ØµÙ… Ù†Ù‚Ø§Ø·:\n\n"
            "Ø£Ø±Ø³Ù„ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )
    async def manage_users_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        banned_text = "ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:\n\n"
        if self.banned_users:
            banned_text += "ğŸš« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙˆÙ†:\n"
            for user_id in self.banned_users.keys():
                banned_text += f"â€¢ {user_id}\n"
        else:
            banned_text += "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ù…Ø­Ø¸ÙˆØ±ÙˆÙ† Ø­Ø§Ù„ÙŠØ§Ù‹.\n"
        keyboard = [
            [
                InlineKeyboardButton("ğŸš« Ø­Ø¸Ø±", callback_data="ban_user"),
                InlineKeyboardButton("âœ… ÙÙƒ", callback_data="unban_user")
            ],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_users")]
        ]
        await update.callback_query.edit_message_text(
            banned_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def ban_user_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'ban_user_id'
        await update.callback_query.edit_message_text(
            "ğŸš« Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…:\n\n"
            "Ø£Ø±Ø³Ù„ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø±Ø§Ø¯ Ø­Ø¸Ø±Ù‡:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="manage_users")]])
        )
    async def unban_user_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'unban_user_id'
        await update.callback_query.edit_message_text(
            "âœ… ÙÙƒ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…:\n\n"
            "Ø£Ø±Ø³Ù„ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø±Ø§Ø¯ ÙÙƒ Ø­Ø¸Ø±Ù‡:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="manage_users")]])
        )
    async def gift_link_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [InlineKeyboardButton("ğŸ Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø§Ø¨Ø· Ù‡Ø¯ÙŠØ©", callback_data="create_gift_link")],
            [InlineKeyboardButton("ğŸ“‹ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø±ÙˆØ§Ø¨Ø·", callback_data="manage_gift_links")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")]
        ]
        await update.callback_query.edit_message_text(
            "ğŸ Ø¥Ø¯Ø§Ø±Ø© Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù‡Ø¯Ø§ÙŠØ§:\n\n"
            "Ø§Ø®ØªØ± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def member_price_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'member_price_value'
        await update.callback_query.edit_message_text(
            f"ğŸ’° Ø³Ø¹Ø± Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„ÙˆØ§Ø­Ø¯:\n\n"
            f"ğŸª Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.member_price} ÙƒÙˆÙƒÙŠØ²\n\n"
            f"Ø£Ø±Ø³Ù„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø¹Ø¶Ùˆ Ø§Ù„ÙˆØ§Ø­Ø¯:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )
    async def entry_points_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'entry_points_value'
        await update.callback_query.edit_message_text(
            f"ğŸ”¢ Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø®ÙˆÙ„:\n\n"
            f"ğŸ’° Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ø¯Ø¹ÙˆØ©: {self.format_points(self.invite_points)}\n\n"
            f"Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø§Ù„ØªÙŠ Ø³ÙŠØ­ØµÙ„ Ø¹Ù„ÙŠÙ‡Ø§ Ø§Ù„Ø¯Ø§Ø¹ÙŠ Ø¹Ù†Ø¯ Ø¯Ø¹ÙˆØ© Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )
    async def show_statistics(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        total_users = len(self.users)
        total_invites = sum(user.get("referrals_count", 0) for user in self.users.values())
        now = datetime.now()
        yesterday = now - timedelta(hours=24)
        daily_users = 0
        daily_invites = 0
        for user_id, user_data in self.users.items():
            if user_data.get("joined_date"):
                try:
                    join_date = datetime.strptime(user_data["joined_date"], '%Y-%m-%d %H:%M:%S.%f')
                    if join_date >= yesterday:
                        daily_users += 1
                except:
                    pass
        total_collected_points = 0
        daily_collected_points = 0
        for user_subs in self.user_channel_subscriptions.values():
            for sub_info in user_subs.values():
                points = sub_info.get("points", 0)
                total_collected_points += points
                if sub_info.get("date"):
                    try:
                        sub_date = datetime.strptime(sub_info["date"], '%Y-%m-%d %H:%M:%S.%f')
                        if sub_date >= yesterday:
                            daily_collected_points += points
                    except:
                        pass
        for invite_list in self.invites.values():
            for invite_data in invite_list:
                if invite_data.get("date"):
                    try:
                        invite_date = datetime.strptime(invite_data["date"], '%Y-%m-%d %H:%M:%S.%f')
                        if invite_date >= yesterday:
                            daily_invites += 1
                    except:
                        pass
        total_current_points = sum(user.get("points", 0) for user in self.users.values())
        total_funded_channels = len(self.funded_channels)
        text = f"ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª:\n\n" \
               f"ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}\n" \
               f"ğŸ‘¤ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¬Ø¯Ø¯ Ø§Ù„ÙŠÙˆÙ…: {daily_users}\n\n" \
               f"ğŸ”— Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø¹ÙˆØ§Øª: {total_invites}\n" \
               f"ğŸ“² Ø¯Ø¹ÙˆØ§Øª Ø§Ù„ÙŠÙˆÙ…: {daily_invites}\n\n" \
               f"ğŸ’ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ù…Ø¬Ù…Ø¹Ø© (Ø¥Ø¬Ù…Ø§Ù„ÙŠ): {self.format_points(total_collected_points)}\n" \
               f"ğŸ’° Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ù…Ø¬Ù…Ø¹Ø© Ø§Ù„ÙŠÙˆÙ…: {self.format_points(daily_collected_points)}\n" \
               f"ğŸª Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {self.format_points(total_current_points)}\n\n" \
               f"ğŸ“º Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©: {len(self.mandatory_channels)}\n" \
               f"ğŸ’° Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø©: {len(self.paid_channels)}\n" \
               f"ğŸ¦ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ù…ÙˆÙ„Ø©: {total_funded_channels}\n" \
               f"ğŸš« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†: {len(self.banned_users)}\n\n" \
               f"ğŸ“… Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: {self.format_time_12h(datetime.now())}"

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")]])
        )
    async def handle_fund_channel_members_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, members_text):
        try:
            members = int(members_text)
            if members <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return

            if members < self.min_funding_members:
                await update.message.reply_text(f"âŒ Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ ÙŠÙ…ÙƒÙ† ØªÙ…ÙˆÙŠÙ„Ù‡ Ù‡Ùˆ {self.min_funding_members} Ø¹Ø¶Ùˆ!")
                return

            user_id = update.effective_user.id
            user = self.get_user(user_id)

            total_cost = float(members * self.member_price)

            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                    f"ğŸ’° ØªØ­ØªØ§Ø¬: {self.format_points(total_cost)} ğŸª\n"
                    f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª"
                )
                context.user_data['waiting_for'] = None
                return

            context.user_data['temp_fund_members'] = members
            context.user_data['temp_fund_cost'] = total_cost
            context.user_data['waiting_for'] = 'fund_channel_username'

            bot_info = await update.get_bot().get_me()
            bot_username = f"@{bot_info.username}" if bot_info.username else "Ø§Ù„Ø¨ÙˆØª"

            await update.message.reply_text(
                f"âœ…] Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡: {members}\n"
                f"ğŸ’| Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©: {self.format_points(total_cost)} ğŸª\n"
                f"âš ï¸] Ø§Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØª {bot_username} Ø£Ø¯Ù…Ù† ÙÙŠ Ù‚Ù†Ø§ØªÙƒ Ø£Ùˆ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ\n"
                f"ğŸ‘¤]â€¢ Ø«Ù… Ø£Ø±Ø³Ù„ ÙŠÙˆØ²Ø± Ø§Ù„Ù‚Ù†Ø§Ø© Ù…Ø¹ @"
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def handle_fund_channel_username_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, username_text):
        try:
            username = username_text.strip()

            if not username.startswith('@'):
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ ÙŠÙˆØ²Ø± Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ù€ @")
                return

            user_id = update.effective_user.id
            user = self.get_user(user_id)

            members = context.user_data.get('temp_fund_members')
            cost = context.user_data.get('temp_fund_cost')

            if not members or not cost:
                await update.message.reply_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
                context.user_data['waiting_for'] = None
                return

            try:
                chat = await context.bot.get_chat(username)
                channel_id = str(chat.id)
                channel_name = chat.title or username

                bot_member = await context.bot.get_chat_member(channel_id, context.bot.id)
                if bot_member.status not in ['administrator', 'creator']:
                    await update.message.reply_text(
                        f"âŒ Ø§Ù„Ø¨ÙˆØª Ù„ÙŠØ³ Ù…Ø´Ø±ÙØ§Ù‹ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©!\n\n"
                        f"âš ï¸ ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØª Ù…Ø´Ø±ÙØ§Ù‹ ÙÙŠ {username} Ø«Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰"
                    )
                    return

                user['points'] -= cost
                funding_type = "Ø¬Ø¯ÙŠØ¯"
                total_members = members
                is_cumulative = False
                existing_funding = self.funded_channels.get(channel_id)
                is_active_funding = existing_funding and existing_funding.get('status') != 'Ù…ÙƒØªÙ…Ù„'
                if channel_id in self.paid_channels and is_active_funding:
                    old_members_required = self.paid_channels[channel_id]["members_required"]
                    new_members_required = old_members_required + members
                    self.paid_channels[channel_id]["members_required"] = new_members_required
                    if channel_id in self.funded_channels:
                        self.funded_channels[channel_id]["members_funded"] += members
                        self.funded_channels[channel_id]["cost_paid"] += cost
                        self.funded_channels[channel_id]["last_funding_date"] = str(datetime.now())
                        self.funded_channels[channel_id]["status"] = "Ù†Ø´Ø·"

                    funding_type = "ØªØ±Ø§ÙƒÙ…ÙŠ"
                    total_members = new_members_required
                    is_cumulative = True
                else:
                    funding_type = "Ø¬Ø¯ÙŠØ¯"
                    self.paid_channels[channel_id] = {
                        "name": channel_name,
                        "invite_link": f"https://t.me/{username[1:]}",
                        "members_required": members,
                        "points": 12,
                        "funded_by": user_id,
                        "funded_date": str(datetime.now()),
                        "total_subscribers_count": 0
                    }
                    self.funded_channels[channel_id] = {
                        "owner_id": user_id,
                        "members_funded": members,
                        "cost_paid": cost,
                        "date": str(datetime.now()),
                        "channel_name": channel_name,
                        "status": "Ù†Ø´Ø·"
                    }
                    total_members = members
                    is_cumulative = False
                funding_number = self.generate_funding_number("channel", channel_id, None, is_cumulative)
                if "funded_channels" not in user:
                    user["funded_channels"] = []
                if channel_id not in user["funded_channels"]:
                    user["funded_channels"].append(channel_id)

                self.save_data_to_db('paid_channels', self.paid_channels)
                self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)
                context.user_data['waiting_for'] = None
                if 'temp_fund_members' in context.user_data:
                    del context.user_data['temp_fund_members']
                if 'temp_fund_cost' in context.user_data:
                    del context.user_data['temp_fund_cost']

                await update.message.reply_text(
                    f"âœ…] ØªÙ… Ø®ØµÙ… {self.format_points(cost)} ÙˆØ¨Ø¯Ø¡ ØªÙ…ÙˆÙŠÙ„ Ù‚Ù†Ø§ØªÙƒ Ø¨Ù€{members} Ø¹Ø¶Ùˆ Ø¨Ù†Ø¬Ø§Ø­!\n"
                    f"ğŸ“£] Ø§Ù„Ù‚Ù†Ø§Ø© : {channel_name}\n"
                    f"ğŸ†”] Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: #{funding_number}\n"
                    f"ğŸ¯| ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø­Ø§Ù„Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø¹Ø¨Ø± Ø²Ø± 'ØªÙ…ÙˆÙŠÙ„Ø§ØªÙŠ'"
                )
                try:
                    user_link = f"[{user_id}](tg://user?id={user_id})"
                    funding_status = "ğŸ’° Ø¹Ù…Ù„ÙŠØ© ØªÙ…ÙˆÙŠÙ„ Ø¬Ø¯ÙŠØ¯Ø©" if funding_type == "Ø¬Ø¯ÙŠØ¯" else "ğŸ”„ Ø¹Ù…Ù„ÙŠØ© ØªÙ…ÙˆÙŠÙ„ ØªØ±Ø§ÙƒÙ…ÙŠ"
                    funding_icon = "ğŸ†•" if funding_type == "Ø¬Ø¯ÙŠØ¯" else "ğŸ”„"
                    message_text = f"{funding_status} {funding_icon}:\n\n"
                    message_text += f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_link}\n"
                    message_text += f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: [{channel_name}](https://t.me/{username[1:]})\n"
                    message_text += f"ğŸ”„ Ù†ÙˆØ¹ Ø§Ù„ØªÙ…ÙˆÙŠÙ„: {funding_type}\n"
                    message_text += f"â• Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø¶Ø§ÙØ©: {members}\n"
                    message_text += f"ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {total_members}\n"
                    message_text += f"ğŸ’° Ø§Ù„ØªÙƒÙ„ÙØ© Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø©: {self.format_points(cost)} ğŸª\n"
                    if funding_type == "ØªØ±Ø§ÙƒÙ…ÙŠ":
                        total_cost_paid = self.funded_channels[channel_id]["cost_paid"]
                        message_text += f"ğŸ’ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø©: {self.format_points(total_cost_paid)} ğŸª\n"
                    message_text += f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}"
                    await context.bot.send_message(
                        ADMIN_ID,
                        message_text,
                        parse_mode='Markdown'
                    )
                except Exception as e:
                    logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")
            except Exception as e:
                await update.message.reply_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø©: {str(e)}")
                context.user_data['waiting_for'] = None
        except Exception as e:
            await update.message.reply_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")
            context.user_data['waiting_for'] = None

    async def handle_broadcast_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message_text):
        context.user_data['waiting_for'] = None

        total_users = len(self.users)
        successful = 0
        failed = 0

        progress_msg = await update.message.reply_text(
            f"ğŸ“¡ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù„Ù€ {total_users} Ù…Ø³ØªØ®Ø¯Ù…...\n"
            f"ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0/{total_users}"
        )

        for i, user_id in enumerate(self.users.keys()):
            try:
                await context.bot.send_message(
                    int(user_id),
                    f"ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙˆØª:\n\n{message_text}\n\n"
                    f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    f"ğŸ‘¨â€ğŸ’¼ Ø¥Ø¯Ø§Ø±Ø© Ø¨ÙˆØª ØªÙŠØ±Ø¨Ùˆ ÙÙˆÙ„Ùˆ"
                )
                successful += 1
            except Exception as e:
                failed += 1
                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}: {e}")

            if (i + 1) % 10 == 0 or (i + 1) == total_users:
                try:
                    await progress_msg.edit_text(
                        f"ğŸ“¡ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù„Ù€ {total_users} Ù…Ø³ØªØ®Ø¯Ù…...\n"
                        f"ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {i + 1}/{total_users}\n"
                        f"âœ… Ù†Ø¬Ø­: {successful}\n"
                        f"âŒ ÙØ´Ù„: {failed}"
                    )
                except:
                    pass

            await asyncio.sleep(0.1)

        final_message = (
            f"âœ… ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©!\n\n"
            f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬:\n"
            f"ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}\n"
            f"âœ… ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­: {successful}\n"
            f"âŒ ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: {failed}\n"
            f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: {self.format_time_12h(datetime.now())}"
        )

        await progress_msg.edit_text(final_message)

        await self.handle_unban_user(update, context, text)

        # If no specific handler found, show main menu
        await self.show_main_menu(update, context)

    async def handle_gift_code_usage(self, update: Update, context: ContextTypes.DEFAULT_TYPE, gift_code):
        user_id = update.effective_user.id
        result = self.use_gift_link(gift_code, user_id)

        if result["success"]:
            user_link = f"[{update.effective_user.first_name}](tg://user?id={user_id})"
            await update.message.reply_text(
                f"ğŸ‰ ØªÙ‡Ø§Ù†ÙŠÙ†Ø§ {user_link}! ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù‡Ø¯ÙŠØ© {self.format_points(result['points'])} ÙƒÙˆÙƒÙŠØ²!\n"
                f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(self.get_user(user_id)['points'])} ğŸª\n\n"
                f"â˜ºï¸ Ù†Ø´ÙƒØ±ÙƒÙ… Ø¹Ù„Ù‰ Ø«Ù‚ØªÙƒÙ… Ø§Ù„ÙƒØ¨ÙŠØ±Ø©ØŒ ÙˆÙ†Ø³Ø¹Ù‰ Ø¯ÙˆÙ…Ø§Ù‹ Ù„ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø£ÙØ¶Ù„ Ù„ÙƒÙ….",
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(f"âŒ {result['message']}")

        context.user_data['waiting_for'] = None
        await self.show_main_menu(update, context)

    async def show_use_gift_code_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.callback_query.edit_message_text(
            "ğŸ Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒÙˆØ¯ Ø§Ù„Ù‡Ø¯ÙŠØ©:\n\n"
            "Ø£Ø±Ø³Ù„ ÙƒÙˆØ¯ Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="back_to_main")]])
        )
        context.user_data['waiting_for'] = 'use_gift_code'

    async def handle_ban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            ban_user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(ban_user_id) in self.banned_users:
                await update.message.reply_text("âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ± Ø¨Ø§Ù„ÙØ¹Ù„!")
                return

            self.banned_users[str(ban_user_id)] = {
                "banned_date": str(datetime.now()),
                "banned_by": update.effective_user.id
            }
            self.save_data_to_db('banned_users', self.banned_users)

            await update.message.reply_text(f"âœ… ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {ban_user_id} Ø¨Ù†Ø¬Ø§Ø­!")

            try:
                await context.bot.send_message(
                    ban_user_id,
                    "ğŸš« ØªÙ… Ø­Ø¸Ø±Ùƒ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©\n"
                    "Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ¹ØªÙ‚Ø¯ Ø£Ù† Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¸Ø± Ø­Ø¯Ø« Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø®Ø·Ø£ØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©: @cxxov"
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø¢ÙŠØ¯ÙŠ ØµØ­ÙŠØ­!")

    async def handle_unban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            unban_user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(unban_user_id) not in self.banned_users:
                await update.message.reply_text("âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ±!")
                return

            del self.banned_users[str(unban_user_id)]
            self.save_data_to_db('banned_users', self.banned_users)

            await update.message.reply_text(f"âœ… ØªÙ… ÙÙƒ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {unban_user_id} Ø¨Ù†Ø¬Ø§Ø­!")

            try:
                await context.bot.send_message(
                    unban_user_id,
                    "âœ… ØªÙ… ÙÙƒ Ø­Ø¸Ø±Ùƒ Ù…Ù† Ø§Ù„Ø¨ÙˆØª!\n"
                    "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ."
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø¢ÙŠØ¯ÙŠ ØµØ­ÙŠØ­!")

    async def handle_user_info_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(user_id) not in self.users:
                await update.message.reply_text("âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…!")
                return

            user = self.get_user(user_id)

            funded_channels_count = len(user.get("funded_channels", []))
            successful_invites = user.get("referrals_count", 0)

            used_cookies = 0
            if str(user_id) in self.user_channel_subscriptions:
                for sub_info in self.user_channel_subscriptions[str(user_id)].values():
                    used_cookies += sub_info.get('points', 0)

            for channel_id in user.get("funded_channels", []):
                if channel_id in self.funded_channels:
                    used_cookies += self.funded_channels[channel_id].get('cost_paid', 0)

            try:
                user_chat = await context.bot.get_chat(user_id)
                user_name = user_chat.first_name or "ØºÙŠØ± Ù…ØªØ§Ø­"
                user_username = f"@{user_chat.username}" if user_chat.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
                user_is_bot = "Ù†Ø¹Ù…" if user_chat.type == 'bot' else "Ù„Ø§"
            except:
                user_name = "ØºÙŠØ± Ù…ØªØ§Ø­"
                user_username = "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
                user_is_bot = "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"

            ban_status = "Ù…Ø­Ø¸ÙˆØ± âŒ" if str(user_id) in self.banned_users else "ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ± âœ…"

            info_text = (
                f"ğŸ‘¤ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙƒØ§Ù…Ù„Ø©:\n\n"
                f"ğŸ†” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {user_id}\n"
                f"ğŸ“ Ø§Ù„Ø§Ø³Ù…: {user_name}\n"
                f"ğŸ“± Ø§Ù„ÙŠÙˆØ²Ø±Ù†ÙŠÙ…: {user_username}\n"
                f"ğŸ¤– Ø¨ÙˆØª: {user_is_bot}\n"
                f"ğŸš« Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¸Ø±: {ban_status}\n\n"
                f"ğŸ’° Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ø­Ø§Ù„ÙŠØ©: {self.format_points(user['points'])} ğŸª\n"
                f"ğŸ”¥ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©: {self.format_points(used_cookies)} ğŸª\n"
                f"ğŸ’ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØªØ³Ø¨Ø©: {self.format_points(user['points'] + used_cookies)} ğŸª\n\n"
                f"ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø´Ø§Ø·:\n"
                f"ğŸ”— Ø§Ù„Ø¯Ø¹ÙˆØ§Øª Ø§Ù„Ù†Ø§Ø¬Ø­Ø©: {successful_invites}\n"
                f"ğŸ’° Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ù…ÙˆÙ„Ø©: {funded_channels_count}\n\n"
                f"ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…: {user['joined_date'][:16] if user.get('joined_date') else 'ØºÙŠØ± Ù…ØªØ§Ø­'}\n"
                f"â° Ø¢Ø®Ø± Ù†Ø´Ø§Ø·: {user.get('last_activity', 'ØºÙŠØ± Ù…ØªØ§Ø­')[:16] if user.get('last_activity') else 'ØºÙŠØ± Ù…ØªØ§Ø­'}\n"
                f"ğŸ¯ Ø§Ø³ØªØ®Ø¯Ù… Ø¯Ø¹ÙˆØ©: {'Ù†Ø¹Ù…' if user.get('used_invite') else 'Ù„Ø§'}\n"
                f"âœ… Ø£ÙƒÙ…Ù„ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ: {'Ù†Ø¹Ù…' if user.get('completed_mandatory') else 'Ù„Ø§'}"
            )

            await update.message.reply_text(info_text)

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø¢ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)!")
        except Exception as e:
            await update.message.reply_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")

    async def handle_ban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(user_id) in self.banned_users:
                await update.message.reply_text("âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ± Ù…Ø³Ø¨Ù‚Ø§Ù‹!")
                return

            self.banned_users[str(user_id)] = {
                "banned_date": str(datetime.now()),
                "banned_by": update.effective_user.id
            }
            self.save_json(BANNED_USERS_FILE, self.banned_users)

            try:
                user_chat = await context.bot.get_chat(user_id)
                user_name = user_chat.first_name or "Ù…Ø³ØªØ®Ø¯Ù…"
            except:
                user_name = "Ù…Ø³ØªØ®Ø¯Ù…"

            await update.message.reply_text(
                f"âœ… ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_name}\n"
                f"ğŸ†” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {user_id}\n"
                f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ø­Ø¸Ø±: {self.format_time_12h(datetime.now())}"
            )

            try:
                await context.bot.send_message(
                    user_id,
                    "ğŸš« ØªÙ… Ø­Ø¸Ø±Ùƒ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©\n"
                    "Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ¹ØªÙ‚Ø¯ Ø£Ù† Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¸Ø± Ø­Ø¯Ø« Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø®Ø·Ø£ØŒ Ù„Ø§ ØªÙ‚Ù„Ù‚ØŒ Ø¨Ø¥Ù…ÙƒØ§Ù†Ùƒ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø£Ù…Ø± : [@cxxov]\n"
                    "Ù†Ø­Ù† Ù‡Ù†Ø§ Ù„Ø¯Ø¹Ù…Ùƒ ÙˆÙ†Ø³Ø¹Ù‰ Ù„ØªÙ‚Ø¯ÙŠÙ… Ø£ÙØ¶Ù„ ØªØ¬Ø±Ø¨Ø© Ù…Ù…ÙƒÙ†Ø©."
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø¢ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)!")

    async def handle_unban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(user_id) not in self.banned_users:
                await update.message.reply_text("âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ±!")
                return

            del self.banned_users[str(user_id)]
            self.save_json(BANNED_USERS_FILE, self.banned_users)

            try:
                user_chat = await context.bot.get_chat(user_id)
                user_name = user_chat.first_name or "Ù…Ø³ØªØ®Ø¯Ù…"
            except:
                user_name = "Ù…Ø³ØªØ®Ø¯Ù…"

            await update.message.reply_text(
                f"âœ… ØªÙ… ÙÙƒ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_name}\n"
                f"ğŸ†” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {user_id}\n"
                f"ğŸ“… ÙˆÙ‚Øª ÙÙƒ Ø§Ù„Ø­Ø¸Ø±: {self.format_time_12h(datetime.now())}"
            )

            try:
                await context.bot.send_message(
                    user_id,
                    "âœ… ØªÙ… ÙÙƒ Ø­Ø¸Ø±Ùƒ Ù…Ù† Ø§Ù„Ø¨ÙˆØª!\n\n"
                    "ğŸ‰ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¬Ù…ÙŠØ¹ Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø¨Ø­Ø±ÙŠØ©\n"
                    "Ù†ØªÙ…Ù†Ù‰ Ù„Ùƒ ØªØ¬Ø±Ø¨Ø© Ù…Ù…ØªØ¹Ø©! ğŸ™"
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø¢ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)!")
    async def transparent_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'transparent_button_text'
        await update.callback_query.edit_message_text(
            "âœ¨ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø²Ø± Ø§Ù„Ø´ÙØ§Ù:\n\n"
            "Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© (Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù„Ù„Ø£Ø¯Ù…Ù† Ù…Ø¹ Ø§Ù„Ø²Ø± Ø§Ù„Ø´ÙØ§Ù):",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )

    async def handle_transparent_button_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message_text):
        context.user_data['temp_transparent_text'] = message_text

        if update.message.photo:
            photo = update.message.photo[-1]
            context.user_data['temp_transparent_photo'] = photo.file_id
        else:
            context.user_data['temp_transparent_photo'] = None

        context.user_data['waiting_for'] = 'transparent_button_name'

        await update.message.reply_text(
            "âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø­ØªÙˆÙ‰!\n\n"
            "ğŸ·ï¸ Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ø²Ø± Ø§Ù„Ø´ÙØ§Ù:"
        )

    async def handle_transparent_button_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE, button_name):
        context.user_data['temp_transparent_button_name'] = button_name
        context.user_data['waiting_for'] = 'transparent_button_url'

        await update.message.reply_text(
            f"âœ… Ø§Ø³Ù… Ø§Ù„Ø²Ø±: {button_name}\n\n"
            f"ğŸ”— Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ø°ÙŠ Ø³ÙŠÙØªØ­ Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø±\n"
            f"Ø£Ùˆ Ø£Ø±Ø³Ù„ ÙƒÙ„Ù…Ø© 'Ø¨Ø¯ÙˆÙ†' Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ±ÙŠØ¯ Ø§Ù„Ø²Ø± Ø¨Ø¯ÙˆÙ† Ø±Ø§Ø¨Ø·:"
        )

    async def handle_transparent_button_url(self, update: Update, context: ContextTypes.DEFAULT_TYPE, url_text):
        try:
            text = context.user_data['temp_transparent_text']
            photo_id = context.user_data.get('temp_transparent_photo')
            button_name = context.user_data['temp_transparent_button_name']

            keyboard = []
            if url_text.lower() != "Ø¨Ø¯ÙˆÙ†":
                keyboard.append([InlineKeyboardButton(button_name, url=url_text)])
            else:
                keyboard.append([InlineKeyboardButton(button_name, callback_data="transparent_click")])

            reply_markup = InlineKeyboardMarkup(keyboard)

            if photo_id:
                await context.bot.send_photo(
                    ADMIN_ID,
                    photo=photo_id,
                    caption=text,
                    reply_markup=reply_markup
                )
            else:
                await context.bot.send_message(
                    ADMIN_ID,
                    text=text,
                    reply_markup=reply_markup
                )

            context.user_data['waiting_for'] = None
            del context.user_data['temp_transparent_text']
            del context.user_data['temp_transparent_button_name']
            if 'temp_transparent_photo' in context.user_data:
                del context.user_data['temp_transparent_photo']

            await update.message.reply_text(
                "âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø²Ø± Ø§Ù„Ø´ÙØ§Ù Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ·ï¸ Ø§Ø³Ù… Ø§Ù„Ø²Ø±: {button_name}\n"
                f"ğŸ”— Ø§Ù„Ø±Ø§Ø¨Ø·: {url_text if url_text.lower() != 'Ø¨Ø¯ÙˆÙ†' else 'Ø¨Ø¯ÙˆÙ† Ø±Ø§Ø¨Ø·'}\n"
                f"ğŸ“¸ ØµÙˆØ±Ø©: {'Ù†Ø¹Ù…' if photo_id else 'Ù„Ø§'}"
            )

        except Exception as e:
            await update.message.reply_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")
            context.user_data['waiting_for'] = None

    async def min_funding_members_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'min_funding_members_value'
        await update.callback_query.edit_message_text(
            f"ğŸ”¢ Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ ÙŠÙ…ÙƒÙ† ØªÙ…ÙˆÙŠÙ„Ù‡:\n\n"
            f"ğŸ“Š Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.min_funding_members} Ø¹Ø¶Ùˆ\n\n"
            f"Ø£Ø± ï¿½Ù„ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ ÙŠÙ…ÙƒÙ† ØªÙ…ÙˆÙŠÙ„Ù‡:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )





    async def handle_filter_days_threshold(self, update: Update, context: ContextTypes.DEFAULT_TYPE, days_text):
        await update.message.reply_text("âŒ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØµÙÙŠØ© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù…Ø¹Ø·Ù„ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.")

    async def handle_min_funding_members_value(self, update: Update, context: ContextTypes.DEFAULT_TYPE, members_text):
        try:
            members = int(members_text)
            if members < 1:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø¹Ø¯Ø¯ Ø£ÙƒØ¨Ø± Ù…Ù† 0!")
                return

            old_members = self.min_funding_members
            self.min_funding_members = members
            context.user_data['waiting_for'] = None

            await update.message.reply_text(
                f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ ÙŠÙ…ÙƒÙ† ØªÙ…ÙˆÙŠÙ„Ù‡ Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ“Š Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¨Ù‚: {old_members} Ø¹Ø¶Ùˆ\n"
                f"ğŸ”¢ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯: {members} Ø¹Ø¶Ùˆ\n\n"
                f"âš ï¸ Ø³ÙŠØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ù‡Ø°Ø§ Ø§Ù„ØªØºÙŠÙŠØ± Ø¹Ù„Ù‰ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙÙ‚Ø·"
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def handle_add_points_user_id(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())

            if str(user_id) not in self.users:
                await update.message.reply_text("âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…!")
                return

            context.user_data['add_points_user_id'] = user_id
            context.user_data['waiting_for'] = 'add_points_amount'

            user = self.get_user(user_id)
            await update.message.reply_text(
                f"âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\n"
                f"ğŸ’° Ø±ØµÙŠØ¯Ù‡ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n\n"
                f"ğŸ“ Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø±Ø§Ø¯ Ø¥Ø¶Ø§ÙØªÙ‡Ø§:"
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø¢ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)!")

    async def handle_add_points_amount(self, update: Update, context: ContextTypes.DEFAULT_TYPE, amount_text):
        try:
            amount = float(amount_text.strip())
            user_id = context.user_data.get('add_points_user_id')

            if amount <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ø¨Ù„Øº Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return

            user = self.get_user(user_id)
            old_points = user['points']
            user['points'] += amount



            context.user_data['waiting_for'] = None
            if 'add_points_user_id' in context.user_data:
                del context.user_data['add_points_user_id']

            await update.message.reply_text(
                f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\n"
                f"â• Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø¶Ø§ÙØ©: {self.format_points(amount)} ğŸª\n"
                f"ğŸ“Š Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚: {self.format_points(old_points)} ğŸª\n"
                f"ğŸ“Š Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯: {self.format_points(user['points'])} ğŸª"
            )

            try:
                await context.bot.send_message(
                    user_id,
                    f"ğŸ‰ ØªÙ… Ø¥Ø¶Ø§ÙØ© Ù†Ø‚Ø§Ø· Ø¥Ù„Ù‰ Ø­Ø³Ø§Ø¨Ùƒ!\n\n"
                    f"â• Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø¶Ø§ÙØ©: {self.format_points(amount)} ğŸª\n"
                    f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n\n"
                    f"Ù…Ù† Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙˆØª ğŸ‘¨â€ğŸ’¼"
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def handle_remove_points_user_id(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())

            if str(user_id) not in self.users:
                await update.message.reply_text("âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…!")
                return

            context.user_data['remove_points_user_id'] = user_id
            context.user_data['waiting_for'] = 'remove_points_amount'

            user = self.get_user(user_id)
            await update.message.reply_text(
                f"âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\n"
                f"ğŸ’° Ø±ØµÙŠØ¯Ù‡ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n\n"
                f"ğŸ“ Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø±Ø§Ø¯ Ø®ØµÙ…Ù‡Ø§:"
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø¢ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)!")

    async def handle_remove_points_amount(self, update: Update, context: ContextTypes.DEFAULT_TYPE, amount_text):
        try:
            amount = float(amount_text.strip())
            user_id = context.user_data.get('remove_points_user_id')

            if amount <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ø¨Ù„Øº Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return

            user = self.get_user(user_id)
            old_points = user['points']

            if user['points'] < amount:
                await update.message.reply_text(
                    f"âŒ Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                    f"ğŸ’° Ø±ØµÙŠØ¯Ù‡ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n"
                    f"ğŸ“ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø®ØµÙ…Ù‡: {self.format_points(amount)} ğŸª"
                )
                return

            user['points'] -= amount


            context.user_data['waiting_for'] = None
            if 'remove_points_user_id' in context.user_data:
                del context.user_data['remove_points_user_id']

            await update.message.reply_text(
                f"âœ… ØªÙ… Ø®ØµÙ… Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\n"
                f"â– Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø®ØµÙˆÙ…Ø©: {self.format_points(amount)} ğŸª\n"
                f"ğŸ“Š Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚: {self.format_points(old_points)} ğŸª\n"
                f"ğŸ“Š Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯: {self.format_points(user['points'])} ğŸª"
            )

            try:
                await context.bot.send_message(
                    user_id,
                    f"âš ï¸ ØªÙ… Ø®ØµÙ… Ù†Ù‚Ø§Ø· Ù…Ù† Ø­Ø³Ø§Ø¨Ùƒ!\n\n"
                    f"â– Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø®ØµÙˆÙ…Ø©: {self.format_points(amount)} ğŸª\n"
                    f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n\n"
                    f"Ù…Ù† Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙˆØª ğŸ‘¨â€ğŸ’¼"
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")
    async def subscription_price_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'subscription_price_value'
        await update.callback_query.edit_message_text(
            f"ğŸ’° Ø³Ø¹Ø± Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù‚Ù†ÙˆØ§Øª:\n\n"
            f"ğŸ“º Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ø¹Ø¶Ùˆ Ø§Ù„ÙˆØ§Ø­Ø¯ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©: {self.member_price} ÙƒÙˆÙƒÙŠØ²\n"
            f"ğŸ¤– Ø³Ø¹Ø± Ø§Ù„Ø¨ÙˆØªØ§Øª Ø«Ø§Ø¨Øª: {self.bot_member_price} ÙƒÙˆÙƒÙŠØ²\n\n"
            f"Ø£Ø±Ø³Ù„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø¹Ø¶Ùˆ Ø§Ù„ÙˆØ§Ø­Ø¯ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )

    async def handle_subscription_price(self, update: Update, context: ContextTypes.DEFAULT_TYPE, price_text):
        try:
            price = float(price_text)
            if price < 1:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø³Ø¹Ø± Ø£ÙƒØ¨Ø± Ù…Ù† 0!")
                return

            old_price = self.member_price
            self.member_price = price
            context.user_data['waiting_for'] = None

            await update.message.reply_text(
                f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ“Š Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚ Ù„Ù„Ù‚Ù†ÙˆØ§Øª: {self.format_points(old_price)} ÙƒÙˆÙƒÙŠØ²\n"
                f"ğŸ’° Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ù‚Ù†ÙˆØ§Øª: {self.format_points(price)} ÙƒÙˆÙƒÙŠØ²\n"
                f"ğŸ¤– Ø³Ø¹Ø± Ø§Ù„Ø¨ÙˆØªØ§Øª ÙŠØ¨Ù‚Ù‰ Ø«Ø§Ø¨Øª: {self.bot_member_price} ÙƒÙˆÙƒÙŠØ²\n\n"
                f"âš ï¸ Ø³ÙŠØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ù‡Ø°Ø§ Ø§Ù„ØªØºÙŠÙŠØ± Ø¹Ù„Ù‰ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙÙ‚Ø·"
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def handle_daily_gift(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        daily_gift_info = self.get_daily_gift_info(user_id)

        keyboard = self.create_daily_gift_keyboard(daily_gift_info)

        cycle_info = ""
        if daily_gift_info['completed_cycles'] > 0:
            cycle_info = f"\nğŸ† Ø§Ù„Ø¯ÙˆØ±Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©: {daily_gift_info['completed_cycles']}"

        if daily_gift_info['can_claim']:
            message_text = (
                "â€¢ Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Ù‚Ø³Ù… Ø¬Ù…Ø¹ Ø§Ù„Ù†Ù‚Ø§Ø· ÙŠÙˆÙ…ÙŠØ§Ù‹ ğŸ\n\n"
                f"ğŸ“… Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø­Ø§Ù„ÙŠ: {daily_gift_info['current_day']}/20{cycle_info}\n"
                f"ğŸ’ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù‡Ø¯Ø§ÙŠØ§ Ø§Ù„Ù…Ø³ØªÙ„Ù…Ø©: {daily_gift_info['total_claimed']}\n\n"
                "- Ù‚Ù… Ø¨ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆÙ„Ø§ ØªÙÙˆØª ÙŠÙˆÙ…Ø§Ù‹ ÙˆØ§Ø­Ø¯Ø§Ù‹ ğŸ“…\n"
                "- Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø© Ø¨Ù‡Ø§ ğŸ\n"
                "ğŸ”„ Ø¨Ø¹Ø¯ Ø¥ÙƒÙ…Ø§Ù„ 20 ÙŠÙˆÙ… Ù…ØªÙˆØ§ØµÙ„ØŒ Ø³ÙŠØ¹Ø§Ø¯ Ø§Ù„ØªØ³Ù„Ø³Ù„ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 1"
            )
        else:
            time_until_next = self.get_time_until_next_day_baghdad()
            message_text = (
                "â€¢ Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Ù‚Ø³Ù… Ø¬Ù…Ø¹ Ø§Ù„Ù†Ù‚Ø§Ø· ÙŠÙˆÙ…ÙŠØ§Ù‹ ğŸ\n\n"
                f"ğŸ“… Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø­Ø§Ù„ÙŠ: {daily_gift_info['current_day']}/20{cycle_info}\n"
                f"ğŸ’ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù‡Ø¯Ø§ÙŠØ§ Ø§Ù„Ù…Ø³ØªÙ„Ù…Ø©: {daily_gift_info['total_claimed']}\n\n"
                "- Ù‚Ù… Ø¨ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆÙ„Ø§ ØªÙÙˆØª ÙŠÙˆÙ…Ø§Ù‹ ÙˆØ§Ø­Ø¯Ø§Ù‹ ğŸ“…\n"
                f"- Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ø¨Ø¹Ø¯ {time_until_next} Ø­Ø³Ø¨ ( Ø¢Ø³ÙŠØ§ / Ø¨ØºØ¯Ø§Ø¯ ) ÙˆÙˆÙ‚Øª Ø§Ø³ØªÙ„Ø§Ù…Ù‡â³\n"
                "ğŸ”„ Ø¨Ø¹Ø¯ Ø¥ÙƒÙ…Ø§Ù„ 20 ÙŠÙˆÙ… Ù…ØªÙˆØ§ØµÙ„ØŒ Ø³ÙŠØ¹Ø§Ø¯ Ø§Ù„ØªØ³Ù„Ø³Ù„ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 1"
            )

        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")])

        await update.callback_query.edit_message_text(
            message_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    def get_daily_gift_info(self, user_id):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ Ø­Ù…Ø§ÙŠØ© Ù…Ø­Ø³Ù†Ø© ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ³Ù„Ø³Ù„"""
        try:
            from pytz import timezone
            baghdad_tz = timezone('Asia/Baghdad')
            now_baghdad = datetime.now(baghdad_tz)
            today_str = now_baghdad.strftime('%Y-%m-%d')

            user_id_str = str(user_id)

            if user_id_str not in self.daily_gifts:
                self.daily_gifts[user_id_str] = {
                    'current_day': 1,
                    'last_claim_date': None,
                    'claimed_today': False,
                    'reset_date': None,
                    'total_claimed': 0,  # Ø¹Ø¯Ø§Ø¯ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù‡Ø¯Ø§ÙŠØ§ Ø§Ù„Ù…Ø³ØªÙ„Ù…Ø©
                    'completed_cycles': 0,  # Ø¹Ø¯Ø¯ Ø§Ù„Ø¯ÙˆØ±Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© (20 ÙŠÙˆÙ…)
                    'cycle_start_date': today_str  # ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¯ÙˆØ±Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                }

            user_gift_data = self.daily_gifts[user_id_str]

            if not isinstance(user_gift_data.get('current_day'), int) or user_gift_data['current_day'] < 1:
                user_gift_data['current_day'] = 1

            if 'completed_cycles' not in user_gift_data:
                user_gift_data['completed_cycles'] = 0
            if 'cycle_start_date' not in user_gift_data:
                user_gift_data['cycle_start_date'] = today_str

            if user_gift_data['current_day'] > 20:
                user_gift_data['completed_cycles'] += 1
                user_gift_data['current_day'] = 1
                user_gift_data['claimed_today'] = False
                user_gift_data['reset_date'] = today_str
                user_gift_data['cycle_start_date'] = today_str
                user_gift_data['last_claim_date'] = None
                self.save_json(DAILY_GIFTS_FILE, self.daily_gifts)
                logger.info(f"User {user_id} completed daily gift cycle {user_gift_data['completed_cycles']}, auto-reset to day 1")

            if user_gift_data['last_claim_date']:
                try:
                    last_claim = datetime.strptime(user_gift_data['last_claim_date'], '%Y-%m-%d')
                    last_claim_baghdad = baghdad_tz.localize(last_claim) if last_claim.tzinfo is None else last_claim
                    days_diff = (now_baghdad.date() - last_claim_baghdad.date()).days

                    if days_diff > 1:  # Ø§Ù†Ù‚Ø·Ø¹ Ø§Ù„ØªØ³Ù„Ø³Ù„ - Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ù„Ù„ÙŠÙˆÙ… 1
                        user_gift_data['current_day'] = 1
                        user_gift_data['claimed_today'] = False
                        user_gift_data['reset_date'] = today_str
                        user_gift_data['cycle_start_date'] = today_str
                        user_gift_data['last_claim_date'] = None
                        self.save_json(DAILY_GIFTS_FILE, self.daily_gifts)
                        logger.info(f"Reset daily gifts for user {user_id} - missed {days_diff-1} days, restarting cycle")
                    elif days_diff == 1:  # ÙŠÙˆÙ… Ø¬Ø¯ÙŠØ¯ ØµØ­ÙŠØ­
                        user_gift_data['claimed_today'] = False
                    elif days_diff == 0:  # Ù†ÙØ³ Ø§Ù„ÙŠÙˆÙ…
                        pass
                except Exception as date_error:
                    logger.error(f"Error parsing last claim date for user {user_id}: {date_error}")
                    user_gift_data['current_day'] = 1
                    user_gift_data['claimed_today'] = False
                    user_gift_data['last_claim_date'] = None
                    user_gift_data['cycle_start_date'] = today_str

            can_claim = not user_gift_data.get('claimed_today', False) and user_gift_data['current_day'] <= 20

            return {
                'current_day': user_gift_data['current_day'],
                'can_claim': can_claim,
                'claimed_today': user_gift_data.get('claimed_today', False),
                'total_claimed': user_gift_data.get('total_claimed', 0),
                'completed_cycles': user_gift_data.get('completed_cycles', 0)
            }

        except Exception as e:
            logger.error(f"Error getting daily gift info for user {user_id}: {e}")
            return {
                'current_day': 1,
                'can_claim': True,
                'claimed_today': False,
                'total_claimed': 0,
                'completed_cycles': 0
            }

    def create_daily_gift_keyboard(self, daily_gift_info):
        """Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ù…Ø¹ Ø§Ù„Ø­Ù…Ø§ÙŠØ© ÙˆØ§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø©"""
        daily_rewards = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]
        keyboard = []

        for row in range(5):
            row_buttons = []
            for col in range(4):
                day_index = row * 4 + col
                if day_index < len(daily_rewards):
                    day_number = day_index + 1
                    reward = daily_rewards[day_index]

                    if day_number < daily_gift_info['current_day']:
                        button_text = f"âœ… {reward}"
                        callback_data = f"daily_gift_claimed_{day_number}"
                    elif day_number == daily_gift_info['current_day']:
                        if daily_gift_info['can_claim']:
                            button_text = f"ğŸ {reward}"
                            callback_data = f"claim_daily_gift_{day_number}_{reward}"
                        else:
                            button_text = f"âœ… {reward}"
                            callback_data = f"daily_gift_claimed_today_{day_number}"
                    else:
                        button_text = f"ğŸ”’ {reward}"
                        callback_data = f"daily_gift_future_{day_number}"

                    row_buttons.append(InlineKeyboardButton(button_text, callback_data=callback_data))

            if row_buttons:
                keyboard.append(row_buttons)

        return keyboard

    def get_time_until_next_day_baghdad(self):
        """Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø­ØªÙ‰ Ø§Ù„ÙŠÙˆÙ… Ø§Ù„ØªØ§Ù„ÙŠ Ø¨ØªÙˆÙ‚ÙŠØª Ø¨ØºØ¯Ø§Ø¯"""
        from pytz import timezone
        baghdad_tz = timezone('Asia/Baghdad')
        now_baghdad = datetime.now(baghdad_tz)

        next_day = (now_baghdad + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
        time_diff = next_day - now_baghdad

        hours = time_diff.seconds // 3600
        minutes = (time_diff.seconds % 3600) // 60
        seconds = time_diff.seconds % 60

        return f"({hours} Ø³Ø§Ø¹Ø© Ùˆ {minutes} Ø¯Ù‚ÙŠÙ‚Ø© Ùˆ {seconds} Ø«Ø§Ù†ÙŠØ©)"

    async def claim_daily_gift_new(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        """Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ù…Ø¹ Ø­Ù…Ø§ÙŠØ© Ø´Ø§Ù…Ù„Ø© Ø¶Ø¯ Ø§Ù„Ø¹Ø¨Ø« ÙˆÙ†Ø¸Ø§Ù… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ³Ù„Ø³Ù„"""
        try:
            parts = data.split('_')
            if len(parts) != 5:
                return

            day_number = int(parts[3])
            reward = int(parts[4])

            daily_rewards = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]
            if day_number < 1 or day_number > 20 or reward != daily_rewards[day_number - 1]:
                logger.warning(f"Invalid daily gift data from user {update.effective_user.id}: day={day_number}, reward={reward}")
                return

            user_id = update.effective_user.id
            user = self.get_user(user_id)
            user_id_str = str(user_id)

            from pytz import timezone
            baghdad_tz = timezone('Asia/Baghdad')
            now_baghdad = datetime.now(baghdad_tz)
            today_str = now_baghdad.strftime('%Y-%m-%d')

            daily_gift_info = self.get_daily_gift_info(user_id)

            if not daily_gift_info['can_claim']:
                return

            if daily_gift_info['current_day'] != day_number:
                return

            if self.daily_gifts[user_id_str].get('claimed_today', False):
                return

            old_points = user['points']
            user['points'] += reward

            self.daily_gifts[user_id_str]['last_claim_date'] = today_str
            self.daily_gifts[user_id_str]['claimed_today'] = True
            self.daily_gifts[user_id_str]['total_claimed'] = self.daily_gifts[user_id_str].get('total_claimed', 0) + 1

            is_cycle_complete = False
            if day_number == 20:
                self.daily_gifts[user_id_str]['current_day'] = 1
                self.daily_gifts[user_id_str]['completed_cycles'] = self.daily_gifts[user_id_str].get('completed_cycles', 0) + 1
                self.daily_gifts[user_id_str]['claimed_today'] = True  # Ù…Ù†Ø¹ Ø§Ø³ØªÙ„Ø§Ù… Ø£Ø®Ø±Ù‰ Ø§Ù„ÙŠÙˆÙ…
                self.daily_gifts[user_id_str]['cycle_start_date'] = today_str
                is_cycle_complete = True

                pass

                logger.info(f"User {user_id} completed daily gift cycle {self.daily_gifts[user_id_str]['completed_cycles']} - auto reset to day 1")
            else:
                pass


            self.save_json(DAILY_GIFTS_FILE, self.daily_gifts)

            await self.handle_daily_gift(update, context)

            try:
                user_link = f"[{user_id}](tg://user?id={user_id})"

                if is_cycle_complete:
                    cycle_number = self.daily_gifts[user_id_str]['completed_cycles']
                    next_day_info = f"ğŸ”„ Ø£ÙƒÙ…Ù„ Ø§Ù„Ø¯ÙˆØ±Ø© #{cycle_number} - Ø³ÙŠØ¨Ø¯Ø£ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 1 ØºØ¯Ø§Ù‹"
                else:
                    next_day_info = f"Ø§Ù„ÙŠÙˆÙ… Ø§Ù„ØªØ§Ù„ÙŠ: {day_number + 1}"

                await context.bot.send_message(
                    ADMIN_ID,
                    f"ğŸ Ù‡Ø¯ÙŠØ© ÙŠÙˆÙ…ÙŠØ© Ù…Ø³ØªÙ„Ù…Ø©:\n\n"
                    f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_link}\n"
                    f"ğŸ“… Ø§Ù„ÙŠÙˆÙ…: {day_number}/20\n"
                    f"ğŸ’° Ø§Ù„Ù‡Ø¯ÙŠØ©: {reward} ğŸª\n"
                    f"ğŸ“Š Ø§Ù„Ù†Ù‚Ø§Ø·: {old_points} â†’ {user['points']}\n"
                    f"ğŸ“ˆ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù‡Ø¯Ø§ÙŠØ§: {self.daily_gifts[user_id_str]['total_claimed']}\n"
                    f"ğŸ”„ {next_day_info}\n"
                    f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}",
                    parse_mode='Markdown'
                )
            except Exception as e:
                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©: {e}")

        except ValueError as ve:
            logger.error(f"ValueError in daily gift claim from user {update.effective_user.id}: {ve}")
        except Exception as e:
            logger.error(f"Error in daily gift claim from user {update.effective_user.id}: {e}")

    async def daily_gift_amount_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'daily_gift_amount_value'
        await update.callback_query.edit_message_text(
            f"ğŸ Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©:\n\n"
            f"ğŸ“Š Ø§Ù„Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.daily_gift_amount} ÙƒÙˆÙƒÙŠØ²\n\n"
            f"Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )

    async def handle_daily_gift_amount_value(self, update: Update, context: ContextTypes.DEFAULT_TYPE, amount_text):
        try:
            amount = float(amount_text)
            if amount < 1:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ù‚Ø¯Ø§Ø± Ø£ÙƒØ¨Ø± Ù…Ù† 0!")
                return

            old_amount = self.daily_gift_amount
            self.daily_gift_amount = amount
            context.user_data['waiting_for'] = None

            await update.message.reply_text(
                f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ù‡Ø¯ÙŠØ© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ“Š Ø§Ù„Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚: {self.format_points(old_amount)} ÙƒÙˆÙƒÙŠØ²\n"
                f"ğŸ Ø§Ù„Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯: {self.format_points(amount)} ÙƒÙˆÙƒÙŠØ²\n\n"
                f"âš ï¸ Ø³ÙŠØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ù‡Ø°Ø§ Ø§Ù„ØªØºÙŠÙŠØ± Ø¹Ù„Ù‰ Ø§Ù„Ù‡Ø¯Ø§ÙŠØ§ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙÙ‚Ø·"
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def show_use_gift_code_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        mandatory_result = await self.check_mandatory_subscriptions(update, context)
        if not mandatory_result["all_subscribed"]:
            return

        context.user_data['waiting_for'] = 'gift_code_input'
        await update.callback_query.edit_message_text(
            "ğŸ« Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒÙˆØ¯ Ø§Ù„Ù‡Ø¯ÙŠØ©\n\n"
            "ğŸ“ Ø£Ø±Ø³Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="back_to_main")]])
        )

    async def handle_gift_code_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, code_text):
        code = code_text.strip()
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        if code not in self.gift_codes:
            await update.message.reply_text("âŒ Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± ØµØ­ÙŠØ­ Ø£Ùˆ Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©!")
            context.user_data['waiting_for'] = None
            return

        gift_code_data = self.gift_codes[code]

        if not gift_code_data.get("active", True):
            await update.message.reply_text("âŒ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù„Ù… ÙŠØ¹Ø¯ Ù†Ø´Ø·Ø§Ù‹!")
            context.user_data['waiting_for'] = None
            return

        if str(user_id) in gift_code_data.get("used_users", []):
            await update.message.reply_text("âŒ Ù„Ù‚Ø¯ Ø§Ø³ØªØ®Ø¯Ù…Øª Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…Ù† Ù‚Ø¨Ù„!")
            context.user_data['waiting_for'] = None
            return

        max_users = gift_code_data.get("max_users", 0)
        used_count = len(gift_code_data.get("used_users", []))

        if used_count >= max_users:
            await update.message.reply_text("âŒ ØªÙ… Ø§Ø³ØªÙ†ÙØ§Ø¯ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯!")
            context.user_data['waiting_for'] = None
            return

        if "used_users" not in self.gift_codes[code]:
            self.gift_codes[code]["used_users"] = []

        self.gift_codes[code]["used_users"].append(str(user_id))

        cookies_amount = gift_code_data.get("cookies", 0)
        user["points"] += cookies_amount

        self.save_json(GIFT_CODES_FILE, self.gift_codes)


        context.user_data['waiting_for'] = None

        remaining_users = max_users - len(self.gift_codes[code]["used_users"])

        await update.message.reply_text(
            f"ğŸ‰ ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒÙˆØ¯ Ø¨Ù†Ø¬Ø§Ø­!\n\n"
            f"ğŸ Ø­ØµÙ„Øª Ø¹Ù„Ù‰: {self.format_points(cookies_amount)} ğŸª\n"
            f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n"
            f"ğŸ‘¥ Ù…ØªØ¨Ù‚ÙŠ Ù„Ù„ÙƒÙˆØ¯: {remaining_users} Ù…Ø³ØªØ®Ø¯Ù…\n\n"
            f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª! ğŸ’«"
        )

        try:
            user_link = f"[{user_id}](tg://user?id={user_id})"
            safe_first_name = self.escape_markdown(update.effective_user.first_name)
            safe_username = ""
            if update.effective_user.username:
                safe_username = self.escape_markdown(f"@{update.effective_user.username}")
            else:
                safe_username = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙŠÙˆØ²Ø±Ù†ÙŠÙ…"

            await context.bot.send_message(
                ADMIN_ID,
                f"ğŸ« ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒÙˆØ¯ Ù‡Ø¯ÙŠØ©\\!\n\n"
                f"ğŸ‘¤ Ø§Ù„Ø§Ø³Ù…: {safe_first_name}\n"
                f"ğŸ“ Ø§Ù„ÙŠÙˆØ²Ø±: {safe_username}\n"
                f"ğŸ†” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {user_link}\n"
                f"ğŸ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„Ù…Ø­ØµÙ„Ø©: {self.format_points(cookies_amount)}\n"
                f"ğŸ« Ø§Ù„ÙƒÙˆØ¯: {code}\n"
                f"ğŸ‘¥ Ù…ØªØ¨Ù‚ÙŠ Ù„Ù„ÙƒÙˆØ¯: {remaining_users} Ù…Ø³ØªØ®Ø¯Ù…\n"
                f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}",
                parse_mode='MarkdownV2'
            )
        except Exception as e:
            logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒÙˆØ¯: {e}")

    async def create_gift_code_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'gift_code_users'
        await update.callback_query.edit_message_text(
            "ğŸ« Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ù‡Ø¯ÙŠØ© Ø¬Ø¯ÙŠØ¯\n\n"
            "ğŸ‘¥ Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_panel")]])
        )

    async def handle_gift_code_users(self, update: Update, context: ContextTypes.DEFAULT_TYPE, users_text):
        try:
            max_users = int(users_text.strip())
            if max_users <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return

            context.user_data['gift_code_max_users'] = max_users
            context.user_data['waiting_for'] = 'gift_code_cookies'

            await update.message.reply_text(
                f"âœ… ØªÙ… Ø­ÙØ¸ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {max_users}\n\n"
                f"ğŸª Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø§Ù„ØªÙŠ Ø³ÙŠØ­ØµÙ„ Ø¹Ù„ÙŠÙ‡Ø§ ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…:"
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def handle_gift_code_cookies(self, update: Update, context: ContextTypes.DEFAULT_TYPE, cookies_text):
        try:
            cookies_amount = float(cookies_text.strip())
            if cookies_amount <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return

            context.user_data['gift_code_cookies'] = cookies_amount
            context.user_data['waiting_for'] = 'gift_code_text'

            await update.message.reply_text(
                f"âœ… ØªÙ… Ø­ÙØ¸ Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙˆÙƒÙŠØ²: {self.format_points(cookies_amount)} ğŸª\n\n"
                f"ğŸ“ Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ù†Øµ Ø§Ù„ÙƒÙˆØ¯ (Ø£Ø­Ø±Ù ÙˆØ£Ø±Ù‚Ø§Ù…):"
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def handle_gift_code_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE, code_text):
        code = code_text.strip()

        if not code.replace(' ', '').isalnum():
            await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø¹Ù„Ù‰ Ø£Ø­Ø±Ù ÙˆØ£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·!")
            return

        if code in self.gift_codes:
            await update.message.reply_text("âŒ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹! ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙƒÙˆØ¯ Ø¢Ø®Ø±.")
            return

        max_users = context.user_data.get('gift_code_max_users')
        cookies_amount = context.user_data.get('gift_code_cookies')

        if not max_users or not cookies_amount:
            await update.message.reply_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
            context.user_data['waiting_for'] = None
            return

        self.gift_codes[code] = {
            "max_users": max_users,
            "cookies": cookies_amount,
            "used_users": [],
            "created_date": str(datetime.now()),
            "created_by": update.effective_user.id,
            "active": True
        }

        self.save_json(GIFT_CODES_FILE, self.gift_codes)

        context.user_data['waiting_for'] = None
        for key in ['gift_code_max_users', 'gift_code_cookies']:
            if key in context.user_data:
                del context.user_data[key]

        total_cookies = max_users * cookies_amount

        await update.message.reply_text(
            f"âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø§Ù„Ù‡Ø¯ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!\n\n"
            f"ğŸ« Ø§Ù„ÙƒÙˆØ¯: `{code}`\n"
            f"ğŸ‘¥ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø³Ù…ÙˆØ­: {max_users}\n"
            f"ğŸª ÙƒÙˆÙƒÙŠØ² Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…: {self.format_points(cookies_amount)}\n"
            f"ğŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙˆÙƒÙŠØ²: {self.format_points(total_cookies)}\n"
            f"ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡: {self.format_time_12h(datetime.now())}\n\n"
            f"ÙŠÙ…ÙƒÙ† Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…Ù† Ø®Ù„Ø§Ù„ Ø²Ø± 'Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒÙˆØ¯' ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.",
            parse_mode='Markdown'
        )

    async def show_accounts_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        from apis import get_accounts, get_working_accounts

        all_accounts = get_accounts()
        working_accounts = get_working_accounts()

        total_accounts = len(all_accounts)
        active_accounts = len(working_accounts)
        inactive_accounts = total_accounts - active_accounts

        first_account_date = "ØºÙŠØ± Ù…ØªØ§Ø­"
        last_account_date = "ØºÙŠØ± Ù…ØªØ§Ø­"

        if all_accounts:
            accounts_with_dates = []
            for account in all_accounts:
                if account.get('added_date'):
                    try:
                        date_obj = datetime.strptime(account['added_date'], '%Y-%m-%d %H:%M:%S.%f')
                        accounts_with_dates.append((account, date_obj))
                    except:
                        try:
                            date_obj = datetime.strptime(account['added_date'], '%Y-%m-%d %H:%M:%S')
                            accounts_with_dates.append((account, date_obj))
                        except:
                            pass

            if accounts_with_dates:
                accounts_with_dates.sort(key=lambda x: x[1])
                first_account_date= accounts_with_dates[0][1].strftime('%Y-%m-%d')
                last_account_date = accounts_with_dates[-1][1].strftime('%Y-%m-%d')

        active_phones_preview = []
        for account in working_accounts[:5]:
            phone = account.get('phone', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            if len(phone) > 5:
                masked_phone = "****" + phone[-4:]
            else:
                masked_phone = phone
            active_phones_preview.append(masked_phone)

        text = f"ğŸ‘¥ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø¶Ø§ÙØ©:\n\n"
        text += f"ğŸ“Š Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª: {total_accounts}\n"
        text += f"âœ… Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©: {active_accounts}\n"
        text += f"âŒ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·Ø©: {inactive_accounts}\n"
        text += f"ğŸ“ˆ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø´Ø§Ø·: {int((active_accounts/total_accounts)*100) if total_accounts > 0 else 0}%\n\n"

        text += f"ğŸ“… Ø£ÙˆÙ„ Ø­Ø³Ø§Ø¨ Ù…ÙØ¶Ø§Ù: {first_account_date}\n"
        text += f"ğŸ“… Ø¢Ø®Ø± Ø­Ø³Ø§Ø¨ Ù…ÙØ¶Ø§Ù: {last_account_date}\n\n"

        if active_phones_preview:
            text += f"ğŸ“± Ø¹ÙŠÙ†Ø© Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©:\n"
            for i, phone in enumerate(active_phones_preview, 1):
                text += f"   {i}. {phone}\n"

            if active_accounts > 5:
                text += f"... Ùˆ {active_accounts - 5} Ø­Ø³Ø§Ø¨ Ø¢Ø®Ø±\n"

        text += f"\nğŸ”„ ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«: {self.format_time_12h(datetime.now())}"

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")]])
        )

    async def show_admin_settings_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [InlineKeyboardButton("ğŸšª Ù…ØºØ§Ø¯Ø±Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª", callback_data="leave_all_chats")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")]
        ]

        await update.callback_query.edit_message_text(
            "âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯dï¿½Øª Ø§Ù„Ø¨ÙˆØª:\n\n"
            "Ø§Ø®ØªØ± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def leave_all_chats_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [
                InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="admin_settings"),
                InlineKeyboardButton("âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…ØºØ§Ø¯Ø±Ø©", callback_data="confirm_leave_all_chats")
            ]
        ]

        accounts = get_working_accounts()
        accounts_count = len(accounts)

        await update.callback_query.edit_message_text(
            f"ğŸšª Ù…ØºØ§Ø¯Ø±Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª\n\n"
            f"âš ï¸ ØªØ­Ø°ÙŠØ±: Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø³ÙŠÙ‚ÙˆÙ… Ø¨Ù…ØºØ§Ø¯Ø±Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª\n"
            f"Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø¶Ø§ÙØ© ÙÙŠ Ø§Ù„Ø¨ÙˆØª\n\n"
            f"ğŸ“Š Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª: {accounts_count}\n\n"
            f"â— Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡!",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_fund_bots_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        user_id = update.effective_user.id
        user = self.get_user(user_id)

        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="funding_section")]]

        max_affordable_members = int(user['points'] // self.bot_member_price)

        await update.callback_query.edit_message_text(
            text=f"*ØªÙ…ÙˆÙŠÙ„ Ø§Ø¹Ø¶Ø§Ø¡ Ø­Ù‚ÙŠÙ‚ÙŠØ© 100% ğŸ“£\n\n*"
                 f"> â€¢ ÙƒÙ„ 1 Ø¹Ø¶Ùˆ ğŸ‘¤ \\= 30 ÙƒÙˆÙƒÙŠØ²\n\n"
                 f"> ğŸª« Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ Ù„Ù„ØªÙ…ÙˆÙŠÙ„: {self.min_funding_members} Ø¹Ø¶Ùˆ\n\n"
                 f"> ğŸ–ï¸ ÙŠÙ…ÙƒÙ†Ùƒ ØªÙ…ÙˆÙŠÙ„: {max_affordable_members} Ø¹Ø¶Ùˆ\n\n"
                 f"*Ø§Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ø¯ ØªÙ…ÙˆÙŠÙ„Ù‡Ø§ Ù„Ù„Ø¨ÙˆØª ğŸ“¬*\n",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='MarkdownV2'
        )
        context.user_data['waiting_for'] = 'fund_bot_members'

    async def handle_fund_bot_members_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, members_text):
        try:
            members = int(members_text)
            if members <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return

            if members < self.min_funding_members:
                await update.message.reply_text(f"âŒ Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ ÙŠÙ…ÙƒÙ† ØªÙ…ÙˆÙŠÙ„Ù‡ Ù‡Ùˆ {self.min_funding_members} Ø¹Ø¶Ùˆ!")
                return
            user_id = update.effective_user.id
            user = self.get_user(user_id)

            total_cost = float(members * self.bot_member_price)
            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                    f"ğŸ’° ØªØ­ØªØ§Ø¬: {self.format_points(total_cost)} ğŸª\n"
                    f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª"
                )
                context.user_data['waiting_for'] = None
                return
            context.user_data['temp_fund_bot_members'] = members
            context.user_data['temp_fund_bot_cost'] = total_cost
            context.user_data['waiting_for'] = 'fund_bot_forward'
            await update.message.reply_text(
                f"âœ…\] Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡: {members}\n"
                f"ğŸ’°\] Ø§Ù„Ø³Ø¹Ø±: {self.format_points(total_cost)} ÙƒÙˆÙƒÙŠØ²\n\n"
                f"âš ï¸\] Ø¹Ù„ÙŠÙƒ ÙˆØ¶Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø±Ù…Ø² \\(  `Â¥`  \\) Ø¯Ø§Ø®Ù„ Ø§Ø³Ù… Ø¨ÙˆØªÙƒ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù† Ø§Ù„Ø¨ÙˆØª Ø®Ø§Øµ Ø¨Ùƒ \\(ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø²Ø§Ù„ØªÙ‡ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚\\)\n\n"
                f"*\\- ÙˆÙ…Ù† Ø«Ù… Ù‚Ù… Ø¨ØªØ­ÙˆÙŠÙ„ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø¨ÙˆØªÙƒ Ø¥Ù„Ù‰ Ù‡Ù†Ø§*",
                parse_mode='MarkdownV2'
            )
        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")
    async def handle_fund_bot_forward_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        if not hasattr(message, 'forward_origin') or not message.forward_origin:
            await update.message.reply_text("âŒ ÙŠØ¬Ø¨ ØªØ­ÙˆÙŠÙ„ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª ÙˆÙ„ÙŠØ³ ÙƒØªØ§Ø¨Ø© Ø±Ø³Ø§Ù„Ø©!")
            return
        from telegram import MessageOriginUser
        if not isinstance(message.forward_origin, MessageOriginUser):
            await update.message.reply_text("âŒ ÙŠØ¬Ø¨ ØªØ­ÙˆÙŠÙ„ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø¨ÙˆØª!")
            return
        forward_user = message.forward_origin.sender_user
        if not forward_user.is_bot:
            await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø­ÙˆÙ„Ø© Ù…Ù† Ø¨ÙˆØª!")
            return
        bot_id = forward_user.id
        bot_id_str = str(bot_id)
        bot_username = forward_user.username

        members = context.user_data.get('temp_fund_bot_members')
        cost = context.user_data.get('temp_fund_bot_cost')

        if not members or not cost:
            await update.message.reply_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
            context.user_data['waiting_for'] = None
            return
        try:
            bot_chat = await context.bot.get_chat(bot_id)
            bot_name = bot_chat.first_name or ""
            bot_description = getattr(bot_chat, 'description', "") or ""
            bot_bio = getattr(bot_chat, 'bio', "") or ""
            symbol_found = False
            if "Â¥" in bot_name or "Â¥" in bot_description or "Â¥" in bot_bio:
                symbol_found = True
            if not symbol_found:
                await update.message.reply_text(
                    f"âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ù…Ø·Ù„ÙˆØ¨\\!\n\n"
                    f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: {bot_name or 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}\n"
                    f"âš ï¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±Ù…Ø² Ø¨Ø¬Ø§Ù†Ø¨ Ø§Ø³Ù… Ø§Ù„Ø¨ÙˆØª\n\n"
                    f"*\\- Ù‡ÙƒØ°Ø§* : `{bot_name} Â¥`\n\n"
                    f"ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø²Ø§Ù„Ø© Ø§Ù„Ø±Ù…Ø² Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙˆØªÙƒ",
                    parse_mode='MarkdownV2'
                )
                return
            user['points'] -= cost
            funding_type = "Ø¬Ø¯ÙŠØ¯"
            total_members = members
            is_cumulative = False

            if bot_id_str in self.paid_bots:
                old_members_required = self.paid_bots[bot_id_str]["members_required"]
                new_members_required = old_members_required + members
                self.paid_bots[bot_id_str]["members_required"] = new_members_required

                if bot_id_str in self.funded_bots:
                    self.funded_bots[bot_id_str]["members_funded"] += members
                    self.funded_bots[bot_id_str]["cost_paid"] += cost
                    self.funded_bots[bot_id_str]["last_funding_date"] = str(datetime.now())

                funding_type = "ØªØ±Ø§ÙƒÙ…ÙŠ"
                total_members = new_members_required
                is_cumulative = True
            else:
                self.paid_bots[bot_id_str] = {
                    "name": bot_name,
                    "username": bot_username,
                    "members_required": members,
                    "points": 30,
                    "funded_by": user_id,
                    "funded_date": str(datetime.now()),
                    "total_subscribers_count": 0,
                    "bot_name_with_symbol": bot_name
                }
                self.funded_bots[bot_id_str] = {
                    "owner_id": user_id,
                    "members_funded": members,
                    "cost_paid": cost,
                    "date": str(datetime.now()),
                    "bot_name": bot_name
                }
            funding_number = self.generate_funding_number("bot", None, bot_id_str, is_cumulative)
            if "funded_bots" not in user:
                user["funded_bots"] = []
            if bot_id_str not in user["funded_bots"]:
                user["funded_bots"].append(bot_id_str)


            self.save_json(PAID_BOTS_FILE, self.paid_bots)
            self.save_json(FUNDED_BOTS_FILE, self.funded_bots)

            context.user_data['waiting_for'] = None
            if 'temp_fund_bot_members' in context.user_data:
                del context.user_data['temp_fund_bot_members']
            if 'temp_fund_bot_cost' in context.user_data:
                del context.user_data['temp_fund_bot_cost']
            await update.message.reply_text(
                f"âœ…\] ØªÙ… Ø®ØµÙ… {self.format_points(cost)} ÙˆØ¨Ø¯Ø¡ ØªÙ…ÙˆÙŠÙ„ Ø¨ÙˆØªÙƒ Ø¨Ù€ {members} Ø¹Ø¶Ùˆ \!\n"
                f"ğŸ¤–\] Ø§Ù„Ø¨ÙˆØª: {bot_name}\n"
                f"ğŸ†”\] Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: \#{funding_number}\n\n"
    f"\>ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø±Ù…Ø² Ù…Ù† Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¢Ù†\n",
                parse_mode="MarkdownV2"
            )
            try:
                user_link = f"[{user_id}](tg://user?id={user_id})"
                funding_status = "ğŸ†• ØªÙ…ÙˆÙŠÙ„ Ø¨ÙˆØª Ø¬Ø¯ÙŠØ¯" if funding_type == "Ø¬Ø¯ÙŠØ¯" else "ğŸ”„ ØªÙ…ÙˆÙŠÙ„ Ø¨ÙˆØª ØªØ±Ø§ÙƒÙ…ÙŠ"
                funding_icon = "ğŸ†•" if funding_type == "Ø¬Ø¯ÙŠØ¯" else "ğŸ”„"
                message_text = f"{funding_status} {funding_icon}:\n\n"
                message_text += f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_link}\n"
                message_text += f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: {bot_name}\n"
                message_text += f"ğŸ”„ Ù†ÙˆØ¹ Ø§Ù„ØªÙ…ÙˆÙŠÙ„: {funding_type}\n"
                message_text += f"â• Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø¶Ø§ÙØ©: {members}\n"
                message_text += f"ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {total_members}\n"
                message_text += f"ğŸ’° Ø§Ù„ØªÙƒÙ„ÙØ© Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø©: {self.format_points(cost)} ğŸª\n"
                if funding_type == "ØªØ±Ø§ÙƒÙ…ÙŠ":
                    total_cost_paid = self.funded_bots[bot_id_str]["cost_paid"]
                    message_text += f"ğŸ’ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø©: {self.format_points(total_cost_paid)} ğŸª\n"

                message_text += f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}"
                await context.bot.send_message(
                    ADMIN_ID,
                    message_text,
                    parse_mode='Markdown'
                )
            except Exception as e:
                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ù¥Ø´Ø¹Ø§Ø± ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")
        except Exception as e:
            await update.message.reply_text(
                f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙˆØª!\n\n"
                f"ğŸ” ØªØ£ÙƒØ¯ Ù…Ù†:\n"
                f"â€¢ ÙˆØ¶Ø¹ Ø§Ù„Ø±Ù…Ø² Â¥ ÙÙŠ Ø§Ø³Ù… Ø§Ù„Ø¨ÙˆØª\n"
                f"â€¢ ØªØ­ÙˆÙŠÙ„ Ø±Ø³Ø§Ù„Ø© ØµØ­ÙŠØ­Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª\n"
                f"â€¢ Ø£Ù† Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ\n\n"
                f"ğŸ’¡ Ø¥Ø°Ø§ Ø§Ø³ØªÙ…Ø±Øª Ø§Ù„Ù…Ø´ÙƒÙ„Ø©ØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©: @cxxov"
            )
            context.user_data['waiting_for'] = None
            user['points'] += cost

    async def show_bot_subscription(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        await self.delete_old_mandatory_message(context, user_id)
        if not self.paid_bots:
            await update.callback_query.edit_message_text(
                "âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„Ù„Ø§Ø´ØªØ±Ø§Ùƒ.\n\n"
                "ØªØ­Ù‚Ù‚ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙØ±Øµ Ø¬Ø¯ÙŠØ¯Ø© Ù„ÙƒØ³Ø¨ Ø§Ù„ÙƒÙˆÙƒÙŠØ²!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]])
            )
            return
        bot_id, bot_info = await self.get_next_paid_bot(user_id, context)
        if not bot_id:
            await update.callback_query.edit_message_text(
                "â€¢ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ , Ù‚Ù… ÙŠØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ø·Ø±ÙŠÙ‚Ù‡ Ù…Ø®ØªÙ„ÙÙ‡ â•\n",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]])
            )
            return
        user_reports = getattr(self, 'user_reports', {})
        user_id_str = str(user_id)
        report_button = []
        if user_id_str not in user_reports:
            user_reports[user_id_str] = {'bots': set(), 'channels': set()}
        if bot_id not in user_reports[user_id_str]['bots']:
            report_button = [InlineKeyboardButton("Ø§Ø¨Ù„Ø§Øº âš ï¸", callback_data=f"report_bot_{bot_id}")]
        self.user_reports = user_reports
        keyboard = [
            [InlineKeyboardButton("Ø¯Ø®ÙˆÙ„ ğŸ¤–", url=f"https://t.me/{bot_info['username']}")] + report_button,
            [InlineKeyboardButton("ØªØ®Ø·ÙŠ", callback_data=f"skip_bot_{bot_id}")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]
        ]
        await update.callback_query.edit_message_text(
            f"â€¢ Ù‚Ù… Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù‰ Ø¨ÙˆØª @{bot_info['username']} ğŸ¤–\n\n"
            f"- Ø§Ø±Ø³Ù„ /start Ø¯Ø§Ø®Ù„ Ø§Ù„Ø±ÙˆØ¨ÙˆØª Ø«Ù… Ù‚Ù… Ø¨ØªØ­ÙˆÙŠÙ„ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø±ÙˆØ¨ÙˆØª Ø§Ù„ÙŠ Ù‡Ù†Ø§ Ù„ØªØ­ØµÙ„ Ø¹Ù„Ù‰ {bot_info['points']} ÙƒÙˆÙƒÙŠØ² ğŸª",
            reply_markup=InlineKeyboardMarkup(keyboard),
            disable_web_page_preview=True
        )
        context.user_data['waiting_for'] = 'bot_subscription_forward'
        context.user_data['current_bot_id'] = bot_id
    async def get_next_paid_bot(self, user_id, context=None):
        user_subscriptions = self.user_bot_subscriptions.get(str(user_id), {})
        for bot_id, bot_info in self.paid_bots.items():
            if bot_id not in user_subscriptions:
                return bot_id, bot_info
        return None, None
    async def get_next_paid_bot_after_skip(self, user_id, current_bot_id, context):
        user_subscriptions = self.user_bot_subscriptions.get(str(user_id), {})
        bots_list = list(self.paid_bots.items())

        current_index = -1
        for i, (bot_id, bot_info) in enumerate(bots_list):
            if bot_id == current_bot_id:
                current_index = i
                break
        start_index = current_index + 1 if current_index != -1 else 0
        for i in range(start_index, len(bots_list)):
            bot_id, bot_info = bots_list[i]
            if bot_id not in user_subscriptions:
                return bot_id, bot_info
        for i in range(0, start_index):
            bot_id, bot_info = bots_list[i]
            if bot_id not in user_subscriptions:
                return bot_id, bot_info
        return None, None
    async def handle_bot_subscription_forward(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        if not hasattr(message, 'forward_origin') or not message.forward_origin:
            await update.message.reply_text("âŒ ÙŠØ¬Ø¨ ØªØ­ÙˆÙŠÙ„ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª ÙˆÙ„ÙŠØ³ ÙƒØªØ§Ø¨Ø© Ø±Ø³Ø§Ù„Ø©!")
            return
        from telegram import MessageOriginUser
        if not isinstance(message.forward_origin, MessageOriginUser):
            await update.message.reply_text("âŒ ÙŠØ¬Ø¨ ØªØ­ÙˆÙŠÙ„ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø¨ÙˆØª!")
            return
        forward_user = message.forward_origin.sender_user
        if not forward_user.is_bot:
            await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø­ÙˆÙ„Ø© Ù…Ù† Ø¨ÙˆØª!")
            return
        current_bot_id = context.user_data.get('current_bot_id')
        if not current_bot_id or current_bot_id not in self.paid_bots:
            await update.message.reply_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
            return
        forwarded_bot_id = str(forward_user.id)
        if forwarded_bot_id != current_bot_id:
            bot_info = self.paid_bots[current_bot_id]
            await update.message.reply_text(f"âŒ ÙŠØ¬Ø¨ ØªØ­ÙˆÙŠÙ„ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª @{bot_info['username']} ÙˆÙ„ÙŠØ³ Ù…Ù† Ø¨ÙˆØª Ø¢Ø®Ø±!")
            return
        user_id_str = str(user_id)
        if user_id_str not in self.user_bot_subscriptions:
            self.user_bot_subscriptions[user_id_str] = {}
        if current_bot_id not in self.user_bot_subscriptions[user_id_str]:
            bot_info = self.paid_bots[current_bot_id]
            user['points'] += bot_info['points']
            self.user_bot_subscriptions[user_id_str][current_bot_id] = {
                "points": bot_info['points'],
                "date": str(datetime.now())
            }
            if 'total_subscribers_count' not in self.paid_bots[current_bot_id]:
                self.paid_bots[current_bot_id]['total_subscribers_count'] = 0
            self.paid_bots[current_bot_id]['total_subscribers_count'] += 1

            self.save_json(USER_BOT_SUBSCRIPTION_FILE, self.user_bot_subscriptions)
            self.save_json(PAID_BOTS_FILE, self.paid_bots)
            current_count = self.paid_bots[current_bot_id]['total_subscribers_count']
            required_count = bot_info['members_required']
            if current_count >= required_count:
                funded_info = None
                owner_id = None
                funding_number = None
                if current_bot_id in self.funded_bots:
                    funded_info = self.funded_bots[current_bot_id]
                    owner_id = funded_info['owner_id']
                    for fund_num, fund_record in self.funding_numbers["records"].items():
                        if fund_record.get("bot_id") == current_bot_id and fund_record.get("funding_type") == "bot":
                            funding_number = fund_num
                            self.update_funding_status(fund_num, "Ù…ÙƒØªÙ…Ù„")
                            break
                    self.move_funding_to_completed(current_bot_id, "bot")
                try:
                    await context.bot.send_message(
                        ADMIN_ID,
                        f"ğŸ‰ ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ø¨ÙˆØª!\n\n"
                        f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: {bot_info['name']}\n"
                        f"ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {required_count}\n"
                        f"âœ… Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ: {current_count}\n"
                        f"ğŸ”¢ Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: #{funding_number}\n\n"
                        f"âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ÙÙŠ Ø§Ù„Ø£Ø±Ø´ÙŠÙ ÙˆØ¥Ø²Ø§Ù„ØªÙ‡ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø´Ø·Ø©."
                    )
                except Exception as e:
                    logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")

                if owner_id and funded_info:
                    try:
                        await context.bot.send_message(
                            owner_id,
                            f"ğŸ‰ ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ØªÙ… Ø§ÙƒØªÙ…Ø§Ù„ ØªÙ…ÙˆÙŠÙ„ Ø¨ÙˆØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                            f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: {bot_info['name']}\n"
                            f"ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ÙƒØªÙ…Ù„: {current_count}\n"
                            f"ğŸ†” Ø±Ù‚Ù… Ø§Ù„ØªÙ…ÙˆÙŠÙ„: #{funding_number}\n"
                            f"ğŸ’° Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø©: {self.format_points(funded_info.get('cost_paid', 0))} ğŸª\n\n"
                            f"ğŸ’¼ ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ÙÙŠ Ù‚Ø³Ù… 'ØªÙ…ÙˆÙŠÙ„Ø§ØªÙŠ'\n"
                            f"âœ… ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\n"
                            f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙ…ÙˆÙŠÙ„!"
                        )
                        try:
                            await context.bot.send_message(
                                ADMIN_ID,
                                f"âœ… ØªÙ… Ø¥Ø´Ø¹Ø§Ø± ØµØ§Ø­Ø¨ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ({owner_id}) Ø¨Ø¥ÙƒØªÙ…Ø§Ù„ ØªÙ…ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­"
                            )
                        except Exception as e:
                            logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")

                    except Exception as e:
                        logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø§ÙƒØªÙ…Ø§Ù„ Ù„ØµØ§Ø­Ø¨ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ {owner_id}: {e}")
                        try:
                            await context.bot.send_message(
                                ADMIN_ID,
                                f"âŒ ÙØ´Ù„ Ø¥Ø´Ø¹Ø§Ø± ØµØ§Ø­Ø¨ Ø§Ù„ØªÙ…ÙˆÙŠÙ„ ({owner_id}) Ø¨Ø¥ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ø¨ÙˆØª\n"
                                f"Ø§Ù„Ø³Ø¨Ø¨: {str(e)}"
                            )
                        except:
                            pass

                if current_bot_id in self.paid_bots:
                    del self.paid_bots[current_bot_id]

                for user_data in self.users.values():
                    if "funded_bots" in user_data and current_bot_id in user_data["funded_bots"]:
                        user_data["funded_bots"].remove(current_bot_id)

                self.save_json(PAID_BOTS_FILE, self.paid_bots)

            else:
                if current_bot_id in self.funded_bots:
                    funded_info = self.funded_bots[current_bot_id]
                    owner_id = funded_info['owner_id']

                    remaining = max(0, required_count - current_count)

                    try:
                        await context.bot.send_message(
                            owner_id,
                            f"ğŸ–ï¸ Ù‚Ø§Ù… Ø¹Ø¶Ùˆ Ø¨ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ âœ…\n\n"
                            f"- Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ : {remaining}"
                        )
                    except:
                        pass

            context.user_data['waiting_for'] = None
            if 'current_bot_id' in context.user_data:
                del context.user_data['current_bot_id']

            success_message = (
                f"âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ù†Ø¬Ø§Ø­ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø·! ğŸ‰\n\n"
                f"ğŸ’° ØªÙ… Ø¥Ø¶Ø§ÙØ© {bot_info['points']} ÙƒÙˆÙƒÙŠØ²\n"
                f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª\n\n"
                f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ! ğŸ™"
            )

            try:
                if hasattr(update, 'message') and update.message.reply_to_message:
                    await update.message.reply_to_message.edit_text(
                        success_message,
                        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="back_to_main")]])
                    )
                else:
                    await context.bot.send_message(
                        user_id,
                        success_message,
                        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="back_to_main")]])
                    )
            except:
                await context.bot.send_message(
                    user_id,
                    success_message,
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="back_to_main")]])
                )

            await asyncio.sleep(1)

            next_bot_id, next_bot_info = await self.get_next_paid_bot(user_id, context)

            if next_bot_id:
                user_reports = getattr(self, 'user_reports', {})
                user_id_str = str(user_id)

                report_button = []
                if user_id_str not in user_reports:
                    user_reports[user_id_str] = {'bots': set(), 'channels': set()}

                if next_bot_id not in user_reports[user_id_str]['bots']:
                    report_button = [InlineKeyboardButton("Ø§Ø¨Ù„Ø§Øº âš ï¸", callback_data=f"report_bot_{next_bot_id}")]

                self.user_reports = user_reports

                keyboard = [
                    [InlineKeyboardButton("Ø¯Ø®ÙˆÙ„ ğŸ¤–", url=f"https://t.me/{next_bot_info['username']}")] + report_button,
                    [InlineKeyboardButton("ØªØ®Ø·ÙŠ", callback_data=f"skip_bot_{next_bot_id}")],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]
                ]

                next_bot_message = (
                    f"â€¢ Ù‚Ù… Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„ÙŠ Ø¨ÙˆØª @{next_bot_info['username']} ğŸ¤–\n\n"
                    f"- Ø§Ø±Ø³Ù„ /start Ø¯Ø§Ø®Ù„ Ø§Ù„Ø±ÙˆØ¨ÙˆØª Ø«Ù… Ù‚Ù… Ø¨ØªØ­ÙˆÙŠÙ„ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø±ÙˆØ¨ÙˆØª Ø§Ù„ÙŠ Ù‡Ù†Ø§ Ù„ØªØ­ØµÙ„ Ø¹Ù„Ù‰ {next_bot_info['points']} ÙƒÙˆÙƒÙŠØ² ğŸª"
                )

                await context.bot.send_message(
                    user_id,
                    next_bot_message,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    disable_web_page_preview=True
                )

                context.user_data['waiting_for'] = 'bot_subscription_forward'
                context.user_data['current_bot_id'] = next_bot_id
            else:
                no_bots_message = (
                    f"â€¢ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ, Ù‚Ù… Ø¨ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ø®ØªÙ„ÙØ© â•"
                )

                await context.bot.send_message(
                    user_id,
                    no_bots_message,
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="back_to_main")]])
                )

        else:
            await update.message.reply_text("âœ… Ù„Ù‚Ø¯ Ø­ØµÙ„Øª Ø¹Ù„Ù‰ Ù†Ù‚Ø§Ø· Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ù‚Ø¨Ù„!")

    async def show_rush_services_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        active_accounts = get_active_accounts_count()

        keyboard = [
            [InlineKeyboardButton("ØªØµÙˆÙŠØª Ø¹Ø±Ø¨ Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ø¬Ø¨Ø§Ø±ÙŠ", callback_data="arab_vote_mandatory")],
            [InlineKeyboardButton("Ø±Ø´Ù‚ ØªÙØ§Ø¹Ù„Ø§Øª ", callback_data="rush_reactions"),
            InlineKeyboardButton("Ø±Ø´Ù‚ ØªØ¹Ù„ÙŠÙ‚Ø§Øª ", callback_data="comments_service")],
            [InlineKeyboardButton("ØªØ¹Ù„ÙŠÙ‚Ø§Øª 2", callback_data="comments_service_2")],
            [InlineKeyboardButton("Ø±Ø´Ù‚ Ø§Ø³ØªÙØªØ§Ø¡", callback_data="poll_service")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="services_menu")]
        ]

        status_message = ""
        if active_accounts == 0:
            status_message = "\nâš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø´Ø·Ø© Ø­Ø§Ù„ÙŠØ§Ù‹"
        else:
            status_message = f"\nâœ… Ù…ØªÙˆÙØ± {active_accounts} Ø­Ø³Ø§Ø¨ Ù†Ø´Ø·"

        await update.callback_query.edit_message_text(
            f"â€¢ Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Ù‚Ø³Ù… Ø§Ù„Ø®Ø¯Ù…Ø§Øª ØŒ Ø§Ø®ØªØ± Ù…Ù† Ø¨ÙŠÙ† Ø§Ù„Ø§Ø²Ø±Ø§Ø± Ø§Ø¯Ù†Ø§Ù‡ ã€½ï¸:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_arab_vote_mandatory_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        if active_accounts == 0:
            await update.callback_query.edit_message_text(
                "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø´Ø·Ø© Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„ØªÙ†ÙÙŠØ° Ø®Ø¯Ù…Ø© Ø§Ù„ØªØµÙˆÙŠØª\n\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="rush_services")]])
            )
            return

        context.user_data['waiting_for'] = 'arab_vote_count'
        context.user_data['service_type'] = 'arab_vote_mandatory'

        await update.callback_query.edit_message_text(
            f"âŒï¸™Ø®Ø¯Ù…Ø© ØªØµÙˆÙŠØª Ø¹Ø±Ø¨ Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ø¬Ø¨Ø§Ø±ÙŠ\n"
            f"âŒï¸™ Ø³Ø¹Ø± Ø§Ù„ØªØµÙˆÙŠØª Ø§Ù„ÙˆØ§Ø­Ø¯ {vote_price} ÙƒÙˆÙƒÙŠØ²\n"
            f"âŒï¸™Ø§Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ØªØµÙˆÙŠØªØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡ ( Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ {active_accounts}):\n",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="rush_services")]])
        )

    async def handle_arab_vote_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE, count_text):
        try:
            count = int(count_text.strip())
            user_id = update.effective_user.id
            user = self.get_user(user_id)

            active_accounts = get_active_accounts_count()

            if count <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¹Ø¯Ø¯ Ø§Ù„ØªØµÙˆÙŠØªØ§Øª Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return

            if count > active_accounts:
                await update.message.reply_text(f"âŒ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ({count}) Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ ({active_accounts})!")
                return

            total_cost = count * vote_price

            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                    f"ğŸ’° ØªØ­ØªØ§Ø¬: {self.format_points(total_cost)} ğŸª\n"
                    f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª"
                )
                context.user_data['waiting_for'] = None
                return

            context.user_data['arab_vote_count'] = count
            context.user_data['arab_vote_cost'] = total_cost
            context.user_data['waiting_for'] = 'arab_vote_link'

            await update.message.reply_text(
                f"âŒï¸™ Ø§Ù„Ø¹Ø¯Ø¯: {count} ØªØµÙˆÙŠØª\n"
                f"âŒï¸™ Ø§Ù„ØªÙƒÙ„ÙØ©: {self.format_points(total_cost)} ÙƒÙˆÙƒÙŠØ²\n"
                f"âŒï¸™ Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù†Ø´ÙˆØ± Ù„Ù„ØªØµÙˆÙŠØª Ø¹Ù„ÙŠÙ‡:\n"
                f"Ù…Ø«Ø§Ù„:-\n"
                f"https://t.me/cxxgo/8..."
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def handle_arab_vote_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, link_text):
        link = link_text.strip()

        if not link.startswith(('https://t.me/', 'http://t.me/', 't.me/')):
            await update.message.reply_text("âŒ Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ­ÙŠØ­! ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ØµÙŠØºØ©: https://t.me/cxxgo/8")
            return

        if link.startswith('t.me/'):
            link = 'https://' + link
        elif link.startswith('http://'):
            link = link.replace('http://', 'https://')

        context.user_data['arab_vote_link'] = link

        await self.show_speed_selection(update, context)

    async def show_speed_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        link = context.user_data.get('arab_vote_link', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')
        count = context.user_data.get('arab_vote_count', 0)
        cost = context.user_data.get('arab_vote_cost', 0)

        keyboard = [            
            [InlineKeyboardButton("ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø³Ø±Ø¹Ø© â³", callback_data="arab_vote_speed_custom"),
            InlineKeyboardButton("Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù‚ØµÙˆÙ‰ ğŸš€", callback_data="arab_vote_speed_fast")],
        ]
        message_text = (
            f"âŒï¸™ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø³Ø±Ø¹Ø© Ø§Ù„Ø±Ø´Ù‚:\n"
        )
        if hasattr(update, 'callback_query') and update.callback_query:
            await update.callback_query.edit_message_text(
                message_text,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await update.message.reply_text(
                message_text,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )

        context.user_data['waiting_for'] = 'arab_vote_speed'

    async def handle_arab_vote_speed_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø³Ø±Ø¹Ø©"""
        if data == "arab_vote_speed_fast":
            await self.execute_arab_vote(update, context, 0)
        elif data == "arab_vote_speed_custom":
            await self.show_custom_speed_input(update, context)

    async def show_custom_speed_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¹Ø±Ø¶ Ù†Ø§ÙØ°Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù…Ø®ØµØµØ©"""
        link = context.user_data.get('arab_vote_link', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')
        count = context.user_data.get('arab_vote_count', 0)
        cost = context.user_data.get('arab_vote_cost', 0)

        context.user_data['waiting_for'] = 'arab_vote_speed'

        await update.callback_query.edit_message_text(
             f"âŒï¸™Ø£Ø±Ø³Ù„ ÙˆÙ‚Øª Ø§Ù„Ø¥Ù†ØªØ¶Ø§Ø± Ø¨ÙŠÙ† Ø§Ù„Ø±Ø´Ù‚ (Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ).\n"
           f"â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢ \n"
           f"âŒï¸™ÙŠØ¬Ø¨ Ø§Ù† Ù„Ø§ÙŠØ²ÙŠØ¯ Ø¹Ù† 300",
        )

    async def handle_arab_vote_speed(self, update: Update, context: ContextTypes.DEFAULT_TYPE, speed_text):
        try:
            speed = int(speed_text.strip())
            if speed < 0 or speed > 500:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ø³Ø±Ø¹Ø© Ø¨ÙŠÙ† 0 Ùˆ 500 Ø«Ø§Ù†ÙŠØ©!")
                return

            await self.execute_arab_vote(update, context, speed)

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def execute_arab_vote(self, update: Update, context: ContextTypes.DEFAULT_TYPE, speed=0):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        count = context.user_data.get('arab_vote_count')
        link = context.user_data.get('arab_vote_link')
        cost = context.user_data.get('arab_vote_cost')

        if not all([count, link, cost]):
            await update.message.reply_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
            return

        estimated_time_seconds = (speed * count) + (3 * count)
        estimated_time_minutes = estimated_time_seconds / 60

        user['points'] -= cost


        start_message = (
            f"ğŸ”„ ÙŠØªÙ… ØªÙ†ÙÙŠØ° Ø·Ù„Ø¨Ùƒ...\n"
            f"â° Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù‚Ø¯Ø±: {estimated_time_minutes:.1f} Ø¯\n\n"
            f"ğŸ“Š Ø³Ø£Ø®Ø¨Ø±Ùƒ Ø¨Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡"
        )

        if hasattr(update, 'callback_query') and update.callback_query:
            message = await update.callback_query.edit_message_text(start_message)
        else:
            message = await update.message.reply_text(start_message)

        asyncio.create_task(self.process_arab_vote_async(
            user_id, count, link, speed, message, context
        ))

        context.user_data['waiting_for'] = None
        for key in ['arab_vote_count', 'arab_vote_link', 'arab_vote_cost', 'arab_vote_speed']:
            if key in context.user_data:
                del context.user_data[key]

    async def show_rush_reactions_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        if active_accounts == 0:
            await update.callback_query.edit_message_text(
                "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø´Ø·Ø© Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„ØªÙ†ÙÙŠØ° Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª\n\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="rush_services")]])
            )
            return
        keyboard = [
            [InlineKeyboardButton("ØªÙØ§Ø¹Ù„Ø§Øª Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©", callback_data="positive_reactions"),
            InlineKeyboardButton("ØªÙØ§Ø¹Ù„Ø§Øª Ø³Ù„Ø¨ÙŠØ©", callback_data="negative_reactions")],
            [InlineKeyboardButton("ØªÙØ§Ø¹Ù„Ø§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©", callback_data="random_reactions")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="rush_services")]
        ]
        await update.callback_query.edit_message_text(
            f"Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù‚Ø³Ù… Ø±Ø´Ù‚ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§ØªâŒï¸™\n",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def handle_positive_reactions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        context.user_data['waiting_for'] = 'positive_reactions_count'
        context.user_data['service_type'] = 'positive_reactions'

        await update.callback_query.edit_message_text(
            f"âŒï¸™Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø£ÙŠØ¬Ø§Ø¨ÙŠØ©\n"
            f"âŒï¸™ Ø³Ø¹Ø± Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„ÙˆØ§Ø­Ø¯ {react_price} ÙƒÙˆÙƒÙŠØ²\n"
            f"âŒï¸™Ø§Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ØªØµÙˆÙŠØªØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡ ( Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ {active_accounts}):\n",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="rush_reactions")]])
        )

    async def handle_negative_reactions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        context.user_data['waiting_for'] = 'positive_reactions_count'
        context.user_data['service_type'] = 'negative_reactions'

        await update.callback_query.edit_message_text(
             f"âŒï¸™Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø³Ù„Ø¨ÙŠØ©\n"
            f"âŒï¸™ Ø³Ø¹Ø± Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„ÙˆØ§Ø­Ø¯ {react_price} ÙƒÙˆÙƒÙŠØ²\n"
            f"âŒï¸™Ø§Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ØªØµÙˆÙŠØªØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡ ( Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ {active_accounts}):\n",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="rush_reactions")]])
        )

    async def handle_random_reactions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        context.user_data['waiting_for'] = 'positive_reactions_count'
        context.user_data['service_type'] = 'random_reactions'

        await update.callback_query.edit_message_text(
             f"âŒï¸™Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠÙ‡\n"
            f"âŒï¸™ Ø³Ø¹Ø± Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„ÙˆØ§Ø­Ø¯ {react_price} ÙƒÙˆÙƒÙŠØ²\n"
            f"âŒï¸™Ø§Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ØªØµÙˆÙŠØªØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡ ( Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ {active_accounts}):\n",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="rush_reactions")]])
        )

    async def handle_reactions_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE, count_text):
        try:
            count = int(count_text.strip())
            user_id = update.effective_user.id
            user = self.get_user(user_id)

            active_accounts = get_active_accounts_count()

            if count <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¹Ø¯Ø¯ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return

            if count > active_accounts:
                await update.message.reply_text(f"âŒ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ({count}) Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ ({active_accounts})!")
                return

            total_cost = count * react_price

            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                    f"ğŸ’° ØªØ­ØªØ§Ø¬: {self.format_points(total_cost)} ğŸª\n"
                    f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª"
                )
                context.user_data['waiting_for'] = None
                return

            context.user_data['reactions_count'] = count
            context.user_data['reactions_cost'] = total_cost
            context.user_data['waiting_for'] = 'reactions_link'

            await update.message.reply_text(
                f"âŒï¸™ Ø§Ù„Ø¹Ø¯Ø¯: {count} ØªÙØ§Ø¹Ù„\n"
                f"âŒï¸™ Ø§Ù„ØªÙƒÙ„ÙØ©: {self.format_points(total_cost)} ÙƒÙˆÙƒÙŠØ²\n"
                f"âŒï¸™ Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù†Ø´ÙˆØ± Ù„Ù„ØªÙØ§Ø¹Ù„ Ø¹Ù„ÙŠÙ‡:\n"
                f"Ù…Ø«Ø§Ù„:-\n"
                f"https://t.me/TurboFollow2/423..."
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def handle_reactions_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, link_text):
        link = link_text.strip()

        if not link.startswith(('https://t.me/', 'http://t.me/', 't.me/')):
            await update.message.reply_text("âŒ Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ­ÙŠØ­! ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ØµÙŠØºØ©: https://t.me/channel/123")
            return

        if link.startswith('t.me/'):
            link = 'https://' + link
        elif link.startswith('http://'):
            link = link.replace('http://', 'https://')

        context.user_data['reactions_link'] = link

        service_type = context.user_data.get('service_type', 'positive_reactions')
        count = context.user_data.get('reactions_count')
        cost = context.user_data.get('reactions_cost')

        await self.execute_reactions(update, context, service_type, count, cost, link)

    async def execute_reactions(self, update: Update, context: ContextTypes.DEFAULT_TYPE, service_type, count, cost, link):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        user['points'] -= cost


        start_message = (
            f"ğŸ”„ ÙŠØªÙ… ØªÙ†ÙÙŠØ° Ø·Ù„Ø¨Ùƒ...\n"
            f"â¤ï¸ Ù†ÙˆØ¹ Ø§Ù„ØªÙØ§Ø¹Ù„: {service_type}\n"
            f"ğŸ“Š Ø§Ù„Ø¹Ø¯Ø¯: {count}\n\n"
            f"ğŸ“ Ø³Ø£Ø®Ø¨Ø±Ùƒ Ø¨Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡"
        )

        message = await update.message.reply_text(start_message)

        asyncio.create_task(self.process_reactions_async(
            user_id, service_type, count, link, message, context
        ))

        context.user_data['waiting_for'] = None
        for key in ['reactions_count', 'reactions_link', 'reactions_cost', 'service_type']:
            if key in context.user_data:
                del context.user_data[key]   
    async def skip_current_bot(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        user_id = update.effective_user.id
        current_bot_id = data.split("_")[2]

        next_bot_id, next_bot_info = await self.get_next_paid_bot_after_skip(user_id, current_bot_id, context)

        if next_bot_id:
            user_reports = getattr(self, 'user_reports', {})
            user_id_str = str(user_id)

            report_button = []
            if user_id_str not in user_reports:
                user_reports[user_id_str] = {'bots': set(), 'channels': set()}

            if next_bot_id not in user_reports[user_id_str]['bots']:
                report_button = [InlineKeyboardButton("Ø§Ø¨Ù„Ø§Øº âš ï¸", callback_data=f"report_bot_{next_bot_id}")]

            self.user_reports = user_reports

            keyboard = [
                [InlineKeyboardButton("Ø¯Ø®ÙˆÙ„ ğŸ¤–", url=f"https://t.me/{next_bot_info['username']}")] + report_button,
                [InlineKeyboardButton("ØªØ®Ø·ÙŠ", callback_data=f"skip_bot_{next_bot_id}")],
                [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]
            ]

            await update.callback_query.edit_message_text(
                f"â€¢ Ù‚Ù… Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù‰ Ø¨ÙˆØª @{next_bot_info['username']} ğŸ¤–\n\n"
                f"- Ø§Ø±Ø³Ù„ /start Ø¯Ø§Ø®Ù„ Ø§Ù„Ø±ÙˆØ¨ÙˆØª Ø«Ù… Ù‚Ù… Ø¨ØªØ­ÙˆÙŠÙ„ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø±ÙˆØ¨ÙˆØª Ø§Ù„ÙŠ Ù‡Ù†Ø§ Ù„ØªØ­ØµÙ„ Ø¹Ù„Ù‰ {next_bot_info['points']} ÙƒÙˆÙƒÙŠØ² ğŸª",
                reply_markup=InlineKeyboardMarkup(keyboard),
                disable_web_page_preview=True
            )

            context.user_data['waiting_for'] = 'bot_subscription_forward'
            context.user_data['current_bot_id'] = next_bot_id
        else:
            await update.callback_query.edit_message_text(
                "âœ… Ù„Ù‚Ø¯ Ù…Ø±Ø±Øª Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©!\n\n"
                "ğŸ”’ Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø±ØµÙŠØ¯ÙƒØŒ ÙŠÙØ±Ø¬Ù‰ Ø¹Ø¯Ù… Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ø¨ÙˆØªØ§Øª.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="collect_stars")]])
            )

    async def process_reactions_async(self, user_id, service_type, count, link, message, context):
        try:
            from apis import react_positive_multiple, react_negative_multiple, get_working_accounts

            working_accounts = get_working_accounts()

            if not working_accounts:
                await message.edit_text("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø´Ø·Ø© Ù„Ù„ØªÙØ§Ø¹Ù„")
                return

            accounts_to_use = working_accounts[:count]

            await message.edit_text(
                f"Ø¬Ø§Ø± Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ...\n\n"
                f"Ø¬Ø§Ø± Ø±Ø´Ù‚ {count} ØªÙØ§Ø¹Ù„\n\n"
                f"Ø³Ø£Ø®Ø¨Ø±Ùƒ Ø¨Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨.\n"
            )

            if service_type == 'positive_reactions':
                results = await react_positive_multiple(accounts_to_use, link, 3, count)
            elif service_type == 'negative_reactions':
                results = await react_negative_multiple(accounts_to_use, link, 3, count)
            else:  # random_reactions
                from apis import reaction
                results = {"successful": 0, "failed": 0, "total": count}

                print(f"ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… {len(accounts_to_use)} Ø­Ø³Ø§Ø¨...")

                for i, session_data in enumerate(accounts_to_use):
                    session = session_data.get('s', '')
                    if session:
                        try:
                            print(f"ğŸ”„ ØªÙØ§Ø¹Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ {i+1}/{len(accounts_to_use)}")
                            result = await reaction(session, link)
                            if result:
                                results["successful"] += 1
                                print(f"âœ… Ù†Ø¬Ø­ Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ {i+1}")
                            else:
                                results["failed"] += 1
                                print(f"âŒ ÙØ´Ù„ Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ {i+1}")
                        except Exception as e:
                            print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙØ§Ø¹Ù„ Ù„Ù„Ø­Ø³Ø§Ø¨ {i+1}: {e}")
                            results["failed"] += 1
                    else:
                        results["failed"] += 1

                    if i < len(accounts_to_use) - 1:
                        await asyncio.sleep(3)

            success_rate = (results["successful"] / count * 100) if count > 0 else 0

            service_names = {
                'positive_reactions': 'Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ© â¤ï¸',
                'negative_reactions': 'Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø³Ù„Ø¨ÙŠØ© ğŸ’”',
                'random_reactions': 'Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© ğŸ²'
            }

            final_message = (
                f"âŒï¸™ ØªÙ… Ø¥ÙƒØªÙ…Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­ ØªÙØ§ØµÙŠÙ„ Ø¹Ù† Ø·Ù„Ø¨Ùƒ â†¯\n"
                f"âŒï¸™Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ â†« {count} ØªÙØ§Ø¹Ù„\n"
                f"âŒï¸™Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ÙƒØªÙ…Ù„ â†«{results['successful']}\n"
                f"âŒï¸™ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­: {success_rate:.1f}%\n"
                f"âŒï¸™Ø§Ù„Ø±Ø§Ø¨Ø· â†«{link[:50]}..."
            )

            await message.edit_text(final_message)

            try:
                await context.bot.send_message(
                    ADMIN_ID,
                    f"â¤ï¸ ØªÙØ§Ø¹Ù„Ø§Øª Ù…ÙƒØªÙ…Ù„Ø©:\n"
                    f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\n"
                    f"ğŸ”— Ø§Ù„Ø±Ø§Ø¨Ø·: {link}\n"
                    f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬: {results['successful']}/{count}\n"
                    f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}"
                )
            except:
                pass

            try:
                thank_you_message = "ğŸ™ Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ùƒ #Ø¨ÙˆØª_ØªÙŠØ±Ø¨Ùˆ_ÙÙˆÙ„Ùˆ"
                await context.bot.send_message(user_id, thank_you_message)
            except Exception as e:
                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø´ÙƒØ±: {e}")

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªÙ†ÙÙŠØ° Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª: {e}")
            await message.edit_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª: {str(e)}")

    async def process_arab_vote_async(self, user_id, count, link, speed, message, context):
        try:
            from apis import vote_multiple, get_working_accounts

            working_accounts = get_working_accounts()

            if not working_accounts:
                await message.edit_text("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø´Ø·Ø© Ù„Ù„ØªØµÙˆÙŠØª")
                return

            accounts_to_use = working_accounts[:count]

            await message.edit_text(
                f"Ø¬Ø§Ø± Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ...\n\n"
                f"Ø¬Ø§Ø± Ø±Ø´Ù‚ {count} ØªÙØ§Ø¹Ù„ \n\n"
                f"Ø³Ø£Ø®Ø¨Ø±Ùƒ Ø¨Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨.\n"

            )

            results = await vote_multiple(accounts_to_use, link, speed, count)

            success_rate = (results["successful"] / count * 100) if count > 0 else 0

            final_message = (
                f"âŒï¸™ ØªÙ… Ø¥ÙƒØªÙ…Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­ ØªÙØ§ØµÙŠÙ„ Ø¹Ù† Ø·Ù„Ø¨Ùƒ â†¯ \n"
                f"âŒï¸™Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ â†« {count} ØªØµÙˆÙŠØª\n"
                f"âŒï¸™Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…ÙƒØªÙ…Ù„ â†«{results['successful']}\n"
                f"âŒï¸™ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­: {success_rate:.1f}%\n"
                f"âŒï¸™Ø§Ù„Ø±Ø§Ø¨Ø· â†«{link[:50]}..."
            )

            await message.edit_text(final_message)

            try:
                await context.bot.send_message(
                    ADMIN_ID,
                    f"ğŸ—³ï¸ ØªØµÙˆÙŠØª Ø¹Ø±Ø¨ Ù…ÙƒØªÙ…Ù„:\n"
                    f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\n"
                    f"ğŸ”— Ø§Ù„Ø±Ø§Ø¨Ø·: {link}\n"
                    f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬: {results['successful']}/{count}\n"
                    f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}"
                )
            except:
                pass

            try:
                thank_you_message = "ğŸ™ Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ùƒ #Ø¨ÙˆØª_ØªÙŠØ±Ø¨Ùˆ_ÙÙˆÙ„Ùˆ"
                await context.bot.send_message(user_id, thank_you_message)
            except Exception as e:
                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø´ÙƒØ±: {e}")

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªÙ†ÙÙŠØ° Ø§Ù„ØªØµÙˆÙŠØª Ø§Ù„Ø¹Ø±Ø¨ÙŠ: {e}")
            await message.edit_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØµÙˆÙŠØª: {str(e)}")

    async def show_comments_service_2_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        await update.callback_query.edit_message_text(
            "Ù‚Ø±ÙŠØ¨Ø§ ğŸ”´",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="rush_services")]])
        )

    async def show_comments_service_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        if active_accounts == 0:
            await update.callback_query.edit_message_text(
                "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø´Ø·Ø© Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„ØªÙ†ÙÙŠØ° Ø®Ø¯Ù…Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª\n\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="rush_services")]])
            )
            return

        context.user_data['waiting_for'] = 'comments_count'
        context.user_data['service_type'] = 'comments_service'

        await update.callback_query.edit_message_text(
            f"ğŸ’¬ Ø®Ø¯Ù…Ø© Ø±Ø´Ù‚ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª\n\n"
            f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ: {self.format_points(user['points'])} ğŸª\n"
            f"ğŸ“Š Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©: {active_accounts}\n"
            f"ğŸ’ Ø³Ø¹Ø± Ø§Ù„ØªØ¹Ù„ÙŠÙ‚ Ø§Ù„ÙˆØ§Ø­Ø¯: {comment_price} ÙƒÙˆÙƒÙŠØ²\n\n"
            f"ğŸ“ Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: {active_accounts}):",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="rush_services")]])
        )

    async def handle_comments_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE, count_text):
        try:
            count = int(count_text.strip())
            user_id = update.effective_user.id
            user = self.get_user(user_id)

            active_accounts = get_active_accounts_count()

            if count <= 0:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¹Ø¯Ø¯ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„ØµÙØ±!")
                return

            if count > active_accounts:
                await update.message.reply_text(f"âŒ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ({count}) Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ ({active_accounts})!")
                return

            total_cost = count * comment_price

            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"âŒ Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙ!\n\n"
                    f"ğŸ’° ØªØ­ØªØ§Ø¬: {self.format_points(total_cost)} ğŸª\n"
                    f"ğŸ“Š Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(user['points'])} ğŸª"
                )
                context.user_data['waiting_for'] = None
                return

            context.user_data['comments_count'] = count
            context.user_data['comments_cost'] = total_cost
            context.user_data['waiting_for'] = 'comments_link'

            await update.message.reply_text(
                f"âœ… Ø§Ù„Ø¹Ø¯Ø¯: {count} ØªØ¹Ù„ÙŠÙ‚\n"
                f"ğŸ’° Ø§Ù„ØªÙƒÙ„ÙØ©: {self.format_points(total_cost)} ğŸª\n\n"
                f"ğŸ“ Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù†Ø´ÙˆØ± Ù„Ù„ØªØ¹Ù„ÙŠÙ‚ Ø¹Ù„ÙŠÙ‡:"
            )

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def handle_comments_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, link_text):
        link = link_text.strip()

        if not link.startswith(('https://t.me/', 'http://t.me/', 't.me/')):
            await update.message.reply_text("âŒ Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ­ÙŠØ­! ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ØµÙŠØºØ©: https://t.me/channel/123")
            return

        if link.startswith('t.me/'):
            link = 'https://' + link
        elif link.startswith('http://'):
            link = link.replace('http://', 'https://')

        context.user_data['comments_link'] = link
        context.user_data['waiting_for'] = 'comments_text'

        await update.message.reply_text(
            f"âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø±Ø§Ø¨Ø·\n\n"
            f"ğŸ“ Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ù†Øµ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚ (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 1000 Ø­Ø±Ù):"
        )

    async def handle_comments_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE, text):
        if len(text) > 1000:
            await update.message.reply_text("âŒ Ø§Ù„Ù†Øµ Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹! Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 1000 Ø­Ø±Ù")
            return

        context.user_data['comments_text'] = text

        keyboard = [
            [InlineKeyboardButton("Ø³Ø±ÙŠØ¹ (3 Ø«ÙˆØ§Ù†ÙŠ)", callback_data="comments_speed_fast")],
            [InlineKeyboardButton("Ø¹Ø§Ø¯ÙŠ (10 Ø«ÙˆØ§Ù†ÙŠ)", callback_data="comments_speed_normal")],
            [InlineKeyboardButton("Ø¨Ø·ÙŠØ¡ (20 Ø«Ø§Ù†ÙŠØ©)", callback_data="comments_speed_slow")],
            [InlineKeyboardButton("Ù…Ø®ØµØµ", callback_data="comments_speed_custom")],
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="rush_services")]
        ]

        await update.message.reply_text(
            f"âš¡ Ø§Ø®ØªØ± Ø³Ø±Ø¹Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª:\n\n"
            f"ğŸ’¬ Ù†Øµ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚: {text[:50]}{'...' if len(text) > 50 else ''}\n"
            f"ğŸ“Š Ø§Ù„Ø¹Ø¯Ø¯: {context.user_data.get('comments_count', 0)}\n"
            f"ğŸ’° Ø§Ù„ØªÙƒÙ„ÙØ©: {self.format_points(context.user_data.get('comments_cost', 0))} ğŸª",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        context.user_data['waiting_for'] = 'comments_speed'

    async def handle_comments_speed_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        speed_map = {
            "comments_speed_fast": 3,
            "comments_speed_normal": 10,
            "comments_speed_slow": 20
        }

        if data in speed_map:
            await self.execute_comments(update, context, speed_map[data])
        elif data == "comments_speed_custom":
            await self.show_comments_custom_speed_input(update, context)

    async def show_comments_custom_speed_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'comments_speed'

        await update.callback_query.edit_message_text(
            f"âŒï¸™Ø£Ø±Ø³Ù„ ÙˆÙ‚Øª Ø§Ù„Ø¥Ù†ØªØ¶Ø§Ø± Ø¨ÙŠÙ† Ø§Ù„Ø±Ø´Ù‚ (Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ).\n"
           f"â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢ â‹¯ â€¢ \n"
           f"âŒï¸™ÙŠØ¬Ø¨ Ø§Ù† Ù„Ø§ÙŠØ²ÙŠØ¯ Ø¹Ù† 300",
        )

    async def handle_comments_speed(self, update: Update, context: ContextTypes.DEFAULT_TYPE, speed_text):
        try:
            speed = int(speed_text.strip())
            if speed < 0 or speed > 300:
                await update.message.reply_text("âŒ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ø³Ø±Ø¹Ø© Ø¨ÙŠÙ† 0 Ùˆ 300 Ø«Ø§Ù†ÙŠØ©!")
                return

            await self.execute_comments(update, context, speed)

        except ValueError:
            await update.message.reply_text("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­!")

    async def execute_comments(self, update: Update, context: ContextTypes.DEFAULT_TYPE, speed=10):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        count = context.user_data.get('comments_count')
        link = context.user_data.get('comments_link')
        comment_text = context.user_data.get('comments_text')
        cost = context.user_data.get('comments_cost')

        if not all([count, link, comment_text, cost]):
            await update.message.reply_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
            return

        user['points'] -= cost


        start_message = (
            f"ğŸ”„ ÙŠØªÙ… ØªÙ†ÙÙŠØ° Ø·Ù„Ø¨Ùƒ...\n"
            f"ğŸ’¬ Ø¹Ø¯Ø¯ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª: {count}\n"
            f"â° Ø§Ù„Ø³Ø±Ø¹Ø©: {speed} Ø«Ø§Ù†ÙŠØ©\n\n"
            f"ğŸ“ Ø³Ø£Ø®Ø¨Ø±Ùƒ Ø¨Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡"
        )
        if hasattr(update, 'callback_query') and update.callback_query:
            message = await update.callback_query.edit_message_text(start_message)
        else:
            message = await update.message.reply_text(start_message)
        asyncio.create_task(self.process_comments_async(
            user_id, count, link, comment_text, speed, message, context
        ))
        context.user_data['waiting_for'] = None
        for key in ['comments_count', 'comments_link', 'comments_text', 'comments_cost']:
            if key in context.user_data:
                del context.user_data[key]
    async def process_comments_async(self, user_id, count, link, comment_text, speed, message, context):
        try:
            from apis import send_comments_multiple, get_working_accounts_for_comments
            working_accounts = get_working_accounts_for_comments()
            if not working_accounts:
                await message.edit_text("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø´Ø·Ø© Ù„Ù„ØªØ¹Ù„ÙŠÙ‚")
                return
            accounts_to_use = working_accounts[:count]
            await message.edit_text(
                f"ğŸš€ Ø¨Ø¯Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª...\n"
                f"ğŸ’¬ Ø§Ù„Ù†Øµ: {comment_text[:30]}{'...' if len(comment_text) > 30 else ''}\n"
                f"ğŸ“Š Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {count}\n"
                f"ğŸ‘¥ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©: {len(accounts_to_use)}\n"
                f"â° Ø§Ù„Ø³Ø±Ø¹Ø©: {speed} Ø«Ø§Ù†ÙŠØ©"
            )
            results = await send_comments_multiple(accounts_to_use, link, comment_text, speed, count)

            success_rate = (results["successful"] / count * 100) if count > 0 else 0
            final_message = (
                f"âœ… ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª!\n\n"
                f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬:\n"
                f"âœ… Ù†Ø¬Ø­: {results['successful']}\n"
                f"âŒ ÙØ´Ù„: {results['failed']}\n"
                f"ğŸ“ˆ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­: {success_rate:.1f}%\n\n"
                f"ğŸ”— Ø§Ù„Ø±Ø§Ø¨Ø·: {link[:50]}..."
            )
            await message.edit_text(final_message)
            try:
                await context.bot.send_message(
                    ADMIN_ID,
                    f"ğŸ’¬ ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ù…ÙƒØªÙ…Ù„Ø©:\n"
                    f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\n"
                    f"ğŸ”— Ø§Ù„Ø±Ø§Ø¨Ø·: {link}\n"
                    f"ğŸ’¬ Ø§Ù„Ù†Øµ: {comment_text[:50]}{'...' if len(comment_text) > 50 else ''}\n"
                    f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬: {results['successful']}/{count}\n"
                    f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {self.format_time_12h(datetime.now())}"
                )
            except:
                pass
            try:
                thank_you_message = "ğŸ™ Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ùƒ #Ø¨ÙˆØª_ØªÙŠØ±Ø¨Ùˆ_ÙÙˆÙ„Ùˆ"
                await context.bot.send_message(user_id, thank_you_message)
            except Exception as e:
                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø´ÙƒØ±: {e}")
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªÙ†ÙÙŠØ° Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª: {e}")
            await message.edit_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª: {str(e)}")
    async def manage_paid_bots_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [InlineKeyboardButton("ğŸ—‘ï¸ Ø­Ø°Ù Ø¨ÙˆØª Ù…Ø¯ÙÙˆØ¹", callback_data="delete_paid_bot")],
            [InlineKeyboardButton("ğŸ“Š Ø§Ø¯Ø§Ø±Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª", callback_data="manage_bots_count")],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")]
        ]
        text = "ğŸ¤– Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø©:\n\n"
        if self.paid_bots:
            text += "Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©:\n"
            for bot_id, info in self.paid_bots.items():
                text += f"â€¢ {info['name']} - {self.format_points(info['points'])} ğŸª (@{info['username']})\n"
        else:
            text += "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª Ù…Ø¯ÙÙˆØ¹Ø© Ø­Ø§Ù„ÙŠØ§Ù‹."
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def delete_paid_bot_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.paid_bots:
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª Ù…Ø¯ÙÙˆØ¹Ø© Ù„Ù„Ø­Ø°Ù!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_paid_bots")]])
            )
            return
        keyboard = []
        for bot_id, info in self.paid_bots.items():
            keyboard.append([InlineKeyboardButton(f"ğŸ—‘ï¸ {info['name']}", callback_data=f"del_bot_{bot_id}")])
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_paid_bots")])
        await update.callback_query.edit_message_text(
            "ğŸ—‘ï¸ Ø§Ø®ØªØ± Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù…Ø±Ø§Ø¯ Ø­Ø°ÙÙ‡:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def confirm_delete_paid_bot(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        bot_id = data.split("_")[2]
        if bot_id in self.paid_bots:
            bot_name = self.paid_bots[bot_id]['name']
            del self.paid_bots[bot_id]
            self.save_json(PAID_BOTS_FILE, self.paid_bots)
            if bot_id in self.funded_bots:
                del self.funded_bots[bot_id]
                self.save_json(FUNDED_BOTS_FILE, self.funded_bots)
            await update.callback_query.edit_message_text(
                f"âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¨ÙˆØª '{bot_name}' Ø¨Ù†Ø¬Ø§Ø­!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_paid_bots")]])
            )
        else:
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="manage_paid_bots")]])
            )
    async def manage_bots_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.paid_bots:
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª Ù…Ø¯ÙÙˆØ¹Ø©!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")]])
            )
            return
        keyboard = []
        text = "ğŸ“Š Ø¥Ø¯Ø§Ø±Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª:\n\n"
        for bot_id, info in self.paid_bots.items():
            total_subscribers = info.get('total_subscribers_count', 0)
            required = info['members_required']
            keyboard.append([
                InlineKeyboardButton(f"ğŸ¤– {info['name']}", callback_data=f"bot_info_{bot_id}"),
                InlineKeyboardButton(f"{total_subscribers}/{required}", callback_data=f"bot_count_info_{bot_id}")
            ])
            text += f"ğŸ¤– {info['name']}\n"
            text += f"ğŸ‘¥ Ø§Ù„Ø¹Ø¯Ø¯: {total_subscribers}/{required}\n\n"
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_panel")])
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def execute_leave_all_chats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.callback_query.edit_message_text("ğŸ”„ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ù…ØºØ§Ø¯Ø±Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª...")
        from apis import get_working_accounts, leave_chats
        accounts = get_working_accounts()
        if not accounts:
            await update.callback_query.edit_message_text(
                "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù…ØªØ§Ø­Ø©!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_settings")]])
            )
            return
        successful = 0
        failed = 0
        total = len(accounts)
        progress_msg = await context.bot.send_message(
            ADMIN_ID,
            f"ğŸ”„ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© {total} Ø­Ø³Ø§Ø¨...\n"
            f"ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0/{total}"
        )
        for i, account in enumerate(accounts):
            session = account.get('s', '')
            phone = account.get('phone', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            if not session:
                failed += 1
                continue
            try:
                result = await leave_chats(session)
                if result:
                    successful += 1
                else:
                    failed += 1
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ù„Ù„Ø­Ø³Ø§Ø¨ {phone}: {e}")
                failed += 1
            if (i + 1) % 5 == 0 or (i + 1) == total:
                try:
                    await progress_msg.edit_text(
                        f"ğŸ”„ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© {total} Ø­Ø³Ø§Ø¨...\n"
                        f"ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {i + 1}/{total}\n"
                        f"âœ… Ù†Ø¬Ø­: {successful}\n"
                        f"âŒ ÙØ´Ù„: {failed}"
                    )
                except:
                    pass
            await asyncio.sleep(2)
        final_message = (
            f"âœ… ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª!\n\n"
            f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:\n"
            f"ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª: {total}\n"
            f"âœ… Ù†Ø¬Ø­: {successful}\n"
            f"âŒ ÙØ´Ù„: {failed}\n"
            f"ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: {self.format_time_12h(datetime.now())}"
        )
        await progress_msg.edit_text(
            final_message,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (ğŸ”™)", callback_data="admin_settings")]])
        )
    async def handle_channel_report(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        channel_id = data.split("_")[2]
        user_id = update.effective_user.id
        if channel_id not in self.paid_channels:
            return
        channel_info = self.paid_channels[channel_id]
        self.pending_reports[str(user_id)] = {
            "channel_id": channel_id,
            "channel_name": channel_info['name'],
            "reporter_id": user_id
        }
        keyboard = [
            [InlineKeyboardButton("Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©ğŸ”¦", callback_data=f"report_reason_not_found")],
            [InlineKeyboardButton("Ù…Ø­ØªÙˆÙ‰ Ø§Ø¨Ø§Ø­ÙŠ ğŸ”", callback_data=f"report_reason_adult_content")],
            [InlineKeyboardButton("Ù…Ø­ØªÙˆÙ‰ Ø·Ø§Ø¦ÙÙŠ Ø£Ùˆ Ø¹Ù†Ù âš ï¸â˜£ï¸", callback_data=f"report_reason_sectarian_violence")],
            [InlineKeyboardButton("Ø³Ø¨Ø¨ Ø¢Ø®Ø± âœï¸", callback_data="report_other_reason")],
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="collect_bulk")]
        ]
        await update.callback_query.edit_message_text(
            f"âš ï¸ Ø¥Ø¨Ù„Ø§Øº Ø¹Ù† Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_info['name']}\n\n"
            f"ğŸ“ Ø§Ø®ØªØ± Ø³Ø¨Ø¨ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def handle_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        await self.process_report_reason(update, context, data, is_bot_report=False)
    async def handle_bot_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        await self.process_report_reason(update, context, data, is_bot_report=True)
    async def process_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data, is_bot_report=False):
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        if user_id_str not in self.pending_reports:
            return
        report_data = self.pending_reports[user_id_str]
        reason_map = {
            "report_reason_not_found": "Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©",
            "report_bot_reason_not_found": "Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©",
            "report_reason_adult_content": "Ù…Ø­ØªÙˆÙ‰ Ø§Ø¨Ø§Ø­ÙŠ",
            "report_bot_reason_adult_content": "Ù…Ø­ØªÙˆÙ‰ Ø§Ø¨Ø§Ø­ÙŠ",
            "report_reason_sectarian_violence": "Ù…Ø­ØªÙˆÙ‰ Ø·Ø§Ø¦ÙÙŠ Ø£Ùˆ Ø¹Ù†Ù",
            "report_bot_reason_sectarian_violence": "Ù…Ø­ØªÙˆÙ‰ Ø·Ø§Ø¦ÙÙŠ Ø£Ùˆ Ø¹Ù†Ù"
        }
        reason = reason_map.get(data, "Ø³Ø¨Ø¨ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ")
        report_data["reason"] = reason
        if is_bot_report:
            await self.send_bot_report_to_admin(update, context, report_data)
        else:
            await self.send_report_to_admin(update, context, report_data)
    async def handle_other_reason_request(self, update: Update, context: ContextTypes.DEFAULT_TYPE, is_bot_report=False):
        cancel_callback = "bot_subscription" if is_bot_report else "collect_bulk"
        waiting_for = 'custom_bot_report_reason' if is_bot_report else 'custom_report_reason'
        keyboard = [
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data=cancel_callback)]
        ]
        await update.callback_query.edit_message_text(
            f"âœï¸ Ø§ÙƒØªØ¨ Ø³Ø¨Ø¨ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        context.user_data['waiting_for'] = waiting_for
    async def handle_custom_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text, is_bot_report=False):
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        if user_id_str not in self.pending_reports:
            await update.message.reply_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!")
            return
        report_data = self.pending_reports[user_id_str]
        report_data["reason"] = f"Ø³Ø¨Ø¨ Ø¢Ø®Ø±: {reason_text}"
        context.user_data['waiting_for'] = None
        if is_bot_report:
            await self.send_bot_report_to_admin(update, context, report_data)
        else:
            await self.send_report_to_admin(update, context, report_data)
    async def handle_custom_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text):
        await self.handle_custom_reason(update, context, reason_text, is_bot_report=False)
    async def handle_custom_bot_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text):
        await self.handle_custom_reason(update, context, reason_text, is_bot_report=True)

    async def send_report_to_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE, report_data):
        try:
            reporter_id = report_data["reporter_id"]
            channel_id = report_data["channel_id"]
            channel_name = report_data["channel_name"]
            reason = report_data["reason"]

            channel_info = self.paid_channels.get(channel_id, {})
            try:
                user_chat = await context.bot.get_chat(reporter_id)
                reporter_name = user_chat.first_name or "Ù…Ø³ØªØ®Ø¯Ù…"
                reporter_username = f"@{user_chat.username}" if user_chat.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
            except:
                reporter_name = "Ù…Ø³ØªØ®Ø¯Ù…"
                reporter_username = "Ù„Ø§ ÙŠÙˆØ¬Ø¯"

            report_id = f"{reporter_id}_{channel_id}_{int(datetime.now().timestamp())}"

            keyboard = [
                [
                    InlineKeyboardButton("Ø¯Ø®ÙˆÙ„ ğŸ”—", url=channel_info.get('invite_link', '#')),
                    InlineKeyboardButton("Ø­Ø°Ù âŒ", callback_data=f"admin_report_delete_{report_id}")
                ],
                [
                    InlineKeyboardButton("Ø¥Ø¨Ù„Ø§Øº Ù†Ø§Ø¬Ø­ ÙˆØ­Ø°Ù âœ…", 
                                       callback_data=f"admin_report_action_delete_{report_id}"),
                    InlineKeyboardButton("Ø¥Ø¨Ù„Ø§Øº Ù†Ø§Ø¬Ø­ Ø¨Ø¯ÙˆÙ† Ø­Ø°Ù âš ï¸", 
                                       callback_data=f"admin_report_action_keep_{report_id}")
                ]
            ]
            self.pending_reports[report_id] = {
                **report_data,
                "report_id": report_id,
                "report_time": str(datetime.now())
            }
            admin_message = (
                f"ğŸš¨ ØªÙ‚Ø±ÙŠØ± Ø¥Ø¨Ù„Ø§Øº Ø¬Ø¯ÙŠØ¯\n\n"
                f"ğŸ‘¤ Ø§Ù„Ù…Ø¨Ù„Øº: {reporter_name}\n"
                f"ğŸ“ Ø§Ù„ÙŠÙˆØ²Ø±: {reporter_username}\n"
                f"ğŸ†” Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø¨Ù„Øº: {reporter_id}\n\n"
                f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ù…Ø¨Ù„Øº Ø¹Ù†Ù‡Ø§: {channel_name}\n"
                f"ğŸ†” Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_id}\n"
                f"âš ï¸ Ø³Ø¨Ø¨ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº: {reason}\n\n"
                f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ø¥Ø¨Ù„Ø§Øº: {self.format_time_12h(datetime.now())}"
            )
            await context.bot.send_message(
                ADMIN_ID,
                admin_message,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            success_message = (
                f"âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_name}\n"
                f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n\n"
                f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø¹Ø¯ØªÙ†Ø§ ÙÙŠ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ğŸ™"
            )
            if hasattr(update, 'callback_query') and update.callback_query:
                await update.callback_query.edit_message_text(success_message)
            else:
                await update.message.reply_text(success_message)
            if not hasattr(self, 'user_reports'):
                self.user_reports = {}
            reporter_id_str = str(reporter_id)
            if reporter_id_str not in self.user_reports:
                self.user_reports[reporter_id_str] = {'bots': set(), 'channels': set()}
            self.user_reports[reporter_id_str]['channels'].add(channel_id)
            if str(reporter_id) in self.pending_reports:
                del self.pending_reports[str(reporter_id)]
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")
            await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ±!")
    async def handle_admin_report_delete(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        report_id = data.split("admin_report_delete_")[1]
        if report_id not in self.pending_reports:
            await update.callback_query.edit_message_text("âŒ Ø§Ù„ØªÙ‚Ø±ÙŠØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯!")
            return
        report_data = self.pending_reports[report_id]
        channel_id = report_data["channel_id"]
        channel_name = report_data["channel_name"]
        if channel_id in self.paid_channels:
            del self.paid_channels[channel_id]
            self.save_data_to_db('paid_channels', self.paid_channels)
        if channel_id in self.funded_channels:
            del self.funded_channels[channel_id]
            self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)
        await update.callback_query.edit_message_text(
            f"âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ù‚Ù†Ø§Ø© '{channel_name}' Ù…Ù† Ø§Ù„Ù…Ø¯ÙÙˆØ¹!\n\n"
            f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ø­Ø°Ù: {self.format_time_12h(datetime.now())}"
        )
        del self.pending_reports[report_id]
    async def handle_admin_report_action(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        if update.effective_user.id != ADMIN_ID:
            return
        parts = data.split("_")
        action = parts[3]  # delete Ø£Ùˆ keep
        report_id = "_".join(parts[4:])  # Ø¨Ø§Ù‚ÙŠ Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø±Ù
        if report_id not in self.pending_reports:
            await update.callback_query.edit_message_text("âŒ Ø§Ù„ØªÙ‚Ø±ÙŠØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ ØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ù…Ù† Ù‚Ø¨Ù„!")
            return
        report_data = self.pending_reports[report_id]
        reporter_id = report_data["reporter_id"]
        report_type = report_data.get("type", "channel")
        reason = report_data["reason"]
        reporter_user = self.get_user(reporter_id)
        reporter_user['points'] += 100

        try:
            if report_type == "bot":
                bot_id = report_data["bot_id"]
                bot_name = report_data["bot_name"]
                if action == "delete":
                    if bot_id in self.paid_bots:
                        del self.paid_bots[bot_id]
                        self.save_json(PAID_BOTS_FILE, self.paid_bots)
                    if bot_id in self.funded_bots:
                        del self.funded_bots[bot_id]
                        self.save_json(FUNDED_BOTS_FILE, self.funded_bots)
                    await context.bot.send_message(
                        reporter_id,
                        f"âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø¥Ø¨Ù„Ø§ØºÙƒ ÙˆØ­Ø°Ù Ø§Ù„Ø¨ÙˆØª!\n\n"
                        f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: {bot_name}\n"
                        f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n"
                        f"ğŸ ØªÙ… Ù…Ù†Ø­Ùƒ 100 ÙƒÙˆÙƒÙŠØ² ÙƒÙ…ÙƒØ§ÙØ£Ø©!\n"
                        f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(reporter_user['points'])} ğŸª\n\n"
                        f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø¹Ø¯ØªÙ†Ø§ ÙÙŠ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰! ğŸ™"
                    )
                    await update.callback_query.edit_message_text(
                        f"âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº ÙˆØ­Ø°Ù Ø§Ù„Ø¨ÙˆØª!\n\n"
                        f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù…Ø­Ø°ÙˆÙ: {bot_name}\n"
                        f"ğŸ‘¤ Ø§Ù„Ù…Ø¨Ù„Øº: {reporter_id}\n"
                        f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n"
                        f"ğŸ ØªÙ… Ù…Ù†Ø­ Ø§Ù„Ù…Ø¨Ù„Øº 100 ÙƒÙˆÙƒÙŠØ²\n"
                        f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: {self.format_time_12h(datetime.now())}"
                    )
                elif action == "keep":
                    await context.bot.send_message(
                        reporter_id,
                        f"âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø¥Ø¨Ù„Ø§ØºÙƒ!\n\n"
                        f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: {bot_name}\n"
                        f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n"
                        f"ğŸ ØªÙ… Ù…Ù†Ø­Ùƒ 100 ÙƒÙˆÙƒÙŠØ² ÙƒÙ…ÙƒØ§ÙØ£Ø©!\n"
                        f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(reporter_user['points'])} ğŸª\n\n"
                        f"ØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ ÙˆØ´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙ‚Ø¸Ø©! ğŸ™"
                    )
                    await update.callback_query.edit_message_text(
                        f"âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº Ø¨Ø¯ÙˆÙ† Ø­Ø°Ù!\n\n"
                        f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: {bot_name}\n"
                        f"ğŸ‘¤ Ø§Ù„Ù…Ø¨Ù„Øº: {reporter_id}\n"
                        f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n"
                        f"ğŸ ØªÙ… Ù…Ù†Ø­ Ø§Ù„Ù…Ø¨Ù„Øº 100 ÙƒÙˆÙƒÙŠØ²\n"
                        f"â„¹ï¸ ØªÙ… Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ø¨ÙˆØª\n"
                        f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: {self.format_time_12h(datetime.now())}"
                    )
            else:  # channel report
                channel_id = report_data["channel_id"]
                channel_name = report_data["channel_name"]
                if action == "delete":
                    if channel_id in self.paid_channels:
                        del self.paid_channels[channel_id]
                        self.save_data_to_db('paid_channels', self.paid_channels)
                    if channel_id in self.funded_channels:
                        del self.funded_channels[channel_id]
                        self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)
                    await context.bot.send_message(
                        reporter_id,
                        f"âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø¥Ø¨Ù„Ø§ØºÙƒ ÙˆØ­Ø°Ù Ø§Ù„Ù‚Ù†Ø§Ø©!\n\n"
                        f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_name}\n"
                        f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n"
                        f"ğŸ ØªÙ… Ù…Ù†Ø­Ùƒ 100 ÙƒÙˆÙƒÙŠØ² ÙƒÙ…ÙƒØ§ÙØ£Ø©!\n"
                        f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(reporter_user['points'])} ğŸª\n\n"
                        f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø¹Ø¯ØªÙ†Ø§ ÙÙŠ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰! ğŸ™"
                    )
                    await update.callback_query.edit_message_text(
                        f"âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº ÙˆØ­Ø°Ù Ø§Ù„Ù‚Ù†Ø§Ø©!\n\n"
                        f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ù…Ø­Ø°ÙˆÙØ©: {channel_name}\n"
                        f"ğŸ‘¤ Ø§Ù„Ù…Ø¨Ù„Øº: {reporter_id}\n"
                        f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n"
                        f"ğŸ ØªÙ… Ù…Ù†Ø­ Ø§Ù„Ù…Ø¨Ù„Øº 100 ÙƒÙˆÙƒÙŠØ²\n"
                        f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: {self.format_time_12h(datetime.now())}"
                    )
                elif action == "keep":
                    await context.bot.send_message(
                        reporter_id,
                        f"âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø¥Ø¨Ù„Ø§ØºÙƒ!\n\n"
                        f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_name}\n"
                        f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n"
                        f"ğŸ ØªÙ… Ù…Ù†Ø­Ùƒ 100 ÙƒÙˆÙƒÙŠØ² ÙƒÙ…ÙƒØ§ÙØ£Ø©!\n"
                        f"ğŸ’° Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {self.format_points(reporter_user['points'])} ğŸª\n\n"
                        f"ØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ ÙˆØ´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙ‚Ø¸Ø©! ğŸ™"
                    )
                    await update.callback_query.edit_message_text(
                        f"âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº Ø¨Ø¯ÙˆÙ† Ø­Ø°Ù!\n\n"
                        f"ğŸ“º Ø§Ù„Ù‚Ù†Ø§Ø©: {channel_name}\n"
                        f"ğŸ‘¤ Ø§Ù„Ù…Ø¨Ù„Øº: {reporter_id}\n"
                        f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n"
                        f"ğŸ ØªÙ… Ù…Ù†Ø­ Ø§Ù„Ù…Ø¨Ù„Øº 100 ÙƒÙˆÙƒÙŠØ²\n"
                        f"â„¹ï¸ ØªÙ… Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ù‚Ù†Ø§Ø©\n"
                        f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: {self.format_time_12h(datetime.now())}"
                    )
            del self.pending_reports[report_id]
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ±: {e}")
            await update.callback_query.edit_message_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ±: {str(e)}")
    async def handle_bot_report(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        bot_id = data.split("_")[2]
        user_id = update.effective_user.id
        if bot_id not in self.paid_bots:
            await update.callback_query.answer("âŒ Ø§Ù„Ø¨ÙˆØª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯!", show_alert=True)
            return
        bot_info = self.paid_bots[bot_id]
        self.pending_reports[str(user_id)] = {
            "bot_id": bot_id,
            "bot_name": bot_info['name'],
            "bot_username": bot_info['username'],
            "reporter_id": user_id,
            "type": "bot"
        }
        keyboard = [
            [InlineKeyboardButton("Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©ğŸ”¦", callback_data=f"report_bot_reason_not_found")],
            [InlineKeyboardButton("Ù…Ø­ØªÙˆÙ‰ Ø§Ø¨Ø§Ø­ÙŠ ğŸ”", callback_data=f"report_bot_reason_adult_content")],
            [InlineKeyboardButton("Ù…Ø­ØªÙˆÙ‰ Ø·Ø§Ø¦ÙÙŠ Ø£Ùˆ Ø¹Ù†Ù âš ï¸â˜£ï¸", callback_data=f"report_bot_reason_sectarian_violence")],
            [InlineKeyboardButton("Ø³Ø¨Ø¨ Ø¢Ø®Ø± âœï¸", callback_data="report_bot_other_reason")],
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="bot_subscription")]
        ]
        await update.callback_query.edit_message_text(
            f"âš ï¸ Ø¥Ø¨Ù„Ø§Øº Ø¹Ù† Ø§Ù„Ø¨ÙˆØª: {bot_info['name']}\n\n"
            f"ğŸ“ Ø§Ø®ØªØ± Ø³Ø¨Ø¨ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def handle_bot_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        await self.process_report_reason(update, context, data, is_bot_report=True)
    async def handle_other_reason_request(self, update: Update, context: ContextTypes.DEFAULT_TYPE, is_bot_report=False):
        """Ø¯Ø§Ù„Ø© Ù…ÙˆØ­Ø¯Ø© Ù„Ø·Ù„Ø¨ Ø³Ø¨Ø¨ Ù…Ø®ØµØµ"""
        cancel_callback = "bot_subscription" if is_bot_report else "collect_bulk"
        waiting_for = 'custom_bot_report_reason' if is_bot_report else 'custom_report_reason'
        keyboard = [
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data=cancel_callback)]
        ]
        await update.callback_query.edit_message_text(
            f"âœï¸ Ø§ÙƒØªØ¨ Ø³Ø¨Ø¨ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        context.user_data['waiting_for'] = waiting_for
    async def handle_custom_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text, is_bot_report=False):
        """Ø¯Ø§Ù„Ø© Ù…ÙˆØ­Ø¯Ø© Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ù…Ø®ØµØµ"""
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        if user_id_str not in self.pending_reports:
            await update.message.reply_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!")
            return
        report_data = self.pending_reports[user_id_str]
        report_data["reason"] = f"Ø³Ø¨Ø¨ Ø¢Ø®Ø±: {reason_text}"
        context.user_data['waiting_for'] = None
        if is_bot_report:
            await self.send_bot_report_to_admin(update, context, report_data)
        else:
            await self.send_report_to_admin(update, context, report_data)
    async def handle_custom_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text):
        await self.handle_custom_reason(update, context, reason_text, is_bot_report=False)
    async def handle_custom_bot_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text):
        await self.handle_custom_reason(update, context, reason_text, is_bot_report=True)
    async def send_bot_report_to_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE, report_data):
        try:
            reporter_id = report_data["reporter_id"]
            bot_id = report_data["bot_id"]
            bot_name = report_data["bot_name"]
            bot_username = report_data["bot_username"]
            reason = report_data["reason"]
            try:
                user_chat = await context.bot.get_chat(reporter_id)
                reporter_name = user_chat.first_name or "Ù…Ø³ØªØ®Ø¯Ù…"
                reporter_username = f"@{user_chat.username}" if user_chat.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
            except:
                reporter_name = "Ù…Ø³ØªØ®Ø¯Ù…"
                reporter_username = "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
            report_id = f"{reporter_id}_{bot_id}_{int(datetime.now().timestamp())}"
            keyboard = [
                [
                    InlineKeyboardButton("Ø¥Ø¨Ù„Ø§Øº Ù†Ø§Ø¬Ø­ ÙˆØ­Ø°Ù âœ…", 
                                       callback_data=f"admin_report_action_delete_{report_id}"),
                    InlineKeyboardButton("Ø¥Ø¨Ù„Ø§Øº Ù†Ø§Ø¬Ø­ Ø¨Ø¯ÙˆÙ† Ø­Ø°Ù âš ï¸", 
                                       callback_data=f"admin_report_action_keep_{report_id}")
                ]
            ]
            self.pending_reports[report_id] = {
                **report_data,
                "report_id": report_id,
                "report_time": str(datetime.now())
            }
            admin_message = (
                f"ğŸš¨ ØªÙ‚Ø±ÙŠØ± Ø¥Ø¨Ù„Ø§Øº Ø¬Ø¯ÙŠØ¯ Ø¹Ù† Ø¨ÙˆØª\n\n"
                f"ğŸ‘¤ Ø§Ù„Ù…Ø¨Ù„Øº: {reporter_name}\n"
                f"ğŸ“ Ø§Ù„ÙŠÙˆØ²Ø±: {reporter_username}\n"
                f"ğŸ†” Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø¨Ù„Øº: {reporter_id}\n\n"
                f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù…Ø¨Ù„Øº Ø¹Ù†Ù‡: {bot_name}\n"
                f"ğŸ“ ÙŠÙˆØ²Ø±Ù†ÙŠÙ… Ø§Ù„Ø¨ÙˆØª: @{bot_username}\n"
                f"ğŸ†” Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ø¨ÙˆØª: {bot_id}\n"
                f"âš ï¸ Ø³Ø¨Ø¨ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº: {reason}\n\n"
                f"ğŸ“… ÙˆÙ‚Øª Ø§Ù„Ø¥Ø¨Ù„Ø§Øº: {self.format_time_12h(datetime.now())}"
            )
            await context.bot.send_message(
                ADMIN_ID,
                admin_message,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            success_message = (
                f"âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: {bot_name}\n"
                f"âš ï¸ Ø§Ù„Ø³Ø¨Ø¨: {reason}\n\n"
                f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø¹Ø¯ØªÙ†Ø§ ÙÙŠ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ğŸ™"
            )
            if hasattr(update, 'callback_query') and update.callback_query:
                await update.callback_query.edit_message_text(success_message)
            else:
                await update.message.reply_text(success_message)
            if not hasattr(self, 'user_reports'):
                self.user_reports = {}
            reporter_id_str = str(reporter_id)
            if reporter_id_str not in self.user_reports:
                self.user_reports[reporter_id_str] = {'bots': set(), 'channels': set()}
            self.user_reports[reporter_id_str]['bots'].add(bot_id)
            if str(reporter_id) in self.pending_reports:
                del self.pending_reports[str(reporter_id)]
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø£Ø¯Ù…Ù†: {e}")
            await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ±!")
def main():
    bot = TelegramBot()
    app = Application.builder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", bot.start))
    app.add_handler(CallbackQueryHandler(bot.handle_callback))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_message))
    print("ğŸš€ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")
    try:
        app.run_polling(allowed_updates=Update.ALL_TYPES)
    except KeyboardInterrupt:
        print("ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª...")
        bot.cre+ate_backup()
        bot.stop_auto_backup()
        bot.stop_admin_check() 


    def update_user_activity(self, user_id):
        """ØªØ­Ø¯ÙŠØ« Ù†Ø´Ø§Ø· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        user_id_str = str(user_id)
        if user_id_str in self.users:
            self.users[user_id_str]["last_activity"] = str(datetime.now())
            self.save_user_to_db(user_id, self.users[user_id_str])

async def delayed_save_data(self):
    """Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¤Ø¬Ù„"""
    if not hasattr(self, '_data_save_pending'):
        self._data_save_pending = True
        await asyncio.sleep(2)
        try:
            await asyncio.gather(
                asyncio.to_thread(self.save_data_to_db, 'users', self.users),
                asyncio.to_thread(self.save_data_to_db, 'user_channel_subscriptions', self.user_channel_subscriptions)
            )
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù…Ø¤Ø¬Ù„: {e}")
        finally:
            if hasattr(self, '_data_save_pending'):
                del self._data_save_pending


async def main():
    """Ø¯Ø§Ù„Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    bot = TelegramBot()

    try:
        app = Application.builder().token(BOT_TOKEN).build()

        app.add_handler(CommandHandler("start", bot.start))
        app.add_handler(CallbackQueryHandler(bot.handle_callback))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_message))

        print("ğŸ¤– Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")
        await app.run_polling(drop_pending_updates=True)

    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}")
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}")
    finally:
        if hasattr(bot, 'stop_admin_check'):
            bot.stop_admin_check()
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nğŸ›‘ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}")
