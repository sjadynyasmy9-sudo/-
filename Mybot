import asyncio
import json
import os
import logging
import hashlib
import secrets
import threading
import time
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (Application, CommandHandler, CallbackQueryHandler,MessageHandler, filters, ContextTypes)
from datetime import datetime, timedelta
from database import DatabaseManager
try:
    from apis import (poll, send_comments_multiple, get_working_accounts_for_comments, 
                     get_active_accounts_count, get_working_accounts, SimpleDB)
    from apis import *
except ImportError:
    def poll(*args, **kwargs):
        return {"success": False, "message": "APIs module not available"}
    def send_comments_multiple(*args, **kwargs):
        return {"success": False, "message": "APIs module not available"}

    def get_working_accounts_for_comments(*args, **kwargs):
        return []

    def get_active_accounts_count(*args, **kwargs):
        return 0

    def get_working_accounts(*args, **kwargs):
        return []
    class SimpleDB:
        def __init__(self, filename):
            self.data = {}

        def get(self, key, default=None):
            return self.data.get(key, default)

        def set(self, key, value):
            self.data[key] = value


db = SimpleDB('simple_data.json')

try:
    import pytz
except ImportError:
    print("تحذير: مكتبة pytz غير مثبتة، سيتم استخدام التوقيت المحلي")

try:
    with open('config.json', 'r', encoding='utf-8') as f:
        w = json.load(f)

    token = w['bot_token']
    stypes = ['member', 'administrator', 'creator']
    member_price = w['prices']['member']
    vote_price = w['prices']['vote']
    link_price = w['prices']['link']
    spam_price = w['prices']['spam']
    react_price = w['prices']['react']
    forward_price = w['prices']['forward']
    view_price = w['prices']['view']
    reaction_price = 6  # سعر التفاعل الواحد
    poll_price = w['prices']['poll']
    userbot_price = w['prices']['userbot']
    linkbot_price = w['prices']['linkbot']
    comment_price = w['prices']['comments']
    linkbot2_price = w['prices']['linkbot2']
    userbot_rush_price = 26
    print("تم تحميل الإعدادات بنجاح")

except Exception as e:
    print(f"خطأ في تحميل config.json: {e}")
    member_price = 12
    vote_price = 5
    link_price = 10
    spam_price = 8
    react_price = 3
    forward_price = 6
    view_price = 2
    poll_price = 50
    reaction_price = 6
    userbot_price = 15
    linkbot_price = 20
    comment_price = 9
    linkbot2_price = 25
    userbot_rush_price = 26
db_manager = DatabaseManager('bot_data.db')
print("SQLite Database System initialized successfully")
def force(channel, userid):
    try:
        x = bot.get_chat_member(channel, userid)
        print(x)
    except:
        return True
    if str(x.status) in stypes:
        print(x)
        return True
    else:
        print(x)
        return False
def addord():
    if not db.get('orders'):
        db.set('orders', 1)
        return True
    else:
        d = db.get('orders')
        d += 1
        db.set('orders', d)
        return True
logging.basicConfig(
    format='%(levelname)s - %(message)s',
    level=logging.WARNING
)
logger = logging.getLogger(__name__)
BOT_TOKEN = "7905405670:AAH9H_RgQYyDLJSj3Ok3mRtELph9zlpWmQU"
ADMIN_ID = 7043243383
MEMBER_PRICE = 12
class TelegramBot:
    def __init__(self):
        self.user_mandatory_messages = {}
        self.db = db_manager
        self.users = self.db.get_all_users()
        self.invite_points = self.db.get_setting('invite_points', 0.75)
        self.mandatory_enabled = self.db.get_setting('mandatory_enabled', True)
        self.member_price = self.db.get_setting('member_price', 8)
        self.bot_member_price = self.db.get_setting('bot_member_price', 30)
        self.wheel_spin_cost = self.db.get_setting('wheel_spin_cost', 500)
        self.min_funding_members = self.db.get_setting('min_funding_members', 50)
        self.daily_gift_amount = self.db.get_setting('daily_gift_amount', 100)
        self.wheel_gift_first = "🍪³¹⁰⁰"
        self.wheel_gift_second = "🍪²⁵⁰⁰"
        self.wheel_prizes = ["🍪³¹⁰⁰", "🍪²⁵⁰⁰", "🍪²⁰⁰⁰", "🍪¹⁵⁰⁰", "🍪¹⁰⁰⁰", "🍪⁵⁰⁰"]
        self.stars_prices = {
            15: 15000,
            25: 25000,
            50: 50000,
            100: 100000,
            200: 200000,
            300: 300000
        }
        self.mandatory_channels = self.db.get_mandatory_channels()
        self.paid_channels = self.db.get_paid_channels()
        self.user_channel_subscriptions = self.db.get_user_channel_subscriptions()
        self.invites = self.db.get_invites()
        self.gifts = {}
        self.banned_users = self.db.get_banned_users()
        self.gift_links = self.db.get_gift_links()
        self.gift_codes = {}
        self.top_referrers = []
        self.monitored_channels = {}
        self.mandatory_subscriptions = {}
        self.funded_channels = self.db.get_funded_channels()
        self.daily_gifts = {}
        self.stars_purchases = {}
        self.paid_bots = self.db.get_paid_bots()
        self.funded_bots = {}
        self.user_bot_subscriptions = {}
        self.funding_numbers = self.db.get_funding_numbers()
        self.completed_fundings = {"channels": {}, "bots": {}}
        logger.info("تم تحميل جميع البيانات من قاعدة البيانات SQLite بنجاح")
        self.user_cooldown = {}
        self.cooldown_time = 1
        self.pending_saves = {}
        self.save_delay = 2
        self.pending_checks = {}
        self.check_delay = 30
        self.user_purchases = {}
        self.wheel_spins = {}
        self.maintenance_mode = {
            "fund_channel": False,
            "invite_link": False,
            "collect_stars": False,
            "wheel_luck": False,
            "stars_section": False,
            "rush_services": False,
        }
        self.maintenance_messages = {
            "fund_channel": "🔧 زر تمويل القناة تحت الصيانة\n\nنعتذر عن الإزعاج، سيتم استئناف الخدمة قريباً",
            "invite_link": "🔧 زر رابط الدعوة تحت الصيانة\n\nنعتذر عن الإزعاج، سيتم استئناف الخدمة قريباً",
            "collect_stars": "🔧 زر تجميع الكوكيز تحت الصيانة\n\nنعتذر عن الإزعاج، سيتم استئناف الخدمة قريباً",
            "wheel_luck": "🔧 زر عجلة الحظ تحت الصيانة\n\nنعتذر عن الإزعاج، سيتم استئناف الخدمة قريباً",
            "stars_section": "🔧 زر قسم النجوم تحت الصيانة\n\nنعتذر عن الإزعاج، سيتم استئناف الخدمة قريباً",
            "rush_services": "🔧 زر قسم خدمات الرشق تحت الصيانة\n\nنعتذر عن الإزعاج، سيتم استئناف الخدمة قريباً",
        }
        self.admin_check_running = False
        self.admin_check_thread = None
        self.start_admin_check()

        self.pending_reports = {}  # تخزين التقارير المؤقتة
        self.user_reports = {}  # تتبع التقارير السابقة للمستخدمين
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not update.message or not update.effective_user:
            return
        if update.message.chat.type != 'private':
            return
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        await self.delete_old_mandatory_message(context, user_id)
        if user_id_str in self.banned_users:
            await update.message.reply_text(
                "تم حظرك من البوت من قبل الإدارة اذا كان هذا عن طريق الخطأ تواصل مع الإدارة @cxxov"
            )
            return
        if user_id != ADMIN_ID:
            on_cooldown, remaining_time = self.is_on_cooldown(user_id)
            if on_cooldown:
                return
        waiting_for = context.user_data.get('waiting_for')

        text = update.message.text if update.message.text else ""

        if waiting_for == 'use_gift_code':
            await self.handle_gift_code_usage(update, context, text)
            return
        elif waiting_for in ['transfer_target_id', 'transfer_amount']:
            if waiting_for == 'transfer_target_id':
                await self.handle_transfer_target_id(update, context, text)
            elif waiting_for == 'transfer_amount':
                await self.handle_transfer_amount(update, context, text)
            return
        elif waiting_for == 'fund_channel_members':
            await self.handle_fund_channel_members_input(update, context, text)
            return
        elif waiting_for == 'fund_channel_username':
            await self.handle_fund_channel_username_input(update, context, text)
            return

        # Admin-only message handlers
        if waiting_for and user_id == ADMIN_ID:
            if waiting_for == 'broadcast_message':
                await self.handle_broadcast_message(update, context, text)
            elif waiting_for == 'mandatory_channel_username':
                await self.handle_mandatory_channel_username(update, context, text)
            elif waiting_for == 'mandatory_channel_members':
                await self.handle_mandatory_channel_members(update, context, text)
            elif waiting_for == 'mandatory_channel_invite':
                await self.handle_mandatory_channel_invite(update, context, text)
            elif waiting_for == 'user_info_admin_id':
                await self.handle_user_info_admin(update, context, text)
            elif waiting_for == 'ban_user_id':
                await self.handle_ban_user(update, context, text)
            elif waiting_for == 'unban_user_id':
                await self.handle_unban_user(update, context, text)

    def save_data_to_db(self, data_type, data):
        try:
            if data_type == 'users':
                pass  # لا حاجة لحفظ في JSON، فقط SQLite
            elif data_type == 'mandatory_channels':
                self.db.save_mandatory_channels(data)
            elif data_type == 'paid_channels':
                self.db.save_paid_channels(data)
            elif data_type == 'user_channel_subscriptions':
                self.db.save_user_channel_subscriptions(data)
            elif data_type == 'gift_links':
                self.db.save_gift_links(data)
            elif data_type == 'funded_channels':
                self.db.save_funded_channels(data)
            elif data_type == 'funding_numbers':
                self.db.save_funding_numbers(data)
            elif data_type == 'paid_bots':
                self.db.save_paid_bots(data)
            elif data_type == 'banned_users':
                self.db.save_banned_users(data)
            elif data_type == 'invites':
                self.db.save_invites(data)
            else:
                self.db.set_setting(data_type, data, 'json')

            logger.debug(f"Data saved to database: {data_type}")
            return True

        except Exception as e:
            logger.error(f"خطأ في حفظ البيانات {data_type}: {e}")
            return False
        try:
            if filename == MANDATORY_CHANNELS_FILE or 'mandatory_channels' in filename:
                self.db.save_mandatory_channels(data)
            elif filename == PAID_CHANNELS_FILE or 'paid_channels' in filename:
                self.db.save_paid_channels(data)
            elif filename == USER_CHANNEL_SUBSCRIPTION_FILE or 'user_channel_subscription' in filename:
                self.db.save_user_channel_subscriptions(data)
            elif filename == GIFT_LINKS_FILE or 'gift_links' in filename:
                self.db.save_gift_links(data)
            elif filename == FUNDED_CHANNELS_FILE or 'funded_channels' in filename:
                self.db.save_funded_channels(data)
            elif filename == FUNDING_NUMBERS_FILE or 'funding_numbers' in filename:
                self.db.save_funding_numbers(data)
            elif filename == PAID_BOTS_FILE or 'paid_bots' in filename:
                self.db.save_paid_bots(data)
            elif filename == BANNED_USERS_FILE or 'banned_users' in filename:
                self.db.save_banned_users(data)
            elif filename == INVITES_FILE or 'invites' in filename:
                self.db.save_invites(data)
            else:
                setting_key = os.path.basename(filename).replace('.json', '')
                self.db.set_setting(setting_key, data, 'json')
            logger.debug(f"Data saved to database instead of {filename}")
            return True
        except Exception as e:
            logger.error(f"خطأ في حفظ البيانات من {filename}: {e}")
            return False
    def save_user_to_db(self, user_id, user_data=None):
        """حفظ بيانات المستخدم إلى قاعدة البيانات المحسنة"""
        try:
            if user_data is None:
                user_data = self.users.get(str(user_id))
            if user_data:
                success = self.db.save_user(user_id, user_data)
                return success
            return False
        except Exception as e:
            logger.error(f"خطأ في حفظ المستخدم {user_id}: {e}")
            return False
    def update_data_in_memory_and_db(self):
        """تحديث البيانات في الذاكرة وقاعدة البيانات"""
        try:
            self.mandatory_channels = self.db.get_mandatory_channels()
            self.paid_channels = self.db.get_paid_channels()
            self.user_channel_subscriptions = self.db.get_user_channel_subscriptions()
            self.invites = self.db.get_invites()
            self.banned_users = self.db.get_banned_users()
            self.gift_links = self.db.get_gift_links()
            self.funded_channels = self.db.get_funded_channels()
            self.funding_numbers = self.db.get_funding_numbers()
            self.paid_bots = self.db.get_paid_bots()
            return True
        except Exception as e:
            logger.error(f"خطأ في تحديث البيانات: {e}")
            return False

    def save_users_to_db_only(self):
        """حفظ المستخدمين في SQLite فقط"""
        try:
            for user_id, user_data in self.users.items():
                self.db.save_user(user_id, user_data)
        except Exception as e:
            logger.error(f"خطأ في حفظ المستخدمين: {e}")

    def format_time_12h(self, dt_obj):
        return dt_obj.strftime('%I:%M %p').replace('AM', 'ص').replace('PM', 'م')

    def escape_markdown(self, text):
        if not text:
            return "غير متاح"
        text = str(text)
        escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
        for char in escape_chars:
            text = text.replace(char, f'\\{char}')
        return text

    def get_user(self, user_id):
        user_data = self.db.get_user(user_id)
        if not user_data:
            user_data = {
                "points": 0.0,
                "stars_bought": 0,
                "joined_date": str(datetime.now()),
                "invite_link": self.generate_invite_link(user_id),
                "banned": False,
                "used_invite": None,
                "first_join": True,
                "completed_mandatory": False,
                "referrals_count": 0,
                "last_activity": str(datetime.now()),
                "funded_channels": [],
                "funded_bots": []
            }
            self.db.save_user(user_id, user_data)
            self.users[str(user_id)] = user_data
        else:
            self.users[str(user_id)] = user_data
        return self.users[str(user_id)]

    def generate_invite_link(self, user_id):
        return str(user_id)

    def is_on_cooldown(self, user_id):
        now = datetime.now()
        if user_id in self.user_cooldown:
            time_diff = (now - self.user_cooldown[user_id]).total_seconds()
            if time_diff < self.cooldown_time:
                return True, self.cooldown_time - int(time_diff)

        self.user_cooldown[user_id] = now
        return False, 0

    def can_purchase_today(self, user_id):
        today = datetime.now().date()
        user_purchases_today = self.user_purchases.get(str(user_id), {})

        for date_str in list(user_purchases_today.keys()):
            if datetime.strptime(date_str, '%Y-%m-%d').date() != today:
                del user_purchases_today[date_str]

        today_str = today.strftime('%Y-%m-%d')
        today_purchases = user_purchases_today.get(today_str, 0)

        if isinstance(today_purchases, dict):
            purchases_count = today_purchases.get("count", 0)
        else:
            purchases_count = today_purchases

        return purchases_count < 2

    def can_spin_wheel_today(self, user_id):
        today = datetime.now().date().strftime('%Y-%m-%d')
        user_id_str = str(user_id)

        if user_id_str not in self.wheel_spins:
            self.wheel_spins[user_id_str] = {}

        user_spins_today = self.wheel_spins[user_id_str]

        for date_str in list(user_spins_today.keys()):
            if date_str != today:
                del user_spins_today[date_str]

        spins_count = user_spins_today.get(today, 0)
        return spins_count < 2

    def record_wheel_spin(self, user_id):
        today = datetime.now().date().strftime('%Y-%m-%d')
        user_id_str = str(user_id)

        if user_id_str not in self.wheel_spins:
            self.wheel_spins[user_id_str] = {}

        if today not in self.wheel_spins[user_id_str]:
            self.wheel_spins[user_id_str][today] = 0

        self.wheel_spins[user_id_str][today] += 1

    def get_daily_gift_info(self, user_id):
        """الحصول على معلومات الهدية اليومية للمستخدم"""
        try:
            today = datetime.now().date()
            today_str = today.strftime('%Y-%m-%d')
            user_id_str = str(user_id)

            try:
                with self.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute('SELECT * FROM daily_gifts WHERE user_id = ?', (user_id_str,))
                    row = cursor.fetchone()

                    if row:
                        last_claim_date = row['last_claim_date']
                        current_day = row['current_day']
                        claimed_today = row['claimed_today']

                        if last_claim_date and last_claim_date != today_str:
                            claimed_today = False
                            cursor.execute('UPDATE daily_gifts SET claimed_today = 0 WHERE user_id = ?', (user_id_str,))
                            conn.commit()

                        return {
                            'can_claim': not claimed_today,
                            'current_day': current_day,
                            'last_claim_date': last_claim_date
                        }
            except:
                pass

            return {
                'can_claim': True,
                'current_day': 1,
                'last_claim_date': None
            }
        except Exception as e:
            logger.error(f"خطأ في get_daily_gift_info: {e}")
            return {
                'can_claim': False,
                'current_day': 1,
                'last_claim_date': None
            }

    def can_claim_daily_gift(self, user_id):
        """دالة مساعدة للتوافق مع الكود القديم"""
        daily_gift_info = self.get_daily_gift_info(user_id)
        return daily_gift_info['can_claim']

    def claim_daily_gift(self, user_id):
        """دالة مساعدة للتوافق مع الكود القديم"""
        daily_gift_info = self.get_daily_gift_info(user_id)
        if daily_gift_info['can_claim']:
            daily_rewards = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]
            current_day = daily_gift_info['current_day']
            if current_day <= len(daily_rewards):
                try:
                    today_str = datetime.now().date().strftime('%Y-%m-%d')
                    with self.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute('''
                            INSERT OR REPLACE INTO daily_gifts 
                            (user_id, current_day, last_claim_date, claimed_today) 
                            VALUES (?, ?, ?, 1)
                        ''', (str(user_id), current_day + 1, today_str))
                        conn.commit()
                except Exception as e:
                    logger.error(f"خطأ في تحديث الهدية اليومية: {e}")

                return daily_rewards[current_day - 1]
        return self.daily_gift_amount

    def record_purchase(self, user_id, stars_count=0):
        today = datetime.now().date().strftime('%Y-%m-%d')

        if str(user_id) not in self.user_purchases:
            self.user_purchases[str(user_id)] = {}

        if today not in self.user_purchases[str(user_id)]:
            self.user_purchases[str(user_id)][today] = {"count": 0, "stars": 0}

        if isinstance(self.user_purchases[str(user_id)][today], int):
            old_count = self.user_purchases[str(user_id)][today]
            self.user_purchases[str(user_id)][today] = {"count": old_count, "stars": 0}

        self.user_purchases[str(user_id)][today]["count"] += 1
        self.user_purchases[str(user_id)][today]["stars"] += stars_count

    def generate_gift_link(self):
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-"
        return ''.join(secrets.choice(chars) for _ in range(20))

    def create_gift_link(self, points, max_users):
        gift_code = self.generate_gift_link()
        expiry_date = datetime.now() + timedelta(hours=24)

        self.gift_links[gift_code] = {
            "points": points,
            "max_users": max_users,
            "used_users": [],
            "created_date": str(datetime.now()),
            "expiry_date": str(expiry_date),
            "active": True
        }
        self.save_json(GIFT_LINKS_FILE, self.gift_links)
        return gift_code

    def use_gift_link(self, gift_code, user_id):
        if gift_code not in self.gift_links:
            return {"success": False, "message": "رابط الهدية غير صحيح!"}

        gift = self.gift_links[gift_code]

        if not gift["active"]:
            return {"success": False, "message": "تم وصول للحد الاقصى لعدد المستخدمين !"}

        expiry_date = datetime.strptime(gift["expiry_date"], '%Y-%m-%d %H:%M:%S.%f')
        if datetime.now() > expiry_date:
            gift["active"] = False
            self.save_json(GIFT_LINKS_FILE, self.gift_links)
            return {"success": False, "message": "الرابط منتهي الصلاحية!"}

        if str(user_id) in gift["used_users"]:
            return {"success": False, "message": "لقد استخدمت هذا الرابط من قبل!"}

        if len(gift["used_users"]) >= gift["max_users"]:
            gift["active"] = False
            self.save_json(GIFT_LINKS_FILE, self.gift_links)
            return {"success": False, "message": "تم وصول للحد الاقصى لعدد المستخدمين !"}

        user = self.get_user(user_id)
        user["points"] += gift["points"]
        gift["used_users"].append(str(user_id))


        self.save_json(GIFT_LINKS_FILE, self.gift_links)

        return {
            "success": True,
            "points": gift["points"],
            "remaining": gift["max_users"] - len(gift["used_users"])
        }

    def deactivate_gift_link(self, gift_code):
        if gift_code in self.gift_links:
            self.gift_links[gift_code]["active"] = False
            self.save_json(GIFT_LINKS_FILE, self.gift_links)
            return True
        return False

    def update_top_referrers(self):
        referrers = []

        for user_id, user_data in self.users.items():
            referral_count = user_data.get("referrals_count", 0)
            if referral_count > 0:
                referrers.append({
                    "user_id": user_id,
                    "count": referral_count
                })

        referrers.sort(key=lambda x: x["count"], reverse=True)
        self.top_referrers = referrers[:5]
        self.save_json(TOP_REFERRERS_FILE, self.top_referrers)

    async def _delayed_activity_save(self):
        await asyncio.sleep(1)  # انتظار ثانية واحدة فقط لتجميع التحديثات
        if hasattr(self, '_activity_save_pending'):

            del self._activity_save_pending

    async def schedule_delayed_check(self, user_id, context):
        user_id_str = str(user_id)

        if user_id_str in self.pending_checks:
            current_task = self.pending_checks[user_id_str]
            if not current_task.done():
                return

        async def delayed_check():
            try:
                await asyncio.sleep(self.check_delay)  # انتظار 30 ثانية
                await self.check_paid_subscriptions_and_deduct(user_id, context)
                if user_id_str in self.pending_checks:
                    del self.pending_checks[user_id_str]
            except asyncio.CancelledError:
                pass
            except Exception as e:
                logger.error(f"خطأ في الفحص المؤجل للمستخدم {user_id}: {e}")
                if user_id_str in self.pending_checks:
                    del self.pending_checks[user_id_str]

        self.pending_checks[user_id_str] = asyncio.create_task(delayed_check())
    def format_points(self, points):
        if points == int(points):
            return str(int(points))
        else:
            return f"{points:.2f}"

    def generate_funding_number(self, funding_type="channel", channel_id=None, bot_id=None, is_cumulative=False):
        """إنشاء رقم تمويل جديد مع التسلسل - رقم جديد لكل تمويل مع تنظيف الأرقام المكتملة"""

        self.cleanup_old_funding_numbers()

        if is_cumulative:
            existing_record = self.get_funding_record_by_id(
                channel_id if funding_type == "channel" else bot_id, 
                funding_type
            )
            if existing_record and existing_record.get("status") != "مكتمل":
                funding_number = existing_record.get("funding_number")
                existing_record["last_cumulative_date"] = str(datetime.now())
                existing_record["status"] = "نشط"
                self.save_json(FUNDING_NUMBERS_FILE, self.funding_numbers)
                return funding_number

        self.funding_numbers["last_number"] += 1
        funding_number = self.funding_numbers["last_number"]

        funding_record = {
            "funding_number": funding_number,
            "funding_type": funding_type,
            "date": str(datetime.now()),
            "channel_id": channel_id if funding_type == "channel" else None,
            "bot_id": bot_id if funding_type == "bot" else None,
            "status": "نشط",
            "is_cumulative": is_cumulative
        }

        self.funding_numbers["records"][str(funding_number)] = funding_record
        self.save_json(FUNDING_NUMBERS_FILE, self.funding_numbers)

        return funding_number

    def cleanup_old_funding_numbers(self):
        """تنظيف أرقام التمويل المكتملة والقديمة للحفاظ على أداء النظام"""
        try:
            current_time = datetime.now()
            records_to_remove = []

            for fund_num, fund_record in self.funding_numbers["records"].items():
                if fund_record.get("status") == "مكتمل":
                    try:
                        completion_date = datetime.strptime(
                            fund_record.get("status_update_date", fund_record.get("date")), 
                            '%Y-%m-%d %H:%M:%S.%f'
                        )
                        days_passed = (current_time - completion_date).days
                        if days_passed > 30:
                            records_to_remove.append(fund_num)
                    except:
                        records_to_remove.append(fund_num)

            for record_id in records_to_remove:
                del self.funding_numbers["records"][record_id]

            if records_to_remove:
                self.save_json(FUNDING_NUMBERS_FILE, self.funding_numbers)
                logger.info(f"تم تنظيف {len(records_to_remove)} سجل تمويل قديم")

        except Exception as e:
            logger.error(f"خطأ في تنظيف أرقام التمويل القديمة: {e}")

    def update_funding_status(self, funding_number, status):
        """تحديث حالة التمويل (مكتمل/ملغي) مع الحفاظ على رقم التمويل"""
        if str(funding_number) in self.funding_numbers["records"]:
            self.funding_numbers["records"][str(funding_number)]["status"] = status
            self.funding_numbers["records"][str(funding_number)]["status_update_date"] = str(datetime.now())
            self.save_json(FUNDING_NUMBERS_FILE, self.funding_numbers)
            return True
        return False

    def get_funding_info(self, funding_number):
        """الحصول على معلومات رقم التمويل"""
        return self.funding_numbers["records"].get(str(funding_number), None)

    def cancel_funding_keep_data(self, funding_id, funding_type="channel", cancellation_reason="إلغاء تلقائي"):
        """إلغاء التمويل مع الاحتفاظ بالبيانات للتمويل التراكمي المستقبلي"""
        try:
            if funding_type == "channel":
                if funding_id in self.funded_channels:
                    self.funded_channels[funding_id]['cancellation_date'] = str(datetime.now())
                    self.funded_channels[funding_id]['cancellation_reason'] = cancellation_reason
                    self.funded_channels[funding_id]['status'] = 'ملغي'
                    self.funded_channels[funding_id]['is_cancelled'] = True

                    funding_record = self.get_funding_record_by_id(funding_id, "channel")
                    if funding_record:
                        funding_number = funding_record.get("funding_number")
                        if funding_number:
                            self.update_funding_status(funding_number, "ملغي")

            elif funding_type == "bot":
                if funding_id in self.funded_bots:
                    self.funded_bots[funding_id]['cancellation_date'] = str(datetime.now())
                    self.funded_bots[funding_id]['cancellation_reason'] = cancellation_reason
                    self.funded_bots[funding_id]['status'] = 'ملغي'
                    self.funded_bots[funding_id]['is_cancelled'] = True

                    funding_record = self.get_funding_record_by_id(funding_id, "bot")
                    if funding_record:
                        funding_number = funding_record.get("funding_number")
                        if funding_number:
                            self.update_funding_status(funding_number, "ملغي")

            self.save_json(FUNDED_CHANNELS_FILE if funding_type == "channel" else FUNDED_BOTS_FILE, 
                          self.funded_channels if funding_type == "channel" else self.funded_bots)
            return True

        except Exception as e:
            logger.error(f"خطأ في إلغاء التمويل {funding_id}: {e}")
            return False

    def reactivate_cumulative_funding(self, funding_id, funding_type="channel", additional_members=0, additional_cost=0):
        """إعادة تفعيل التمويل الملغي كتمويل تراكمي"""
        try:
            if funding_type == "channel":
                if funding_id in self.funded_channels:
                    funding_data = self.funded_channels[funding_id]

                    funding_data['status'] = 'نشط'
                    funding_data['is_cancelled'] = False
                    funding_data['reactivation_date'] = str(datetime.now())

                    current_members = funding_data.get('members_funded', 0)
                    current_cost = funding_data.get('cost_paid', 0)

                    funding_data['members_funded'] = current_members + additional_members
                    funding_data['cost_paid'] = current_cost + additional_cost

                    funding_record = self.get_funding_record_by_id(funding_id, "channel")
                    if funding_record:
                        funding_number = funding_record.get("funding_number")
                        if funding_number:
                            self.update_funding_status(funding_number, "نشط")

                    return funding_record.get("funding_number") if funding_record else None

            elif funding_type == "bot":
                if funding_id in self.funded_bots:
                    funding_data = self.funded_bots[funding_id]

                    funding_data['status'] = 'نشط'
                    funding_data['is_cancelled'] = False
                    funding_data['reactivation_date'] = str(datetime.now())

                    current_members = funding_data.get('members_funded', 0)
                    current_cost = funding_data.get('cost_paid', 0)

                    funding_data['members_funded'] = current_members + additional_members
                    funding_data['cost_paid'] = current_cost + additional_cost

                    funding_record = self.get_funding_record_by_id(funding_id, "bot")
                    if funding_record:
                        funding_number = funding_record.get("funding_number")
                        if funding_number:
                            self.update_funding_status(funding_number, "نشط")

                    return funding_record.get("funding_number") if funding_record else None

            return None

        except Exception as e:
            logger.error(f"خطأ في إعادة تفعيل التمويل {funding_id}: {e}")
            return None

    def move_funding_to_completed(self, funding_id, funding_type="channel"):
        """نقل التمويل المكتمل إلى قسم التمويلات المكتملة مع تنظيف البيانات القديمة بشكل صحيح"""
        try:
            if funding_type == "channel":
                if funding_id in self.funded_channels:
                    funding_data = self.funded_channels[funding_id].copy()
                    funding_data['completion_date'] = str(datetime.now())
                    funding_data['moved_to_completed'] = True
                    funding_data['funding_type'] = funding_type
                    funding_data['status'] = 'مكتمل'

                    funding_record = self.get_funding_record_by_id(funding_id, "channel")
                    if funding_record:
                        funding_data['funding_number'] = funding_record.get("funding_number", "غير متاح")
                        self.update_funding_status(funding_record.get("funding_number"), "مكتمل")
                    else:
                        funding_data['funding_number'] = "غير متاح"

                    if funding_id in self.paid_channels:
                        funding_data['final_members_count'] = self.paid_channels[funding_id].get('total_subscribers_count', 0)
                        funding_data['channel_invite_link'] = self.paid_channels[funding_id].get('invite_link', '')
                        funding_data['channel_name'] = self.paid_channels[funding_id].get('name', funding_data.get('channel_name', ''))

                    timestamp = int(datetime.now().timestamp())
                    unique_key = f"{funding_id}_{timestamp}"

                    self.completed_fundings["channels"][unique_key] = funding_data

                    owner_id = funding_data.get('owner_id')
                    if owner_id and str(owner_id) in self.users:
                        user = self.users[str(owner_id)]
                        if "funded_channels" in user and funding_id in user["funded_channels"]:
                            user["funded_channels"].remove(funding_id)

                    del self.funded_channels[funding_id]

                    self.save_json(COMPLETED_FUNDINGS_FILE, self.completed_fundings)
                    self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)


                    logger.info(f"تم نقل التمويل {funding_id} إلى قسم التمويلات المكتملة بمفتاح {unique_key} ورقم تمويل {funding_data['funding_number']} وحذف البيانات القديمة")
                    return True

            elif funding_type == "bot":
                if funding_id in self.funded_bots:
                    funding_data = self.funded_bots[funding_id].copy()
                    funding_data['completion_date'] = str(datetime.now())
                    funding_data['moved_to_completed'] = True
                    funding_data['funding_type'] = funding_type
                    funding_data['status'] = 'مكتمل'

                    funding_record = self.get_funding_record_by_id(funding_id, "bot")
                    if funding_record:
                        funding_data['funding_number'] = funding_record.get("funding_number", "غير متاح")
                        self.update_funding_status(funding_record.get("funding_number"), "مكتمل")
                    else:
                        funding_data['funding_number'] = "غير متاح"

                    if funding_id in self.paid_bots:
                        funding_data['final_members_count'] = self.paid_bots[funding_id].get('total_subscribers_count', 0)
                        funding_data['bot_username'] = self.paid_bots[funding_id].get('username', '')
                        funding_data['bot_name'] = self.paid_bots[funding_id].get('name', funding_data.get('bot_name', ''))

                    timestamp = int(datetime.now().timestamp())
                    unique_key = f"{funding_id}_{timestamp}"

                    self.completed_fundings["bots"][unique_key] = funding_data

                    owner_id = funding_data.get('owner_id')
                    if owner_id and str(owner_id) in self.users:
                        user = self.users[str(owner_id)]
                        if "funded_bots" in user and funding_id in user["funded_bots"]:
                            user["funded_bots"].remove(funding_id)

                    del self.funded_bots[funding_id]

                    self.save_json(COMPLETED_FUNDINGS_FILE, self.completed_fundings)
                    self.save_json(FUNDED_BOTS_FILE, self.funded_bots)


                    logger.info(f"تم نقل تمويل البوت {funding_id} إلى قسم التمويلات المكتملة بمفتاح {unique_key} ورقم تمويل {funding_data['funding_number']} وحذف البيانات القديمة")
                    return True

            return False

        except Exception as e:
            logger.error(f"خطأ في نقل التمويل {funding_id} إلى القسم المكتمل: {e}")
            return False

    def get_user_fundings_from_permanent_record(self, user_id):
        """الحصول على آخر 5 تمويلات للمستخدم من السجل الدائم"""
        user_fundings = []

        for channel_id, funding_info in self.funded_channels.items():
            if funding_info.get('owner_id') == user_id:
                funding_record = self.get_funding_record_by_id(channel_id, "channel")
                status, current_count, required_count = self.determine_funding_status(channel_id, funding_info, "channel")

                user_fundings.append({
                    "id": channel_id,
                    "type": "قناة",
                    "name": funding_info.get('channel_name', 'قناة غير معروفة'),
                    "status": status,
                    "current_count": current_count,
                    "required_count": required_count,
                    "funding_number": funding_record.get("funding_number", "غير متاح") if funding_record else "غير متاح",
                    "date": funding_info.get('date', 'غير متاح'),
                    "cost": funding_info.get('cost_paid', 0),
                    "funding_date_obj": self.parse_date_string(funding_info.get('date', 'غير متاح'))
                })

        for bot_id, funding_info in self.funded_bots.items():
            if funding_info.get('owner_id') == user_id:
                funding_record = self.get_funding_record_by_id(bot_id, "bot")
                status, current_count, required_count = self.determine_funding_status(bot_id, funding_info, "bot")

                user_fundings.append({
                    "id": bot_id,
                    "type": "بوت",
                    "name": funding_info.get('bot_name', 'بوت غير معروف'),
                    "status": status,
                    "current_count": current_count,
                    "required_count": required_count,
                    "funding_number": funding_record.get("funding_number", "غير متاح") if funding_record else "غير متاح",
                    "date": funding_info.get('date', 'غير متاح'),
                    "cost": funding_info.get('cost_paid', 0),
                    "funding_date_obj": self.parse_date_string(funding_info.get('date', 'غير متاح'))
                })

        for unique_key, completed_info in self.completed_fundings.get("channels", {}).items():
            if completed_info.get('owner_id') == user_id:
                user_fundings.append({
                    "id": unique_key,
                    "type": "قناة",
                    "name": completed_info.get('channel_name', 'قناة غير معروفة'),
                    "status": "مكتمل 🟢",
                    "current_count": completed_info.get('final_members_count', completed_info.get('members_funded', 0)),
                    "required_count": completed_info.get('members_funded', 0),
                    "funding_number": completed_info.get("funding_number", "غير متاح"),
                    "date": completed_info.get('date', 'غير متاح'),
                    "cost": completed_info.get('cost_paid', 0),
                    "funding_date_obj": self.parse_date_string(completed_info.get('date', 'غير متاح'))
                })

        for unique_key, completed_info in self.completed_fundings.get("bots", {}).items():
            if completed_info.get('owner_id') == user_id:
                user_fundings.append({
                    "id": unique_key,
                    "type": "بوت", 
                    "name": completed_info.get('bot_name', 'بوت غير معروف'),
                    "status": "مكتمل 🟢",
                    "current_count": completed_info.get('final_members_count', completed_info.get('members_funded', 0)),
                    "required_count": completed_info.get('members_funded', 0),
                    "funding_number": completed_info.get("funding_number", "غير متاح"),
                    "date": completed_info.get('date', 'غير متاح'),
                    "cost": completed_info.get('cost_paid', 0),
                    "funding_date_obj": self.parse_date_string(completed_info.get('date', 'غير متاح'))
                })

        user_fundings.sort(key=lambda x: x['funding_date_obj'], reverse=True)

        self.cleanup_old_completed_fundings(user_id, user_fundings)

        return user_fundings[:5]  # إرجاع آخر 5 تمويلات فقط

    def parse_date_string(self, date_string):
        """تحويل نص التاريخ إلى كائن datetime للترتيب"""
        try:
            if date_string == 'غير متاح':
                return datetime.min

            try:
                return datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S.%f')
            except:
                try:
                    return datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S')
                except:
                    try:
                        return datetime.strptime(date_string[:19], '%Y-%m-%d %H:%M:%S')
                    except:
                        return datetime.min
        except:
            return datetime.min

    def cleanup_old_completed_fundings(self, user_id, current_fundings):
        """حذف التمويلات المكتملة القديمة والاحتفاظ بآخر 5 فقط"""
        try:
            user_completed_channels = []
            user_completed_bots = []

            for unique_key, completed_info in self.completed_fundings.get("channels", {}).items():
                if completed_info.get('owner_id') == user_id:
                    date_obj = self.parse_date_string(completed_info.get('date', 'غير متاح'))
                    user_completed_channels.append((unique_key, date_obj))

            for unique_key, completed_info in self.completed_fundings.get("bots", {}).items():
                if completed_info.get('owner_id') == user_id:
                    date_obj = self.parse_date_string(completed_info.get('date', 'غير متاح'))
                    user_completed_bots.append((unique_key, date_obj))

            user_completed_channels.sort(key=lambda x: x[1], reverse=True)
            user_completed_bots.sort(key=lambda x: x[1], reverse=True)

            channels_to_keep = user_completed_channels[:3]
            bots_to_keep = user_completed_bots[:3]

            for unique_key, _ in user_completed_channels[3:]:
                if unique_key in self.completed_fundings.get("channels", {}):
                    del self.completed_fundings["channels"][unique_key]

            for unique_key, _ in user_completed_bots[3:]:
                if unique_key in self.completed_fundings.get("bots", {}):
                    del self.completed_fundings["bots"][unique_key]

            if len(user_completed_channels) > 3 or len(user_completed_bots) > 3:
                self.save_json(COMPLETED_FUNDINGS_FILE, self.completed_fundings)

        except Exception as e:
            logger.error(f"خطأ في تنظيف التمويلات القديمة: {e}")

    def get_funding_record_by_id(self, funding_id, funding_type):
        """الحصول على سجل التمويل بناءً على المعرف والنوع - يعيد آخر سجل (الأحدث)"""
        matching_records = []

        for fund_num, fund_record in self.funding_numbers["records"].items():
            if funding_type == "channel" and fund_record.get("channel_id") == funding_id:
                matching_records.append((int(fund_num), fund_record))
            elif funding_type == "bot" and fund_record.get("bot_id") == funding_id:
                matching_records.append((int(fund_num), fund_record))

        if matching_records:
            matching_records.sort(key=lambda x: x[0], reverse=True)
            return matching_records[0][1]

        return None

    def determine_funding_status(self, funding_id, funding_info, funding_type):
        """تحديد حالة التمويل والعدد الحالي والمطلوب"""
        if funding_type == "channel":
            funding_status = funding_info.get('status', 'نشط')
            is_cancelled = funding_info.get('is_cancelled', False)

            if funding_status == 'مكتمل':
                return "مكتمل 🟢", funding_info.get('members_funded', 0), funding_info.get('members_funded', 0)
            elif is_cancelled or funding_status == 'ملغي':
                return "ملغي 🔴", 0, funding_info.get('members_funded', 0)
            elif funding_id in self.paid_channels:
                current_count = self.paid_channels[funding_id].get('total_subscribers_count', 0)
                required_count = self.paid_channels[funding_id].get('members_required', 0)
                if current_count >= required_count:
                    return "مكتمل 🟢", current_count, required_count
                else:
                    return "نشط 🟡", current_count, required_count
            else:
                return "ملغي 🔴", 0, funding_info.get('members_funded', 0)

        elif funding_type == "bot":
            funding_status = funding_info.get('status', 'نشط')
            is_cancelled = funding_info.get('is_cancelled', False)

            if funding_status == 'مكتمل':
                return "مكتمل 🟢", funding_info.get('members_funded', 0), funding_info.get('members_funded', 0)
            elif is_cancelled or funding_status == 'ملغي':
                return "ملغي 🔴", 0, funding_info.get('members_funded', 0)
            elif funding_id in self.paid_bots:
                current_count = self.paid_bots[funding_id].get('total_subscribers_count', 0)
                required_count = self.paid_bots[funding_id].get('members_required', 0)
                if current_count >= required_count:
                    return "مكتمل 🟢", current_count, required_count
                else:
                    return "نشط 🟡", current_count, required_count
            else:
                return "ملغي 🔴", 0, funding_info.get('members_funded', 0)

        return "غير معروف", 0, 0


    def start_admin_check(self):
        if self.admin_check_running:
            return
        self.admin_check_running = True
        self.admin_check_thread = threading.Thread(target=self.admin_check_loop, daemon=True)
        self.admin_check_thread.start()
        pass  # بدء التحقق بصمت
    def stop_admin_check(self):
        self.admin_check_running = False
        if self.admin_check_thread and self.admin_check_thread.is_alive():
            self.admin_check_thread.join(timeout=5)
        pass  # إيقاف التحقق بصمت
    def admin_check_loop(self):
        while self.admin_check_running:
            try:
                for i in range(3600):
                    if not self.admin_check_running:
                        break
                    time.sleep(1)
                if self.admin_check_running:
                    asyncio.run(self.check_admin_permissions())

            except Exception as e:
                logger.error(f"خطأ في حلقة التحقق من صلاحيات المشرف: {e}")
                time.sleep(300)
    async def check_admin_permissions(self):
        try:
            app = Application.builder().token(BOT_TOKEN).build()
            channels_to_cancel = []

            for channel_id, channel_info in list(self.paid_channels.items()):
                try:
                    bot_member = await app.bot.get_chat_member(channel_id, app.bot.id)
                    if bot_member.status not in ['administrator', 'creator']:
                        channels_to_cancel.append(channel_id)

                        funding_number = None
                        for fund_num, fund_record in self.funding_numbers["records"].items():
                            if fund_record.get("channel_id") == channel_id and fund_record.get("funding_type") == "channel":
                                funding_number = fund_num
                                self.update_funding_status(funding_number, "ملغي")
                                break

                        if channel_id in self.funded_channels:
                            funded_info = self.funded_channels[channel_id]
                            owner_id = funded_info['owner_id']

                            self.cancel_funding_keep_data(channel_id, "channel", "البوت لم يعد مشرفاً في القناة")

                            try:
                                message = f"⚠️ تم إلغاء تمويل قناتك!\n\n"
                                message += f"📺 القناة: {channel_info['name']}\n"
                                if funding_number:
                                    message += f"🔢 رقم التمويل: #{funding_number}\n"
                                message += f"❌ السبب: البوت لم يعد مشرفاً في القناة\n\n"
                                message += f"💡 لإعادة التمويل، يرجى رفع البوت مشرفاً مرة أخرى وتمويل القناة من جديد\n"
                                message += f"✅ سيكون التمويل الجديد تراكمي فوق العدد السابق بنفس رقم التمويل"

                                await app.bot.send_message(owner_id, message)
                            except Exception as e:
                                logger.error(f"فشل في إرسال إشعار لصاحب التمويل {owner_id}: {e}")

                        try:
                            admin_message = f"🚨 تم إلغاء تمويل قناة تلقائياً!\n\n"
                            admin_message += f"📺 القناة: {channel_info['name']}\n"
                            admin_message += f"🆔 معرف القناة: {channel_id}\n"
                            if funding_number:
                                admin_message += f"🔢 رقم التمويل: #{funding_number}\n"
                            admin_message += f"❌ السبب: البوت لم يعد مشرفاً في القناة\n"
                            admin_message += f"📅 وقت الإلغاء: {self.format_time_12h(datetime.now())}"

                            await app.bot.send_message(ADMIN_ID, admin_message)
                        except Exception as e:
                            logger.error(f"فشل في إرسال إشعار الإلغاء للأدمن: {e}")

                except Exception as e:
                    logger.error(f"خطأ في التحقق من القناة {channel_id}: {e}")

            for channel_id in channels_to_cancel:
                if channel_id in self.paid_channels:
                    del self.paid_channels[channel_id]

                if channel_id in self.monitored_channels:
                    del self.monitored_channels[channel_id]

            if channels_to_cancel:
                self.save_data_to_db('paid_channels', self.paid_channels)
                self.save_json(MONITORED_CHANNELS_FILE, self.monitored_channels)
                self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)

                pass  # تم إلغاء التمويل للقنوات المحذوفة

        except Exception as e:
            logger.error(f"خطأ في التحقق من صلاحيات المشرف: {e}")

    async def delete_old_mandatory_message(self, context, user_id):
        try:
            user_id_str = str(user_id)

            if user_id_str in self.user_mandatory_messages:
                try:
                    message_id = self.user_mandatory_messages[user_id_str]
                    await context.bot.delete_message(chat_id=user_id, message_id=message_id)
                except Exception:
                    pass  # تجاهل الأخطاء بصمت
                finally:
                    del self.user_mandatory_messages[user_id_str]
        except Exception:
            pass
    async def get_channel_member_count(self, context, channel_id):
        try:
            chat = await context.bot.get_chat(channel_id)
            return chat.member_count if hasattr(chat, 'member_count') else 0
        except:
            return 0
    async def is_user_member_of_channel(self, context, channel_id, user_id):
        try:
            member = await context.bot.get_chat_member(channel_id, user_id)
            return member.status in ['member', 'administrator', 'creator']
        except Exception:
            return False
    async def get_next_paid_channel(self, user_id, context):
        user_subscriptions = self.user_channel_subscriptions.get(str(user_id), {})
        for channel_id, channel_info in self.paid_channels.items():
            if channel_id not in user_subscriptions:
                is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
                if not is_member:
                    return channel_id, channel_info
        return None, None

    async def get_next_paid_channel_after_skip(self, user_id, current_channel_id, context):
        """الحصول على القناة التالية بعد تخطي القناة الحالية"""
        user_subscriptions = self.user_channel_subscriptions.get(str(user_id), {})
        channels_list = list(self.paid_channels.items())

        current_index = -1
        for i, (channel_id, channel_info) in enumerate(channels_list):
            if channel_id == current_channel_id:
                current_index = i
                break

        start_index = current_index + 1 if current_index != -1 else 0

        for i in range(start_index, len(channels_list)):
            channel_id, channel_info = channels_list[i]
            if channel_id not in user_subscriptions:
                is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
                if not is_member:
                    return channel_id, channel_info

        for i in range(0, start_index):
            channel_id, channel_info = channels_list[i]
            if channel_id not in user_subscriptions:
                is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
                if not is_member:
                    return channel_id, channel_info

        return None, None
    async def get_top_referrers(self, context):
        referrers_with_usernames = []

        for referrer in self.top_referrers:
            try:
                user_chat = await context.bot.get_chat(int(referrer["user_id"]))
                if user_chat.username:
                    username = f"@{user_chat.username}"
                else:
                    username = user_chat.first_name or "مستخدم"
            except:
                username = "مستخدم"
            referrers_with_usernames.append({
                "user_id": referrer["user_id"],
                "username": username,
                "count": referrer["count"]
            })
        return referrers_with_usernames
    async def check_paid_subscriptions_and_deduct(self, user_id, context):
        user_id_str = str(user_id)
        if user_id_str not in self.user_channel_subscriptions:
            return
        user_subs = self.user_channel_subscriptions[user_id_str]
        if not user_subs:
            return
        last_check_key = f"last_check_{user_id_str}"
        current_time = datetime.now()
        if hasattr(self, 'user_last_checks'):
            last_check = self.user_last_checks.get(last_check_key)
            if last_check and (current_time - last_check).total_seconds() < 30:  # 30 ثانية
                return
        else:
            self.user_last_checks = {}
        channels_to_check = []
        for channel_id in user_subs.keys():
            if channel_id in self.paid_channels or channel_id in self.monitored_channels:
                channels_to_check.append(channel_id)

        if not channels_to_check:
            return

        self.user_last_checks[last_check_key] = current_time
        max_concurrent = min(2, len(channels_to_check))  # تقليل إلى 2 فحوصات فقط

        async def check_single_channel(channel_id):
            try:
                return channel_id, await asyncio.wait_for(
                    self.is_user_member_of_channel(context, channel_id, user_id),
                    timeout=3  # تقليل المهلة إلى 3 ثوان
                )
            except (asyncio.TimeoutError, Exception):
                return channel_id, True  # افتراض العضوية في حالة الخطأ
        results = []
        for i in range(0, len(channels_to_check), max_concurrent):
            batch = channels_to_check[i:i + max_concurrent]
            batch_tasks = [check_single_channel(channel_id) for channel_id in batch]
            try:
                batch_results = await asyncio.wait_for(
                    asyncio.gather(*batch_tasks, return_exceptions=True),
                    timeout=15  # حد أقصى 15 ثانية للمجموعة
                )
                for result in batch_results:
                    if not isinstance(result, Exception):
                        results.append(result)
            except asyncio.TimeoutError:
                for channel_id in batch:
                    results.append((channel_id, True))
        user = self.get_user(user_id)
        points_deducted = 0
        channels_to_remove = []
        deduction_details = []
        for channel_id, is_member in results:
            if not is_member:
                sub_info = user_subs.get(channel_id)
                if sub_info:
                    points_deducted += sub_info.get('points', 0)
                    channels_to_remove.append(channel_id)
                    channel_name = "قناة غير معروفة"
                    if channel_id in self.paid_channels:
                        channel_name = self.paid_channels[channel_id]['name']
                    elif channel_id in self.monitored_channels:
                        channel_name = self.monitored_channels[channel_id]['name']
                    deduction_details.append({
                        'channel_name': channel_name,
                        'points': sub_info.get('points', 0)
                    })
        if channels_to_remove:
            user['points'] -= points_deducted
            for channel_id in channels_to_remove:
                if channel_id in self.user_channel_subscriptions[user_id_str]:
                    del self.user_channel_subscriptions[user_id_str][channel_id]
            if not self.user_channel_subscriptions[user_id_str]:
                del self.user_channel_subscriptions[user_id_str]
            for detail in deduction_details:
                try:
                    await context.bot.send_message(
            user_id,
            f"❕ تم رصد مغادرتك من: {detail['channel_name']}\n"
                        f"❗ وتم خصم منك {self.format_points(detail['points'])}⭐ حسب القواعد المعتمدة.\n"
                    )
                except Exception as e:
                    logger.error(f"فشل إرسال رسالة الخصم للمستخدم {user_id}: {e}")
            await self.delayed_save_data()
    def update_user_activity(self, user_id):
        """تحديث نشاط المستخدم بكفاءة"""
        user_id_str = str(user_id)
        if user_id_str in self.users:
            self.users[user_id_str]["last_activity"] = str(datetime.now())
            self.save_user_to_db(user_id, self.users[user_id_str])


    async def delayed_save_data(self):
        if not hasattr(self, '_data_save_pending'):
            self._data_save_pending = True
            await asyncio.sleep(2)
            try:
                await asyncio.gather(
                    asyncio.to_thread(self.save_data_to_db, 'users', self.users),
                    asyncio.to_thread(self.save_data_to_db, 'user_channel_subscriptions', self.user_channel_subscriptions)
                )
            except Exception as e:
                logger.error(f"خطأ في الحفظ المؤجل: {e}")
            finally:
                if hasattr(self, '_data_save_pending'):
                    del self._data_save_pending

    async def send_subscription_notification(self, context, user_id, channel_info, current_count, required_count):
        try:
            await context.bot.send_message(
                ADMIN_ID,
                f"🔔 اشتراك جديد في القناة الإجبارية!\n\n"
                f"📺 القناة: {channel_info['name']}\n"
                f"👤 المستخدم: {user_id}\n"
                f"📊 العدد الحالي: {current_count}/{required_count}\n"
                f"📈 التقدم: {int((current_count/required_count)*100) if required_count > 0 else 0}%"
            )
        except Exception as e:
            logger.error(f"خطأ في إرسال إشعار الاشتراك: {e}")

    async def send_completion_notification(self, context, channel_info, required_count, current_count, channel_id):
        try:
            await context.bot.send_message(
                ADMIN_ID,
                f"🎉 تم إكمال العدد المطلوب للقناة الإجبارية!\n\n"
                f"📺 القناة: {channel_info['name']}\n"
                f"👥 العدد المطلوب: {required_count}\n"
                f"✅ العدد الحالي: {current_count}\n\n"
                f"🔄 تم حذف القناة من الاشتراك الاجباري يمكنك إعادة تفعيله مرة أخرى ♻️."
            )
            if channel_id in self.mandatory_channels:
                del self.mandatory_channels[channel_id]
        except Exception as e:
            logger.error(f"خطأ في إرسال إشعار اكتمال العدد: {e}")

    async def async_save_mandatory_data(self, user_id_str, user_mandatory_subs):
        try:
            self.mandatory_subscriptions[user_id_str] = user_mandatory_subs
            await asyncio.gather(
                asyncio.to_thread(self.save_json, MANDATORY_SUBSCRIPTIONS_FILE, self.mandatory_subscriptions),
                asyncio.to_thread(self.save_json, MANDATORY_CHANNELS_FILE, self.mandatory_channels)
            )
        except Exception as e:
            logger.error(f"خطأ في حفظ بيانات الاشتراكات: {e}")

    async def check_mandatory_subscriptions_status(self, user_id, context):
        if not self.mandatory_enabled or not self.mandatory_channels:
            return

        user_id_str = str(user_id)
        user_mandatory_subs = self.mandatory_subscriptions.get(user_id_str, {})

        channel_ids = list(self.mandatory_channels.keys())

        async def check_channel_fast(channel_id):
            try:
                return channel_id, await asyncio.wait_for(
                    self.is_user_member_of_channel(context, channel_id, user_id),
                    timeout=3  # 3 ثوان لكل قناة
                )
            except:
                return channel_id, True

        results = []
        for i in range(0, len(channel_ids), 2):
            batch = channel_ids[i:i + 2]
            batch_tasks = [check_channel_fast(channel_id) for channel_id in batch]
            try:
                batch_results = await asyncio.wait_for(
                    asyncio.gather(*batch_tasks, return_exceptions=True),
                    timeout=10
                )
                for result in batch_results:
                    if not isinstance(result, Exception):
                        results.append(result)
            except:
                for channel_id in batch:
                    results.append((channel_id, True))

        for channel_id, is_member in results:
            if isinstance(user_mandatory_subs.get(channel_id), dict):
                user_mandatory_subs[channel_id]["subscribed"] = is_member
                user_mandatory_subs[channel_id]["last_check"] = str(datetime.now())
            else:
                was_counted = user_mandatory_subs.get(channel_id, False)
                user_mandatory_subs[channel_id] = {
                    "subscribed": is_member,
                    "counted": bool(was_counted),
                    "last_check": str(datetime.now())
                }

        self.mandatory_subscriptions[user_id_str] = user_mandatory_subs
        asyncio.create_task(asyncio.to_thread(self.save_json, MANDATORY_SUBSCRIPTIONS_FILE, self.mandatory_subscriptions))

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not update.message or not update.effective_user:
            return
        if update.message.chat.type != 'private':
            await update.message.reply_text("تواصل معي في الخاص.")
            return
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        self.update_user_activity(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        if str(user_id) in self.banned_users:
            await update.message.reply_text(
                "🚫 تم حظرك من استخدام البوت من قبل الإدارة\n"
                "إذا كنت تعتقد أن هذا الحظر حدث عن طريق الخطأ، لا تقلق، بإمكانك التواصل مع الإدارة لمراجعة الأمر : [@cxxov]\n"
                "نحن هنا لدعمك ونسعى لتقديم أفضل تجربة ممكنة."
            )
            return

        invite_code = None
        gift_code = None
        if context.args:
            arg = context.args[0]
            if arg.startswith("gift_"):
                gift_code = arg.split("gift_")[1]
            else:
                invite_code = arg

        is_new_user = user.get("first_join", True)
        mandatory_result = await self.check_mandatory_subscriptions(update, context)
        if not mandatory_result["all_subscribed"]:
            if invite_code and invite_code != "new":
                context.user_data['pending_invite_code'] = invite_code
            return

        if invite_code == "new" and not is_new_user:
            await self.show_main_menu(update, context)
            return

        if invite_code and invite_code != "new" and not is_new_user:
            await update.message.reply_text("❌ أنت مفعل في البوت من قبل!")
            await self.show_main_menu(update, context)
            return

        if is_new_user:
            inviter_info = None
            inviter_id = None
            if invite_code and invite_code != "new":
                for uid, user_data in self.users.items():
                    if user_data.get("invite_link") == invite_code:
                        inviter_id = uid
                        try:
                            inviter_chat = await context.bot.get_chat(int(uid))
                            if inviter_chat.username:
                                inviter_info = f"@{inviter_chat.username}"
                            else:
                                inviter_info = inviter_chat.first_name or "مستخدم"
                        except:
                            inviter_info = "مستخدم"
                        break

            if inviter_info and inviter_id:
                entry_type = f"عبر رابط دعوة \\([{inviter_id}](tg://user?id={inviter_id})\\)"
            else:
                entry_type = "مباشر"

            total_users = len(self.users)
            safe_first_name = self.escape_markdown(update.effective_user.first_name)
            safe_username = ""
            if update.effective_user.username:
                safe_username = self.escape_markdown(f"@{update.effective_user.username}")
            else:
                safe_username = "لا يوجد يوزرنيم"

            await context.bot.send_message(
                ADMIN_ID,
                f"🔔 مستخدم جديد:\n"
                f"👤 {safe_first_name}\n"
                f"📝 اليوزر: {safe_username}\n"
                f"🆔 الآيدي: [{user_id}](tg://user?id={user_id})\n"
                f"📥 نوع الدخول: {entry_type}\n"
                f"👥 إجمالي المستخدمين: {total_users}",
                parse_mode='MarkdownV2'
            )
            user["first_join"] = False
            user["completed_mandatory"] = True

        if gift_code:
            result = self.use_gift_link(gift_code, user_id)
            if result["success"]:
                user_link = f"[{update.effective_user.first_name}](tg://user?id={user_id})"
                await update.message.reply_text(
                    f"🎉] تهانينا {user_link}! تم استلام الهدية {self.format_points(result['points'])}  كوكيز!\n"
                    f"📊] رصيدك الحالي: {self.format_points(user['points'])} 🍪\n\n"
                    f"☺️] نشكركم على ثقتكم الكبيرة، ونسعى دوماً لتقديم الأفضل لكم.",
                    parse_mode='Markdown'
                )
                try:
                    safe_first_name = self.escape_markdown(update.effective_user.first_name)
                    safe_username = ""
                    if update.effective_user.username:
                        safe_username = self.escape_markdown(f"@{update.effective_user.username}")
                    else:
                        safe_username = "لا يوجد يوزرنيم"

                    user_link_admin = f"[{user_id}](tg://user?id={user_id})"
                    await context.bot.send_message(
                        ADMIN_ID,
                        f"🎁 تم استخدام رابط هدية\\!\n\n"
                        f"👤 الاسم: {safe_first_name}\n"
                        f"📝 اليوزر: {safe_username}\n"
                        f"🆔 الآيدي: {user_link_admin}\n"
                        f"💰 الكوكيز المحصلة: {self.format_points(result['points'])}\n"
                        f"👥 متبقي للرابط: {result['remaining']} مستخدم\n"
                        f"🔗 كود الرابط: {gift_code[:10]}\\.\\.\\.\n"
                        f"📅 التاريخ: {self.format_time_12h(datetime.now())}",
                        parse_mode='MarkdownV2'
                    )
                except Exception as e:
                    logger.error(f"فشل في إرسال إشعار رابط الهدية: {e}")
            else:
                await update.message.reply_text(f"❌ {result['message']}")
            await self.show_main_menu(update, context)
            return

        if invite_code and invite_code != "new" and is_new_user:
            await self.handle_invite_link(update, context, invite_code)
        elif context.user_data.get('pending_invite_code') and user.get("completed_mandatory"):
            await self.handle_invite_link(update, context, context.user_data['pending_invite_code'])
            del context.user_data['pending_invite_code']

        await self.show_main_menu(update, context)

    async def check_mandatory_subscriptions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.mandatory_enabled or not self.mandatory_channels:
            return {"all_subscribed": True, "unsubscribed": []}
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        unsubscribed_channels = []
        user_mandatory_subs = self.mandatory_subscriptions.get(user_id_str, {})
        channel_ids = list(self.mandatory_channels.keys())
        max_concurrent = min(5, len(channel_ids))  # حد أقصى 3 فحوصات متوازية
        async def check_single_channel(channel_id):
            try:
                return channel_id, await asyncio.wait_for(
                    self.is_user_member_of_channel(context, channel_id, user_id),
                    timeout=5  # 5 ثوان لكل قناة
                )
            except (asyncio.TimeoutError, Exception):
                return channel_id, True 
        results = []
        for i in range(0, len(channel_ids), max_concurrent):
            batch = channel_ids[i:i + max_concurrent]
            batch_tasks = [check_single_channel(channel_id) for channel_id in batch]

            try:
                batch_results = await asyncio.wait_for(
                    asyncio.gather(*batch_tasks, return_exceptions=True),
                    timeout=15  # حد أقصى 15 ثانية للمجموعة
                )
                for result in batch_results:
                    if not isinstance(result, Exception):
                        results.append(result)
            except asyncio.TimeoutError:
                for channel_id in batch:
                    results.append((channel_id, True))

        for channel_id, is_member in results:
            if not is_member:
                unsubscribed_channels.append(self.mandatory_channels[channel_id])
                user_mandatory_subs[channel_id] = {
                    "subscribed": False,
                    "counted": False,
                    "last_check": str(datetime.now())
                }
            else:
                previous_state = user_mandatory_subs.get(channel_id, {})
                was_subscribed_before = previous_state.get("subscribed", False) if isinstance(previous_state, dict) else previous_state
                was_counted_before = previous_state.get("counted", False) if isinstance(previous_state, dict) else False

                user_mandatory_subs[channel_id] = {
                    "subscribed": True,
                    "counted": was_counted_before,
                    "last_check": str(datetime.now())
                }

                if not was_subscribed_before and not was_counted_before:
                    if 'total_subscribers_count' not in self.mandatory_channels[channel_id]:
                        self.mandatory_channels[channel_id]['total_subscribers_count'] = 0

                    self.mandatory_channels[channel_id]['total_subscribers_count'] += 1
                    user_mandatory_subs[channel_id]["counted"] = True
                    user_mandatory_subs[channel_id]["first_count_date"] = str(datetime.now())

                    channel_info = self.mandatory_channels[channel_id]
                    required_count = channel_info.get('members_required', 0)
                    current_count = channel_info['total_subscribers_count']

                    asyncio.create_task(self.send_subscription_notification(context, user_id, channel_info, current_count, required_count))

                    if required_count > 0 and current_count >= required_count:
                        asyncio.create_task(self.send_completion_notification(context, channel_info, required_count, current_count, channel_id))

        asyncio.create_task(self.async_save_mandatory_data(user_id_str, user_mandatory_subs))

        if unsubscribed_channels:
            await self.delete_old_mandatory_message(context, update.effective_user.id)

            text = "⚜️ عليك الاشتراك في قنوات البوت ومن ثم اضغط على زر التحقق :\n"
            keyboard = []

            for i, channel in enumerate(unsubscribed_channels, 1):
                if channel.get('username'):
                    channel_username = channel['username']
                keyboard.append([
                    InlineKeyboardButton(f" {channel_username}", url=channel['invite_link']),
                    InlineKeyboardButton("غير مشترك ❌", callback_data="unsubscribed_status")
                ])

            bot_username = (await context.bot.get_me()).username
            if context.user_data.get('pending_invite_code'):
                invite_code = context.user_data['pending_invite_code']
                continue_url = f"https://t.me/{bot_username}?start={invite_code}"
            elif context.args and context.args[0] != "new":
                continue_url = f"https://t.me/{bot_username}?start={context.args[0]}"
            else:
                continue_url = f"https://t.me/{bot_username}?start=new"

            keyboard.append([InlineKeyboardButton("✅ التحقق من الاشتراك", url=continue_url)])

            sent_message = await update.message.reply_text(
                text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                disable_web_page_preview=True
            )

            self.user_mandatory_messages[str(update.effective_user.id)] = sent_message.message_id

            return {"all_subscribed": False, "unsubscribed": unsubscribed_channels}

        user = self.get_user(user_id)
        user["completed_mandatory"] = True


        return {"all_subscribed": True, "unsubscribed": []}

    async def handle_invite_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, invite_code):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        if user.get("used_invite"):
            return

        inviter_id = None
        inviter_username = None
        for uid, user_data in self.users.items():
            if user_data.get("invite_link") == invite_code:
                inviter_id = int(uid)
                try:
                    inviter_chat = await context.bot.get_chat(inviter_id)
                    if inviter_chat.username:
                        inviter_username = f"@{inviter_chat.username}"
                    else:
                        inviter_username = inviter_chat.first_name or "مستخدم"
                except:
                    inviter_username = "مستخدم"
                break

        if inviter_id and inviter_id != user_id:
            user["used_invite"] = invite_code

            self.users[str(inviter_id)]["points"] += self.invite_points
            self.users[str(inviter_id)]["referrals_count"] = self.users[str(inviter_id)].get("referrals_count", 0) + 1


            self.update_top_referrers()

            invite_data = {
                "inviter_id": inviter_id,
                "invited_id": user_id,
                "date": str(datetime.now()),
                "points_earned": self.invite_points
            }

            if invite_code not in self.invites:
                self.invites[invite_code] = []
            self.invites[invite_code].append(invite_data)
            self.save_json(INVITES_FILE, self.invites)

            await update.message.reply_text(
                f"🎉 لقد دخلت عبر رابط دعوة خاص بصديقك {inviter_username} "
                f"وحصل على {self.format_points(self.invite_points)} 🍪!"
            )

            if update.effective_user.username:
                invited_username = f"@{update.effective_user.username}"
            else:
                invited_username = update.effective_user.first_name or "مستخد �"
            await context.bot.send_message(
                inviter_id,
                f"🎉 دخل {invited_username} "
                f"عبر رابط الدعوة الخاص بك وحصلت على {self.format_points(self.invite_points)} 🍪!"
            )
        elif inviter_id == user_id:
            await update.message.reply_text("❌ لا يمكنك استخدام رابط الدعوة الخاص بك!")

    async def show_main_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        total_users = len(self.users)

        keyboard = [
            [InlineKeyboardButton("🛍 الخـدمـات← 📦", callback_data="services_menu")],
            [InlineKeyboardButton("قسم التمويل 🔊🧬", callback_data="funding_section")],
            [
                InlineKeyboardButton("تجميع كوكيز 🍪", callback_data="collect_stars"),
                InlineKeyboardButton("تحويل كوكيز ♻️", callback_data="transfer_cookies")
            ],
            [InlineKeyboardButton("استخدام كود 🎁", callback_data="use_gift_code")],
            [
                InlineKeyboardButton("معلوماتي 📑", callback_data="my_info"),
                InlineKeyboardButton("التعليمات 📋", callback_data="instructions")
            ],
            [                InlineKeyboardButton(f"(عدد المستخدمين :  {total_users} ✅ )", callback_data="users_count_display")
            ]
        ]

        if user_id == ADMIN_ID:
            keyboard.append([InlineKeyboardButton("👨‍💼 لوحة الإدارة", callback_data="admin_panel")])

        self.update_user_activity(user_id)

        text = f"*اهلا بك* [{update.effective_user.first_name}](tg://user?id={user_id}) *في بوت تيربو فولو 👥*\n" \
               f"            *يوزر قناة البوت <( @TurboFollow2 )>*       \n" \
               f"           *🍪• عدد الكوكيز :* {self.format_points(user['points'])} •🍪\n" \
               f"           *🆔• ايديك :* `{user_id}` •🆔\n" \

        reply_markup = InlineKeyboardMarkup(keyboard)

        if update.callback_query:
            sent_message = await update.callback_query.edit_message_text(
                text,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
        else:
            sent_message = await update.message.reply_text(
                text,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )

    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query

        if not query or not update.effective_user:
            return

        if query.message.chat.type != 'private':
            await query.answer("البوت يعمل في المحادثات الخاصة فقط!", show_alert=True)
            return

        data = query.data
        user_id = update.effective_user.id

        if str(user_id) in self.banned_users:
            return

        if user_id != ADMIN_ID:
            on_cooldown, remaining_time = self.is_on_cooldown(user_id)
            if on_cooldown:
                await query.answer(f"انتظر {remaining_time} ثانية قبل الضغط مرة أخرى 🔴", show_alert=True)
                return

        await query.answer()

        if data in ["collect_stars", "buy_stars"] or data.startswith("buy_") or data.startswith("confirm_buy_"):
            asyncio.create_task(self.schedule_delayed_check(user_id, context))

        self.update_user_activity(user_id)

        if data == "check_subscriptions":
            mandatory_result = await self.check_mandatory_subscriptions(update, context)
            if mandatory_result["all_subscribed"]:
                if context.user_data.get('pending_invite_code'):
                    user = self.get_user(user_id)
                    user["completed_mandatory"] = True


                    await self.handle_invite_link(update, context, context.user_data['pending_invite_code'])
                    del context.user_data['pending_invite_code']

                await self.show_main_menu(update, context)

        elif data == "check_mandatory_smart":
            await self.handle_smart_mandatory_check(update, context)

        elif data == "services_menu":
            await self.show_services_menu(update, context)

        elif data == "funding_section":
            await self.show_funding_section(update, context)

        elif data == "fund_channel":
            if self.maintenance_mode["fund_channel"]:
                await query.edit_message_text(
                    self.maintenance_messages["fund_channel"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
                )
                return
            await self.show_fund_channel_menu(update, context)

        elif data == "fund_bots":
            await self.show_fund_bots_menu(update, context)

        elif data == "bot_subscription":
            await self.show_bot_subscription(update, context)

        elif data == "stars_section":
            if self.maintenance_mode["stars_section"]:
                await query.edit_message_text(
                    self.maintenance_messages["stars_section"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="services_menu")]])
                )
                return
            await self.show_stars_section(update, context)

        elif data == "invite_link":
            if self.maintenance_mode["invite_link"]:
                await query.edit_message_text(
                    self.maintenance_messages["invite_link"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
                )
                return
            await self.show_invite_link(update, context)

        elif data == "collect_stars":
            if self.maintenance_mode["collect_stars"]:
                await query.edit_message_text(
                    self.maintenance_messages["collect_stars"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
                )
                return
            await self.show_collect_cookies(update, context)
        elif data == "collect_single":
            await self.show_single_collect(update, context)
        elif data == "collect_bulk":
            await self.show_bulk_collect(update, context)
        elif data == "check_bulk_subscriptions":
            await self.check_bulk_subscriptions(update, context)
        elif data == "collect_more":
            await self.show_bulk_collect(update, context)
        elif data == "daily_gift":
            await self.handle_daily_gift(update, context)
        elif data.startswith("claim_daily_gift_"):
            await self.claim_daily_gift_new(update, context, data)
        elif data.startswith("daily_gift_claimed_"):
            await update.callback_query.answer()
        elif data.startswith("daily_gift_claimed_today_"):
            await update.callback_query.answer()
        elif data.startswith("daily_gift_future_"):
            day_number = data.split("_")[3]
            await update.callback_query.answer()
        elif data == "wheel_of_luck":
            if self.maintenance_mode["wheel_luck"]:
                await query.edit_message_text(
                    self.maintenance_messages["wheel_luck"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
                )
                return
            await self.show_wheel_menu(update, context)
        elif data == "my_info":
            await self.show_user_info(update, context)
        elif data == "instructions":
            await self.show_instructions(update, context)
        elif data == "bot_updates":
            await self.show_bot_updates(update, context)
        elif data == "my_fundings":
            await self.show_my_fundings(update, context)
        elif data.startswith("funding_details_"):
            await self.show_funding_details(update, context, data)
        elif data.startswith("header_"):
            await query.answer()
        elif data.startswith("funding_status_info_"):
            await query.answer()
        elif data.startswith("funding_progress_"):
            await query.answer()
        elif data.startswith("funding_channel_link_"):
            await self.handle_funding_channel_link(update, context, data)
        elif data.startswith("funding_bot_link_"):
            await self.handle_funding_bot_link(update, context, data)
        elif data == "admin_panel" and user_id == ADMIN_ID:
            await self.show_admin_panel(update, context)
        elif data == "back_to_main":
            await self.show_main_menu(update, context)
        elif data.startswith("buy_stars_"):
            await self.handle_stars_purchase(update, context, data)
        elif data.startswith("confirm_stars_"):
            await self.confirm_stars_purchase(update, context, data)
        elif data.startswith("delivered_stars_") and user_id == ADMIN_ID:
            await self.handle_stars_delivery_confirmation(update, context, data)
        elif data.startswith("quick_fund_"):
            await self.handle_quick_fund(update, context, data)

        elif data.startswith("confirm_fund_"):
            await self.confirm_funding(update, context, data)
        elif data == "cancel_fund":
            await query.edit_message_text("❌ تم إلغاء عملية التمويل.")
        elif data == "spin_wheel":
            await self.handle_wheel_spin(update, context)
        elif data == "confirm_spin_wheel":
            await self.confirm_wheel_spin(update, context)
        elif data.startswith("delivered_") and user_id == ADMIN_ID:
            await self.handle_delivery_confirmation(update, context, data)
        elif data.startswith("check_paid_"):
            await self.check_paid_subscription(update, context, data)
        elif data.startswith("skip_channel_"):
            await self.skip_current_channel(update, context, data)
        elif data == "manage_mandatory" and user_id == ADMIN_ID:
            await self.manage_mandatory_channels(update, context)
        elif data == "toggle_mandatory" and user_id == ADMIN_ID:
            await self.toggle_mandatory_subscription(update, context)
        elif data == "manage_paid" and user_id == ADMIN_ID:
            await self.manage_paid_channels(update, context)
        elif data == "broadcast" and user_id == ADMIN_ID:
            await self.broadcast_menu(update, context)
        elif data == "add_points" and user_id == ADMIN_ID:
            await self.add_points_menu(update, context)
        elif data == "remove_points" and user_id == ADMIN_ID:
            await self.remove_points_menu(update, context)
        elif data == "manage_users" and user_id == ADMIN_ID:
            await self.manage_users_menu(update, context)
        elif data == "gift_link" and user_id == ADMIN_ID:
            await self.gift_link_menu(update, context)
        elif data == "create_gift_code" and user_id == ADMIN_ID:
            await self.create_gift_code_menu(update, context)
        elif data == "create_gift_link" and user_id == ADMIN_ID:
            await self.create_gift_link_menu(update, context)
        elif data == "manage_gift_links" and user_id == ADMIN_ID:
            await self.manage_gift_links_menu(update, context)
        elif data.startswith("deactivate_gift_") and user_id == ADMIN_ID:
            await self.deactivate_gift_link_handler(update, context, data)
        elif data.startswith("gift_"):
            await self.handle_gift_link_usage(update, context, data)
        elif data == "entry_points" and user_id == ADMIN_ID:
            await self.entry_points_menu(update, context)
        elif data == "statistics" and user_id == ADMIN_ID:
            await self.show_statistics(update, context)
        elif data == "user_info_admin" and user_id == ADMIN_ID:
            await self.user_info_admin_menu(update, context)
        elif data == "member_price" and user_id == ADMIN_ID:
            await self.member_price_menu(update, context)
        elif data == "add_mandatory_channel" and user_id == ADMIN_ID:
            await self.add_mandatory_channel(update, context)
        elif data == "delete_mandatory_channel" and user_id == ADMIN_ID:
            await self.delete_mandatory_channel_menu(update, context)
        elif data.startswith("del_mandatory_") and user_id == ADMIN_ID:
            await self.confirm_delete_mandatory_channel(update, context, data)
        elif data == "add_paid_channel" and user_id == ADMIN_ID:
            await self.add_paid_channel(update, context)
        elif data == "delete_paid_channel" and user_id == ADMIN_ID:
            await self.delete_paid_channel_menu(update, context)
        elif data.startswith("del_paid_") and user_id == ADMIN_ID:
            await self.confirm_delete_paid_channel(update, context, data)
        elif data == "manage_paid_count" and user_id == ADMIN_ID:
            await self.manage_paid_count(update, context)
        elif data == "update_paid_status" and user_id == ADMIN_ID:
            await self.update_paid_status(update, context)
        elif data == "update_mandatory_stats" and user_id == ADMIN_ID:
            await self.update_mandatory_stats(update, context)

        elif data == "ban_user" and user_id == ADMIN_ID:
            await self.ban_user_menu(update, context)
        elif data == "unban_user" and user_id == ADMIN_ID:
            await self.unban_user_menu(update, context)
        elif data == "maintenance" and user_id == ADMIN_ID:
            await self.maintenance_menu(update, context)
        elif data.startswith("maintenance_") and user_id == ADMIN_ID:
            if data == "maintenance_fund_channel":
                await self.maintenance_button_menu(update, context, "fund_channel", "تمويل القناة")
            elif data == "maintenance_invite_link":
                await self.maintenance_button_menu(update, context, "invite_link", "رابط الدعوة")
            elif data == "maintenance_collect_stars":
                await self.maintenance_button_menu(update, context, "collect_stars", "تجميع نجوم")
            elif data == "maintenance_wheel_luck":
                await self.maintenance_button_menu(update, context, "wheel_luck", "عجلة الحظ")
            elif data == "maintenance_stars_section":
                await self.maintenance_button_menu(update, context, "stars_section", "قسم النجوم")
            elif data == "maintenance_rush_services":
                await self.maintenance_button_menu(update, context, "rush_services", "قسم خدمات الرشق")
            elif data.startswith("maintenance_on_"):
                button_type = data.split("maintenance_on_")[1]
                await self.toggle_button_maintenance(update, context, button_type, True)
            elif data.startswith("maintenance_off_"):
                button_type = data.split("maintenance_off_")[1]
                await self.toggle_button_maintenance(update, context, button_type, False)
            elif data.startswith("maintenance_message_"):
                button_type = data.split("maintenance_message_")[1]
                await self.maintenance_button_message_menu(update, context, button_type)
        elif data == "subscription_price" and user_id == ADMIN_ID:
            await self.subscription_price_menu(update, context)

        elif data == "transfer_cookies":
            mandatory_result = await self.check_mandatory_subscriptions(update, context)
            if not mandatory_result["all_subscribed"]:
                return
            await self.show_transfer_cookies_menu(update, context)
        elif data == "use_gift_code":
            mandatory_result = await self.check_mandatory_subscriptions(update, context)
            if not mandatory_result["all_subscribed"]:
                return
            await self.show_use_gift_code_menu(update, context)
        elif data == "transparent" and user_id == ADMIN_ID:
            await self.transparent_menu(update, context)
        elif data == "transparent_click":
            await query.answer()
        elif data == "rush_reactions":
            await self.show_rush_reactions_menu(update, context)
        elif data == "min_funding_members" and user_id == ADMIN_ID:
            await self.min_funding_members_menu(update, context)
        elif data == "daily_gift_amount" and user_id == ADMIN_ID:
            await self.daily_gift_amount_menu(update, context)
        elif data == "accounts_info" and user_id == ADMIN_ID:
            await self.show_accounts_info(update, context)
        elif data == "manage_paid_bots" and user_id == ADMIN_ID:
            await self.manage_paid_bots_menu(update, context)
        elif data == "delete_paid_bot" and user_id == ADMIN_ID:
            await self.delete_paid_bot_menu(update, context)
        elif data.startswith("del_bot_") and user_id == ADMIN_ID:
            await self.confirm_delete_paid_bot(update, context, data)
        elif data == "manage_bots_count" and user_id == ADMIN_ID:
            await self.manage_bots_count(update, context)
        elif data == "confirm_leave_all_chats" and user_id == ADMIN_ID:
            await self.execute_leave_all_chats(update, context)
        elif data.startswith("skip_bot_"):
            await self.skip_current_bot(update, context, data)
        elif data == "users_count_display":
            await query.answer()
        elif data == "unsubscribed_status":
            await query.answer()
        elif data == "rush_services":
            if self.maintenance_mode["rush_services"]:
                await query.edit_message_text(
                    self.maintenance_messages["rush_services"],
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="services_menu")]])
                )
                return
            await self.show_rush_services_menu(update, context)

        elif data == "arab_vote_mandatory":
            await self.show_arab_vote_mandatory_menu(update, context)
        elif data == "admin_settings" and user_id == ADMIN_ID:
            await self.show_admin_settings_menu(update, context)
        elif data == "leave_all_chats" and user_id == ADMIN_ID:
            await self.leave_all_chats_menu(update, context)
        elif data.startswith("report_channel_"):
            await self.handle_channel_report(update, context, data)
        elif data.startswith("report_reason_"):
            await self.handle_report_reason(update, context, data)
        elif data.startswith("report_bot_reason_"):
            await self.handle_bot_report_reason(update, context, data)
        elif data == "report_other_reason":
            await self.handle_other_reason_request(update, context)
        elif data.startswith("admin_report_action_"):
            await self.handle_admin_report_action(update, context, data)
        elif data.startswith("admin_report_delete_") and user_id == ADMIN_ID:
            await self.handle_admin_report_delete(update, context, data)
        elif data.startswith("report_bot_") and not data.startswith("report_bot_reason_") and data != "report_bot_other_reason":
            await self.handle_bot_report(update, context, data)
        elif data.startswith("report_bot_reason_"):
            await self.handle_bot_report_reason(update, context, data)
        elif data == "report_bot_other_reason":
            await self.handle_bot_other_reason_request(update, context)
        elif data == "positive_reactions":
            await self.handle_positive_reactions(update, context)
        elif data == "negative_reactions":
            await self.handle_negative_reactions(update, context)
        elif data == "random_reactions":
            await self.handle_random_reactions(update, context)

        elif data.startswith("arab_vote_speed_"):
            await self.handle_arab_vote_speed_callback(update, context, data)
        elif data == "comments_service":
            await self.show_comments_service_menu(update, context)
        elif data == "comments_service_2":
            await self.show_comments_service_2_menu(update, context)
        elif data.startswith("comments_speed_"):
            await self.handle_comments_speed_callback(update, context, data)
        elif data == "poll_service":
            await self.show_poll_service_menu(update, context)

async def main():
    """Start the bot"""
    application = None
    try:
        telegram_bot = TelegramBot()

        application = Application.builder().token(BOT_TOKEN).build()

        application.add_handler(CommandHandler("start", telegram_bot.start))
        application.add_handler(CallbackQueryHandler(telegram_bot.handle_callback))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, telegram_bot.handle_message))

        print("🤖 تم تحميل البوت بنجاح، بدء الاستماع للرسائل...")
        
        # بدء البوت مع معالجة أفضل للإيقاف
        await application.run_polling(
            drop_pending_updates=True,
            close_loop=False
        )

    except KeyboardInterrupt:
        print("🛑 تم إيقاف البوت بواسطة المستخدم")
    except Exception as e:
        logger.error(f"خطأ في تشغيل البوت: {e}")
        print(f"❌ خطأ في تشغيل البوت: {e}")
    finally:
        # تنظيف الموارد
        if application:
            try:
                await application.shutdown()
                print("✅ تم إغلاق البوت بنجاح")
            except Exception as e:
                logger.error(f"خطأ في إغلاق البوت: {e}")

if __name__ == "__main__":
    try:
        print("🤖 بدء تشغيل البوت...")
        
        # التحقق من وجود حلقة أحداث نشطة
        try:
            loop = asyncio.get_running_loop()
            print("⚠️ يوجد event loop نشط بالفعل")
        except RuntimeError:
            # لا يوجد event loop نشط، يمكننا إنشاء واحد جديد
            pass
        
        # استخدام asyncio.run مع التعامل الصحيح للـ event loop
        asyncio.run(main())
        
    except KeyboardInterrupt:
        print("🛑 تم إيقاف البوت بواسطة المستخدم")
    except RuntimeError as e:
        if "cannot be called from a running event loop" in str(e):
            # إذا كان هناك event loop نشط، نستخدمه
            import nest_asyncio
            nest_asyncio.apply()
            asyncio.run(main())
        else:
            logger.error(f"خطأ في تشغيل البوت: {e}")
            print(f"❌ خطأ في تشغيل البوت: {e}")
    except Exception as e:
        logger.error(f"خطأ في تشغيل البوت: {e}")
        print(f"❌ خطأ في تشغيل البوت: {e}")

    async def handle_mandatory_channel_username(self, update: Update, context: ContextTypes.DEFAULT_TYPE, username_text):
        try:
            username = username_text.strip()

            if username.startswith('@'):
                username = username[1:]

            if not username:
                await update.message.reply_text("❌ يوزرنيم القناة غير صحيح!")
                return

            try:
                chat = await context.bot.get_chat(f"@{username}")
                channel_id = str(chat.id)
                channel_name = chat.title or username

                bot_member = await context.bot.get_chat_member(channel_id, context.bot.id)
                if bot_member.status not in ['administrator', 'creator']:
                    await update.message.reply_text(
                        f"❌ البوت ليس مشرفاً في القناة!\n\n"
                        f"⚠️ يرجى رفع البوت مشرفاً في @{username} ثم المحاولة مرة أخرى"
                    )
                    return

                context.user_data['temp_mandatory_channel_username'] = f"@{username}"
                context.user_data['waiting_for'] = 'mandatory_channel_members'

                await update.message.reply_text(
                    f"✅ تم التحقق من القناة: {channel_name}\n\n"
                    f"📢 الآن أرسل العدد المطلوب من الأعضاء للقناة الإجبارية:"
                )

            except Exception as e:
                await update.message.reply_text(f"❌ خطأ في التحقق من القناة: {str(e)}")
                context.user_data['waiting_for'] = None

        except Exception as e:
            await update.message.reply_text(f"❌ حدث خطأ: {str(e)}")
            context.user_data['waiting_for'] = None

    async def handle_mandatory_channel_members(self, update: Update, context: ContextTypes.DEFAULT_TYPE, members_text):
        try:
            members_count = int(members_text.strip())

            if members_count <= 0:
                await update.message.reply_text("❌ عدد الأعضاء يجب أن يكون أكبر من صفر!")
                return

            context.user_data['temp_mandatory_channel_members'] = members_count
            context.user_data['waiting_for'] = 'mandatory_channel_invite'
            await update.message.reply_text(
                f"✅ تم تعيين العدد المطلوب: {members_count} عضو\n\n"
                f"🔗 الآن أرسل رابط الدعوة للقناة:"
            )
        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")
        except Exception as e:
            await update.message.reply_text(f"❌ حدث خطأ: {str(e)}")
            context.user_data['waiting_for'] = None

    async def handle_mandatory_channel_invite(self, update: Update, context: ContextTypes.DEFAULT_TYPE, invite_text):
        try:
            invite_link = invite_text.strip()
            if not invite_link.startswith(('https://t.me/', 'http://t.me/', 't.me/')):
                await update.message.reply_text("❌ رابط الدعوة غير صحيح!")
                return
            if invite_link.startswith('t.me/'):
                invite_link = 'https://' + invite_link
            elif invite_link.startswith('http://'):
                invite_link = invite_link.replace('http://', 'https://')
            channel_username = context.user_data.get('temp_mandatory_channel_username')
            members_required = context.user_data.get('temp_mandatory_channel_members')
            if not channel_username or not members_required:
                await update.message.reply_text("❌ خطأ في البيانات، يرجى المحاولة مرة أخرى")
                context.user_data['waiting_for'] = None
                return
            try:
                chat = await context.bot.get_chat(channel_username)
                channel_id = str(chat.id)
                channel_name = chat.title or channel_username
                bot_member = await context.bot.get_chat_member(channel_id, context.bot.id)
                if bot_member.status not in ['administrator', 'creator']:
                    await update.message.reply_text(
                        f"❌ البوت ليس مشرفاً في القناة!\n\n"
                        f"⚠️ يرجى رفع البوت مشرفاً في {channel_username} ثم المحاولة مرة أخرى"
                    )
                    return
                self.mandatory_channels[channel_id] = {
                    "name": channel_name,
                    "username": channel_username,
                    "invite_link": invite_link,
                    "members_required": members_required,
                    "total_subscribers_count": 0,
                    "added_date": str(datetime.now()),
                    "added_by": update.effective_user.id
                }
                self.save_data_to_db('mandatory_channels', self.mandatory_channels)
                context.user_data['waiting_for'] = None
                if 'temp_mandatory_channel_username' in context.user_data:
                    del context.user_data['temp_mandatory_channel_username']
                if 'temp_mandatory_channel_members' in context.user_data:
                    del context.user_data['temp_mandatory_channel_members']
                await update.message.reply_text(
                    f"✅ تم إضافة القناة الإجبارية بنجاح!\n\n"
                    f"📺 القناة: {channel_name}\n"
                    f"👥 العدد المطلوب: {members_required}\n"
                    f"🔗 رابط الدعوة: {invite_link}\n\n"
                    f"📅 تاريخ الإضافة: {self.format_time_12h(datetime.now())}"
                )
            except Exception as e:
                await update.message.reply_text(f"❌ خطأ في التحقق من القناة: {str(e)}")
                context.user_data['waiting_for'] = None
        except Exception as e:
            await update.message.reply_text(f"❌ حدث خطأ: {str(e)}")
            context.user_data['waiting_for'] = None
    async def show_services_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        keyboard = [
            [InlineKeyboardButton("شراء نجوم", callback_data="stars_section"),
            InlineKeyboardButton("خدمات الرشق", callback_data="rush_services"),],
            [InlineKeyboardButton(" القائــمة الـرئـيـسـية 🔙 ", callback_data="back_to_main")]
        ]
        await update.callback_query.edit_message_text(
            "🛍️ اختر الخدمة المطلوبة:\n",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def show_funding_section(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        keyboard = [
            [InlineKeyboardButton("تمويل قناة أو مجموعة 📣", callback_data="fund_channel"),
            InlineKeyboardButton("تمويل بوتات 🤖", callback_data="fund_bots")],
            [InlineKeyboardButton("تمويلاتي (💼)", callback_data="my_fundings")],
        ]
        await update.callback_query.edit_message_text(
            "💥| اهلا بك في قسم التمويل \n"
            "🐲|يمكنك تمويل أعضاء حقيقين 100% للقنوات والبوتا\n"
            "🚏|يمكنك أيضا معرفة حالات تمويلاتك الحالية",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def show_stars_section(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        keyboard = [
            [
                InlineKeyboardButton("⭐ 15", callback_data="buy_stars_15"),
                InlineKeyboardButton("⭐ 25", callback_data="buy_stars_25"),
                InlineKeyboardButton("⭐ 50", callback_data="buy_stars_50")
            ],
            [
                InlineKeyboardButton("⭐ 100", callback_data="buy_stars_100"),
                InlineKeyboardButton("⭐ 200", callback_data="buy_stars_200"),
                InlineKeyboardButton("⭐ 300", callback_data="buy_stars_300")
            ],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="services_menu")]
        ]
        await update.callback_query.edit_message_text(
            "🔻 اختر عدد النجوم التي تريد الحصول على الهدية مقابلها:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def handle_stars_purchase(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        stars = int(data.split("_")[2])
        price = self.stars_prices[stars]
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        if user["points"] < price:
            await update.callback_query.edit_message_text(
                f"❌ رصيدك غير كافٍ!\n\n"
                f"💰 تحتاج: {self.format_points(price)} 🍪\n"
                f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪\n\n"
                f"💡 يمكنك الحصول على كوكيز من خلال:\n"
                f"🔗 دعوة الأصدقاء\n"
                f"📺 الاشتراك في القنوات",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="stars_section")]])
            )
            return
        keyboard = [
            [
                InlineKeyboardButton("إلغاء", callback_data="stars_section"),
                InlineKeyboardButton("تأكيد الشراء", callback_data=f"confirm_stars_{stars}")
            ]
        ]
        await update.callback_query.edit_message_text(
            f"📮 تأكيد عملية الشراء!\n\n"
            f"⭐ عدد النجوم: {stars}\n"
            f"🍪 التكلفة: {self.format_points(price)}\n\n"
            f"عند تأكيدك للشراء سيتم ارسال النجوم لحسابك هذا فوراً",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def confirm_stars_purchase(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        stars = int(data.split("_")[2])
        price = self.stars_prices[stars]
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        user["points"] -= price

        purchase_id = f"{user_id}_{int(datetime.now().timestamp())}"
        self.stars_purchases[purchase_id] = {
            "user_id": user_id,
            "stars": stars,
            "price": price,
            "date": str(datetime.now()),
            "delivered": False
        }
        self.save_json(STARS_PURCHASES_FILE, self.stars_purchases)
        await update.callback_query.edit_message_text(
            f"🎯 تم تأكيد عملية الشراء بنجاح!\n\n"
            f"⭐ عدد النجوم: {stars}\n"
            f"🍪 التكلفة: {self.format_points(price)}\n\n"
            f"يرجى إرسال أي رسالة إلى الحساب التالي: @cxxov\n"
            f"📩 لا تنتظر الرد، فقط أرسل الرسالة ليتمكن البوت من متابعة إرسال الهدية.\n\n"
            f"كل الامتنان لثقتك بنا، ونأمل أن نكون عند حسن الظن."
        )
        try:
            safe_first_name = self.escape_markdown(update.effective_user.first_name)
            safe_username = ""
            if update.effective_user.username:
                safe_username = self.escape_markdown(f"@{update.effective_user.username}")
            else:
                safe_username = "لا يوجد يوزرنيم"
            user_link_admin = f"[{user_id}](tg://user?id={user_id})"
            keyboard = [[InlineKeyboardButton("تم التسليم ☑️", callback_data=f"delivered_stars_{purchase_id}")]]
            await context.bot.send_message(
                ADMIN_ID,
                f"🔔 طلب شراء نجوم جديد:\n\n"
                f"👤 العميل: {safe_first_name}\n"
                f"📝 اليوزر: {safe_username}\n"
                f"🆔 الآيدي: {user_link_admin}\n"
                f"⭐ عدد النجوم: {stars}\n"
                f"📅 وقت الطلب: {self.format_time_12h(datetime.now())}",
                parse_mode='MarkdownV2',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        except Exception as e:
            logger.error(f"فشل في إرسال إشعار شراء النجوم: {e}")
    async def handle_stars_delivery_confirmation(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        purchase_id = data.split("_", 2)[2]
        if purchase_id not in self.stars_purchases:
            await update.callback_query.edit_message_text("❌ لم يتم العثور على عملية الشراء!")
            return
        purchase = self.stars_purchases[purchase_id]
        customer_user_id = purchase["user_id"]
        stars = purchase["stars"]
        self.stars_purchases[purchase_id]["delivered"] = True
        self.stars_purchases[purchase_id]["delivery_date"] = str(datetime.now())
        self.save_json(STARS_PURCHASES_FILE, self.stars_purchases)
        user = self.get_user(customer_user_id)
        try:
            await context.bot.send_message(
                customer_user_id,
                f"🌟 تم تأكيد آخر شراء لك بمبلغ {stars} نجمة!\n\n"
                f"شكراً لك على استخدام البوت! 💫"
            )
            await update.callback_query.edit_message_text(
                f"✅ تم تأكيد التسليم بنجاح!\n\n"
                f"👤 العميل: {customer_user_id}\n"
                f"⭐ عدد النجوم: {stars}\n"
                f"📊 رصيده الحالي: {self.format_points(user['points'])} 🍪\n"
                f"📅 وقت التأكيد: {self.format_time_12h(datetime.now())}"
            )
        except Exception as e:
            await update.callback_query.edit_message_text(
                f"❌ خطأ في إرسال التأكيد للمستخدم {customer_user_id}\n\n"
                f"الخطأ: {str(e)}"
            )
    async def show_fund_channel_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        if self.maintenance_mode["fund_channel"]:
            await update.callback_query.edit_message_text(
                self.maintenance_messages["fund_channel"],
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
            )
            return
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        context.user_data['waiting_for'] = 'fund_channel_members'
        keyboard = [[InlineKeyboardButton("رجوع (🔙)", callback_data="funding_section")]]
        max_affordable_members_channel = int(user['points'] // self.member_price)
        await update.callback_query.edit_message_text(
            text=f"*تمويل اعضاء حقيقية 100% 📣\n\n*"
                 f"> • كل 1 عضو 👤 \\= 8 كوكيز\n\n"
                    f">🪫 أقل عدد للتمويل: {self.min_funding_members} عضو\n\n"
                 f">🎖️ يمكنك تمويل: {max_affordable_members_channel} عضو\n\n"
                f"*• ارسل عدد الاعضاء المراد تمويلها 📬:*\n",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='MarkdownV2'
        )
    async def handle_quick_fund(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        members = int(data.split("_")[2])
        if members < self.min_funding_members:
            return
        required_points = float(members * self.member_price)
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        if user["points"] < required_points:
            await update.callback_query.edit_message_text(
                f"❌ رصيدك غير كافٍ!\n\n"
                f"💰 تحتاج: {self.format_points(required_points)} 🍪\n"
                f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪\n\n"
                f"💡 يمكنك الحصول على كوكيز من خلال:\n"
                f"🔗 دعوة الأصدقاء\n"
                f"📺 الاشتراك في القنوات",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="fund_channel")]])
            )
            return
        context.user_data['temp_fund_members'] = members
        context.user_data['temp_fund_cost'] = required_points
        context.user_data['waiting_for'] = 'fund_channel_username'
        bot_info = await update.get_bot().get_me()
        bot_username = f"@{bot_info.username}" if bot_info.username else "البوت"
        await update.callback_query.edit_message_text(
            f"👥] عدد الأعضاء: {members}\n"
            f"💰] التكلفة الإجمالية: {self.format_points(required_points)} 🍪\n\n"
            f"⚠️] ارفع البوت {bot_username} أدمن في قناتك أو مجموعتك\n\n"
            f"• ثم أرسل يوزر القناة مع @",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="fund_channel")]])
        )
    async def confirm_funding(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        members = int(data.split("_")[2])
        required_points = float(members * self.member_price)
        user["points"] -= required_points

    async def show_wheel_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        await self.delete_old_mandatory_message(context, user_id)
        today = datetime.now().date().strftime('%Y-%m-%d')
        user_spins_today = self.wheel_spins.get(str(user_id), {}).get(today, 0)
        remaining_spins = 2 - user_spins_today
        if remaining_spins <= 0:
            await update.callback_query.edit_message_text(
                "⚠️ لقد استنفدت مرات التدوير اليوم!\n\n"
                "🎡 يمكنك تدوير العجلة مرتين فقط كل يوم\n"
                "⏰ عد غداً لمحاولات جديدة\n\n"
                f"📊 التدويرات اليوم: {user_spins_today}/2",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
            )
            return
        if user["points"] < self.wheel_spin_cost:
            await update.callback_query.edit_message_text(
                f"❌ رصيدك غير كافٍ!\n\n"
                f"💰 تحتاج: {self.wheel_spin_cost} 🍪 لتدوير العجلة\n"
                f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪\n"
                f"🎡 التدويرات المتبقية اليوم: {remaining_spins}/2",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
            )
            return
        user_link = f"[{update.effective_user.first_name}](tg://user?id={user_id})"
        next_prize = self.wheel_gift_first if user_spins_today == 0 else self.wheel_gift_second
        keyboard = [
            [InlineKeyboardButton(f"🎡 تدوير العجلة ({self.wheel_spin_cost} 🍪)", callback_data="spin_wheel")],
            [InlineKeyboardButton("❌ إلغاء", callback_data="back_to_main")]
        ]
        await update.callback_query.edit_message_text(
            f"🎡 أهلاً بك عزيزي {user_link} في عجلة الحظ\n\n"
            f"🎁 الجائزة القادمة: {next_prize}\n"
            f"🔄 التدوير رقم: {user_spins_today + 1}/2\n"
            f"📊 التدويرات المتبقية: {remaining_spins}\n\n"
            f"💰 سعر التدوير: {self.wheel_spin_cost} 🍪\n"
            f"✨ الجوائز يتم تسليمها تلقائياً فور الفوز! 🎉",
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def handle_wheel_spin(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        user["points"] -= self.wheel_spin_cost
        self.record_wheel_spin(user_id)

        await update.callback_query.edit_message_text(
            f"تم خصم {self.wheel_spin_cost} 🍪 وجاري تدوير العجلة...",
            reply_markup=None
        )
        await asyncio.sleep(1)
        await self.wheel_animation(update, context)
    async def wheel_animation(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        prizes = self.wheel_prizes
        spins = 2
        for spin in range(spins):
            for prize_idx in range(len(prizes)):
                display_text = "🎡 تدوير العجلة...\n"
                for idx, prize in enumerate(prizes):
                    if idx == prize_idx:
                        display_text += f"{prize} ☚\n"
                    else:
                        display_text += f"{prize}\n"
                try:
                    await update.callback_query.edit_message_text(display_text)
                    await asyncio.sleep(0.20)  # 250 ملي ثانية
                except:
                    pass 
        await self.show_wheel_result(update, context)
    async def show_wheel_result(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        today = datetime.now().date().strftime('%Y-%m-%d')
        user_spins_today = self.wheel_spins.get(str(user_id), {}).get(today, 0)
        won_prize = self.wheel_gift_first if user_spins_today == 1 else self.wheel_gift_second
        user_link = f"[{update.effective_user.first_name}](tg://user?id={user_id})"
        try:
            prize_text = won_prize.replace("🍪", "")
            prize_text = prize_text.replace("³", "3").replace("²", "2").replace("¹", "1").replace("⁰", "0")
            stars_won = int(prize_text)
            user["points"] += stars_won

            remaining_spins = 2 - user_spins_today
            spin_text = "يمكنك اللعب مرة أخرى اليوم!" if remaining_spins > 0 else "انتهت محاولاتك لهذا اليوم، عد غداً!"
            await update.callback_query.edit_message_text(
                f"🎊 مبروك عزيزي {user_link}!\n"
                f"🎁 لقد ربحت: {won_prize}\n"
                f"✅ تم إضافة {stars_won} كوكيز إلى رصيدك تلقائياً\n"
                f"💰 رصيدك الحالي: {self.format_points(user['points'])} 🍪\n\n"
                f"🎡 {spin_text}",
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
            )
            try:
                user_link_admin = f"[{user_id}](tg://user?id={user_id})"
                safe_first_name = self.escape_markdown(update.effective_user.first_name)
                safe_username = ""
                if update.effective_user.username:
                    safe_username = self.escape_markdown(f"@{update.effective_user.username}")
                else:
                    safe_username = "لا يوجد يوزرنيم"
                await context.bot.send_message(
                    ADMIN_ID,
                    f"🎡 جائزة عجلة الحظ \\(تلقائي\\)\\!\n\n"
                    f"👤 الفائز: {safe_first_name}\n"
                    f"📝 اليوزر: {safe_username}\n"
                    f"🆔 الآيدي: {user_link_admin}\n"
                    f"🎁 الجائزة: {won_prize} \\({stars_won} كوكيز\\)\n"
                    f"🔄 التدوير رقم: {user_spins_today}/2\n"
                    f"📅 التاريخ: {self.format_time_12h(datetime.now())}",
                    parse_mode='MarkdownV2'
                )
            except Exception as e:
                logger.error(f"فشل في إرسال إشعار عجلة الحظ: {e}")

        except Exception as e:
            logger.error(f"Error processing wheel prize: {e}")
            await update.callback_query.edit_message_text(
                f"❌ حدث خطأ في معالجة الجائزة!\n"
                f"يرجى التواصل مع الإدارة: @cxxov",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
            )

    async def show_invite_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        try:
            bot_username = (await context.bot.get_me()).username
            invite_link = f"https://t.me/{bot_username}?start={user['invite_link']}"

            successful_invites = user.get("referrals_count", 0)

            share_message = (
                f"@s1x2bot ⌁︙ أنضم الى بوت تيربو فولو  ↫⤈\n"
                f"⌁︙عندما تقوم بتفعيل البوت \n"
                f"⌁︙ سوف تحصل على ↫ 100 كوكيز\n"
                f"⌁︙رشق لايكات مسابقة اشتراك إجباري حسابات عربية\n"
                f"⌁︙يوفر تمويل القنوات والمجموعات والبوتات حقيقي 100%\n"
                f"⌁︙ يمكنك شراء نجوم تسليم تلقائي\n"
                f"⌁︙البوت يمتاز بسرعة تنفيذ الطلب ✓ .\n"
                f"⌁︙ رابط البوت ↫⤈\n"
                f"{invite_link}"
            )

            import urllib.parse
            encoded_message = urllib.parse.quote(share_message)
            share_url = f"https://t.me/share/url?url={encoded_message}"

            message_text = (
                  f"🗳️ احصل على {self.format_points(self.invite_points)} 🍪 مقابل كل دعوة!\n"
                f"🔗 رابط الدعوة الخاص بك:\n\n"
                f"`{invite_link}`\n\n"

                f"📮 عدد دعواتك: {successful_invites}\n\n"
            )

            try:
                if self.top_referrers and len(self.top_referrers) > 0:
                    message_text += "🏆 المستخدمين الاكثر مشاركة لرابط الدعوة:\n"
                    medals = ["🥇", "🥈", "🥉"]
                    for i, referrer in enumerate(self.top_referrers[:3]):
                        medal = medals[i] if i < len(medals) else "🎖️"
                        try:
                            user_chat = await context.bot.get_chat(int(referrer["user_id"]))
                            if user_chat.username:
                                user_link = f"[{referrer['user_id']}](tg://user?id={referrer['user_id']})"
                            else:
                                user_link = f"`{referrer['user_id']}`"
                            message_text += f"{medal} {user_link} - {referrer['count']}\n"
                        except:
                            message_text += f"{medal} `{referrer['user_id']}` - {referrer['count']}\n"
            except Exception as e:
                pass

            keyboard = [
            [InlineKeyboardButton("مشاركة رابط الدعوة 📤", url=share_url)],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]
        ]

            await update.callback_query.edit_message_text(
                message_text,
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )

        except Exception as e:
            try:
                bot_username = (await context.bot.get_me()).username
                invite_link = f"https://t.me/{bot_username}?start={user['invite_link']}"
                successful_invites = user.get("referrals_count", 0)

                simple_text = (
                    f"🔗 رابط الدعوة:\n\n"
                    f"`{invite_link}`\n\n"
                    f"🍪 {self.format_points(self.invite_points)} كوكيز لكل دعوة\n"
                    f"🎯 دعواتك: {successful_invites}"
                )

                keyboard = [[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]]

                await update.callback_query.edit_message_text(
                    simple_text,
                    parse_mode='Markdown',
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            except Exception as e2:
                await self.show_main_menu(update, context)

    async def show_collect_cookies(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        if not self.paid_channels:
            keyboard = [
                [
                    InlineKeyboardButton("رابط الدعوة (🔗)", callback_data="invite_link")
                ],
                [InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]
            ]

            await update.callback_query.edit_message_text(
                "⚠️ لا توجد قنوات متاحة حالياً للتجميع.\n\n"
                "تحقق لاحقاً للحصول على فرص جديدة لكسب الكوكيز!",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return

        keyboard = [
            [
                InlineKeyboardButton("📣 (×10) ⬅️", callback_data="collect_bulk"),
                InlineKeyboardButton("الاشتراك بالقنوات 📣", callback_data="collect_single")
            ],
            [
                InlineKeyboardButton("( - 🤖 الاشتراك بالبوتات 🤖 - )", callback_data="bot_subscription"),
            ],
            [
               InlineKeyboardButton("الهدية اليومية (🎁)", callback_data="daily_gift"),

               InlineKeyboardButton(" رابط الدعوة (🔗)", callback_data="invite_link")
            ],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            "• مرحبا بك في قسم تجميع النقاط 〽️\n"
            "- يمكنك تجميع النقاط بأكثر من طريقة. 📢\n",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_single_collect(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id

        channel_id, channel_info = await self.get_next_paid_channel(user_id, context)

        if not channel_id:
            await update.callback_query.edit_message_text(
                "⏳ لا يوجد قنوات في الوقت الحالي، قم بتجميع النقاط بطريقة مختلفة\n"
                "🚫 إذا قمت بمغادرة أي قناة سيتم خصم الكوكيز منك.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]])
            )
            return

        channel_username = channel_info['name']
        invite_link = channel_info.get('invite_link', '')

        if 't.me/' in invite_link:
            try:
                username_part = invite_link.split('t.me/')[-1]
                if not username_part.startswith('+') and '/' not in username_part:
                    channel_username = f"@{username_part}"
            except:
                pass

        keyboard = [
            [InlineKeyboardButton(f"{channel_info['name']}", url=channel_info.get('invite_link', ''))],
            [InlineKeyboardButton("تحقق ✅", callback_data=f"check_paid_{channel_id}")],
            [InlineKeyboardButton("تخطي 🔂", callback_data=f"skip_channel_{channel_id}")],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]
        ]
        await update.callback_query.edit_message_text(
            f"اشترك بالقناة : {channel_username}\n"
            f"�س�|• وأَحصل على :  {self.format_points(channel_info['points'])} 🍪\n\n",
            reply_markup=InlineKeyboardMarkup(keyboard),
            disable_web_page_preview=True
        )
    async def show_bulk_collect(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        available_channels = []
        user_subscriptions = self.user_channel_subscriptions.get(str(user_id), {})

        for channel_id, channel_info in self.paid_channels.items():
            if channel_id not in user_subscriptions and len(available_channels) < 10:
                available_channels.append((channel_id, channel_info))
        if not available_channels:
            await update.callback_query.edit_message_text(
                "🎯 لقد اشتركت في جميع القنوات المتاحة!\n\n"
                "🔰 للحفاظ على رصيدك، يُرجى عدم مغادرة القنوات.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]])
            )
            return
        total_cookies = sum(channel_info['points'] for _, channel_info in available_channels)
        text = f"• اشترك في جميع القنوات أدناه 🚸 لكي تحصل على : {self.format_points(total_cookies)} كوكيز 🍪\n\�n"
        keyboard = []
        user_reports = getattr(self, 'user_reports', {})
        user_id_str = str(user_id)
        if user_id_str not in user_reports:
            user_reports[user_id_str] = {'bots': set(), 'channels': set()}
        self.user_reports = user_reports
        for channel_id, channel_info in available_channels:
            row = [InlineKeyboardButton(f"📺 {channel_info['name']}", url=channel_info['invite_link'])]
        for channel_id, channel_info in available_channels:
            row = [InlineKeyboardButton(f"{channel_info['name']}", url=channel_info['invite_link'])]
            if channel_id not in user_reports[user_id_str]['channels']:
                row.append(InlineKeyboardButton("ابلاغ ⚠️", callback_data=f"report_channel_{channel_id}"))
            else:
                row.append(InlineKeyboardButton("تم البلاغ ⚠️", callback_data="already_reported"))
            keyboard.append(row)
        keyboard.append([InlineKeyboardButton("التحقق من الاشتراك ✅", callback_data="check_bulk_subscriptions")])
        keyboard.append([InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")])
        context.user_data['bulk_channels'] = available_channels
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            disable_web_page_preview=True
        )
    async def check_bulk_subscriptions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        await update.callback_query.edit_message_text("⏳ جاري التحقق من اشتراكاتك...")
        bulk_channels = context.user_data.get('bulk_channels', [])
        if not bulk_channels:
            await update.callback_query.edit_message_text(
                "❌ خطأ، يرجى المحاولة مرة أخرى",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]])
            )
            return
        successful_subscriptions = 0
        total_cookies_earned = 0
        for channel_id, channel_info in bulk_channels:
            try:
                is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
                if is_member:
                    if str(user_id) not in self.user_channel_subscriptions:
                        self.user_channel_subscriptions[str(user_id)] = {}
                    if channel_id not in self.user_channel_subscriptions[str(user_id)]:
                        user['points'] += channel_info['points']
                        total_cookies_earned += channel_info['points']
                        successful_subscriptions += 1
                        self.user_channel_subscriptions[str(user_id)][channel_id] = {
                            "points": channel_info['points'],
                            "date": str(datetime.now())
                        }
                        if 'total_subscribers_count' not in self.paid_channels[channel_id]:
                            self.paid_channels[channel_id]['total_subscribers_count'] = 0
                        self.paid_channels[channel_id]['total_subscribers_count'] += 1

                        if channel_id in self.funded_channels:
                            funded_info = self.funded_channels[channel_id]
                            owner_id = funded_info['owner_id']
                            current_count = self.paid_channels[channel_id].get('total_subscribers_count', 0)
                            required_count = self.paid_channels[channel_id]['members_required']
                            remaining = max(0, required_count - current_count)
                            try:
                                channel_link = f"[{channel_info['name']}]({channel_info['invite_link']})"
                                await context.bot.send_message(
                                    owner_id,
                                    f"🎖️ اشترك شخص جديد في قناتك {channel_link}\n\n"
                                    f"👥] العدد المتبقي: {remaining}",
                                    parse_mode='Markdown',
                                    disable_web_page_preview=True
                                )
                            except:
                                try:
                                    await context.bot.send_message(
                                        owner_id,
                                        f"🎖️ اشترك شخص جديد في قناتك!\n"
                                        f"📮 {channel_info['name']}\n"
                                        f"العدد المتبقي: {remaining}"
                                    )
                                except:
                                    pass
                        if self.paid_channels[channel_id]['total_subscribers_count'] >= channel_info['members_required']:
                            funding_number = None
                            for fund_num, fund_record in self.funding_numbers["records"].items():
                                if fund_record.get("channel_id") == channel_id and fund_record.get("funding_type") == "channel":
                                    funding_number = fund_num
                                    self.update_funding_status(fund_num, "مكتمل")
                                    break

                            if channel_id in self.funded_channels:
                                funded_info = self.funded_channels[channel_id]
                                owner_id = funded_info['owner_id']
                                current_count = self.paid_channels[channel_id]['total_subscribers_count']

                                funding_record = self.get_funding_record_by_id(channel_id, "channel")
                                correct_funding_number = funding_record.get("funding_number", "غير متاح") if funding_record else "غير متاح"

                                try:
                                    await context.bot.send_message(
                                        owner_id,
                                        f"🎉] تهانينا! تم اكتمال تمويل قناتك {current_count} عضو بنجاح!\n"
                                        f"📣] القناة: {channel_info['name']}\n"
                                        f"🆔] رقم التمويل: #{correct_funding_number}\n"
                                        f"💼] يمكنك مراجعة التمويل في قسم 'تمويلاتي'\n"
                                    )
                                except Exception as e:
                                    print(f"Error sending message to owner: {e}")

                                try:
                                    await context.bot.send_message(
                                        ADMIN_ID,
                                        f"✅ تم إشعار صاحب التمويل ({owner_id}) بإكتمال تمويل القناة {channel_info['name']} بنجاح"
                                    )
                                except Exception as e:
                                    print(f"Error sending message to admin: {e}")
                                except Exception as e:
                                    logger.error(f"فشل في إرسال تأكيد الإشعار للأدمن: {e}")

                                    try:
                                        await context.bot.send_message(
                                            ADMIN_ID,
                                            f"❌ فشل إشعار صاحب التمويل ({owner_id}) بإكتمال القناة {channel_info['name']}\n"
                                            f"السبب: {str(e)}"
                                        )
                                    except:
                                        pass

                            if channel_id in self.funded_channels:
                                self.funded_channels[channel_id]['status'] = 'مكتمل'
                                self.funded_channels[channel_id]['completion_date'] = str(datetime.now())
                                self.funded_channels[channel_id]['final_members_count'] = self.paid_channels[channel_id]['total_subscribers_count']

                                self.move_funding_to_completed(channel_id, "channel")

                            try:
                                funding_record = self.get_funding_record_by_id(channel_id, "channel")
                                correct_funding_number = funding_record.get("funding_number", "غير متاح") if funding_record else "غير متاح"

                                await context.bot.send_message(
                                    ADMIN_ID,
                                    f"🎉 تم إكمال العدد المطلوب للقناة!\n\n"
                                    f"📺 القناة: {channel_info['name']}\n"
                                    f"👥 العدد المطلوب: {channel_info['members_required']}\n"
                                    f"✅ العدد الحالي: {self.paid_channels[channel_id]['total_subscribers_count']}\n"
                                    f"🔢 رقم التمويل: #{correct_funding_number}\n\n"
                                    f"✅ تم حفظ التمويل في الأرشيف وإزالته من القائمة النشطة."
                                )
                            except Exception as e:
                                logger.error(f"فشل في إرسال إشعار الاكتمال للأدمن: {e}")

                            if channel_id in self.paid_channels:
                                del self.paid_channels[channel_id]
                            if channel_id in self.monitored_channels:
                                del self.monitored_channels[channel_id]
                            if channel_id in self.funded_channels:
                                del self.funded_channels[channel_id]
                            for user_id_loop, user_data_loop in self.users.items():
                                if "funded_channels" in user_data_loop and channel_id in user_data_loop["funded_channels"]:
                                    user_data_loop["funded_channels"].remove(channel_id)
                        if channel_id in self.funded_channels:
                            funded_info = self.funded_channels[channel_id]
                            owner_id = funded_info['owner_id']
                            current_count = self.paid_channels[channel_id].get('total_subscribers_count', 0)
                            required_count = self.paid_channels[channel_id]['members_required']
                            remaining = max(0, required_count - current_count)
                            try:
                                channel_link = f"[{channel_info['name']}]({channel_info['invite_link']})"
                                await context.bot.send_message(
                                    owner_id,
                                    f"🎖️ اشترك شخص جديد في قناتك {channel_link}\n\n"
                                    f"👥] العدد المتبقي: {remaining}",
                                    parse_mode='Markdown',
                                    disable_web_page_preview=True
                                )
                            except:
                                try:
                                    await context.bot.send_message(
                                        owner_id,
                                        f"🎖️ اشترك شخص جديد في قناتك!\n"
                                        f"📮 {channel_info['name']}\n"
                                        f"العدد المتبقي: {remaining}"
                                    )
                                except:
                                    pass
            except Exception as e:
                logger.error(f"خطأ في فحص القناة {channel_id}: {e}")

        self.save_json(USER_CHANNEL_SUBSCRIPTION_FILE, self.user_channel_subscriptions)
        self.save_data_to_db('paid_channels', self.paid_channels)
        self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)
        self.save_json(MONITORED_CHANNELS_FILE, self.monitored_channels)
        if 'bulk_channels' in context.user_data:
            del context.user_data['bulk_channels']
        if successful_subscriptions > 0:
            keyboard = [
                [InlineKeyboardButton("تجميع المزيد", callback_data="collect_more")],
                [InlineKeyboardButton("القائمة الرئيسية (🔙)", callback_data="back_to_main")]
            ]
            await update.callback_query.edit_message_text(
                f"🎉 لقد اشتركت في {successful_subscriptions} قناة وتم اعطاؤك {self.format_points(total_cookies_earned)} 🍪\n"
                f"⚠️ اذا غادرت سيتم خصم الكوكيز منك",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            keyboard = [
                [InlineKeyboardButton("(🏧) تجميع المزيد (🏧)", callback_data="collect_more")],
                [InlineKeyboardButton("رجوع (🔙) للقائمة", callback_data="back_to_main")]
            ]
            await update.callback_query.edit_message_text(
                "❌ لم يتم العثور على اشتراكات جديدة\n\n"
                "تأكد من الاشتراك في القنوات أولاً",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
    async def skip_current_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        user_id = update.effective_user.id
        current_channel_id = data.split("_")[2]

        next_channel_id, next_channel_info = await self.get_next_paid_channel_after_skip(user_id, current_channel_id, context)

        if next_channel_id:
            keyboard = [
                [InlineKeyboardButton("تحقق ✅", callback_data=f"check_paid_{next_channel_id}")],
                [InlineKeyboardButton("تخطي 🔂", callback_data=f"skip_channel_{next_channel_id}")],
                [InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]
            ]
            await update.callback_query.edit_message_text(
                f"🛎️|• اشترك في : {next_channel_info['name']}\n"
                f"🎁|• وأَحصل على :  {self.format_points(next_channel_info['points'])} 🍪\n\n",
                reply_markup=InlineKeyboardMarkup(keyboard),
                disable_web_page_preview=True
            )
        else:
            await update.callback_query.edit_message_text(
                "✅ لقد مررت بجميع القنوات المتاحة!\n\n"
                "🔒 للحفاظ على رصيدك، يُرجى عدم مغادرة القنوات.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]])
            )
    async def check_paid_subscription(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        channel_id = data.split("_")[2]
        if channel_id not in self.paid_channels:
            await update.callback_query.edit_message_text(
                "❌ القناة غير متاحة!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]])
            )
            return
        channel_info = self.paid_channels[channel_id]
        is_member = await self.is_user_member_of_channel(context, channel_id, user_id)
        if is_member:
            if str(user_id) not in self.user_channel_subscriptions:
                self.user_channel_subscriptions[str(user_id)] = {}
            if channel_id not in self.user_channel_subscriptions[str(user_id)]:
                user['points'] += channel_info['points']


                self.user_channel_subscriptions[str(user_id)][channel_id] = {
                    "points": channel_info['points'],
                    "date": str(datetime.now())
                }
                self.save_json(USER_CHANNEL_SUBSCRIPTION_FILE, self.user_channel_subscriptions)
                if 'total_subscribers_count' not in self.paid_channels[channel_id]:
                    self.paid_channels[channel_id]['total_subscribers_count'] = 0
                self.paid_channels[channel_id]['total_subscribers_count'] += 1
                self.save_data_to_db('paid_channels', self.paid_channels)
                if channel_id in self.funded_channels:
                    funded_info = self.funded_channels[channel_id]
                    owner_id = funded_info['owner_id']
                    current_count = self.paid_channels[channel_id]['total_subscribers_count']
                    required_count = channel_info['members_required']
                    remaining = max(0, required_count - current_count)

                    try:
                        channel_link = f"[{channel_info['name']}]({channel_info['invite_link']})"
                        await context.bot.send_message(
                            owner_id,
                            f"🎖️ اشترك شخص جديد في قناتك {channel_link}\n\n"
                            f"👥] العدد المتبقي: {remaining}",
                            parse_mode='Markdown',
                            disable_web_page_preview=True
                        )
                    except:
                        try:
                            await context.bot.send_message(
                                owner_id,
                                f"🎖️ اشترك شخص جديد في قناتك!\n"
                                f"📮 {channel_info['name']}\n"
                                f"العدد المتبقي: {remaining}"
                            )
                        except:
                            pass
                if self.paid_channels[channel_id]['total_subscribers_count'] >= channel_info['members_required']:
                    funding_number = None
                    for fund_num, fund_record in self.funding_numbers["records"].items():
                        if fund_record.get("channel_id") == channel_id and fund_record.get("funding_type") == "channel":
                            funding_number = fund_num
                            self.update_funding_status(fund_num, "مكتمل")
                            break

                    if channel_id in self.funded_channels:
                        funded_info = self.funded_channels[channel_id]
                        owner_id = funded_info['owner_id']
                        current_count = self.paid_channels[channel_id]['total_subscribers_count']

                        funding_record = self.get_funding_record_by_id(channel_id, "channel")
                        correct_funding_number = funding_record.get("funding_number", "غير متاح") if funding_record else "غير متاح"

                        try:
                            await context.bot.send_message(
                                owner_id,
                                f"🎉 تهانينا! تم اكتمال تمويل قناتك بنجاح!\n\n"
                                f"📣 القناة: {channel_info['name']}\n"
                                f"👥 العدد المكتمل: {current_count}\n"
                                f"🆔 رقم التمويل: #{correct_funding_number}\n"
                                f"💰 التكلفة المدفوعة: {self.format_points(funded_info.get('cost_paid', 0))} 🍪\n\n"
                                f"💼 يمكنك مراجعة التمويل في قسم 'تمويلاتي'\n"
                                f"✅ يمكنك تمويل القناة مرة أخرى إذا كنت تريد المزيد من الأعضاء"
                            )

                            try:
                                await context.bot.send_message(
                                    ADMIN_ID,
                                    f"✅ تم إشعار صاحب التمويل ({owner_id}) بإكتمال تمويل القناة {channel_info['name']} بنجاح"
                                )
                            except Exception as e:
                                logger.error(f"فشل في إرسال تأكيد الإشعار للأدمن: {e}")

                        except Exception as e:
                            logger.error(f"فشل في إرسال إشعار الاكتمال لصاحب التمويل {owner_id}: {e}")
                            try:
                                await context.bot.send_message(
                                    ADMIN_ID,
                                    f"❌ فشل إشعار صاحب التمويل ({owner_id}) بإكتمال القناة {channel_info['name']}\n"
                                    f"السبب: {str(e)}"
                                )
                            except:
                                pass

                    if channel_id in self.funded_channels:
                        self.funded_channels[channel_id]['status'] = 'مكتمل'
                        self.funded_channels[channel_id]['completion_date'] = str(datetime.now())
                        self.funded_channels[channel_id]['final_members_count'] = self.paid_channels[channel_id]['total_subscribers_count']

                        self.move_funding_to_completed(channel_id, "channel")

                    funding_record = self.get_funding_record_by_id(channel_id, "channel")
                    correct_funding_number = funding_record.get("funding_number", "غير متاح") if funding_record else "غير متاح"

                    await context.bot.send_message(
                        ADMIN_ID,
                        f"🎉 تم إكمال العدد المطلوب للقناة!\n\n"
                        f"📺 القناة: {channel_info['name']}\n"
                        f"👥 العدد المطلوب: {channel_info['members_required']}\n"
                        f"✅ العدد الحالي: {self.paid_channels[channel_id]['total_subscribers_count']}\n"
                        f"🔢 رقم التمويل: #{correct_funding_number}\n\n"
                        f"✅ تم حفظ التمويل في الأرشيف وإزالته من القائمة النشطة."
                    )

                    if channel_id in self.paid_channels:
                        del self.paid_channels[channel_id]
                        self.save_data_to_db('paid_channels', self.paid_channels)

                    if channel_id in self.monitored_channels:
                        del self.monitored_channels[channel_id]
                        self.save_json(MONITORED_CHANNELS_FILE, self.monitored_channels)

                    self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)


                await update.callback_query.edit_message_text(
                    f"🛎️•| تم الاشتراك بنجاح وحصلت على {self.format_points(channel_info['points'])} 🍪\n"
                    f"‼️•| اذا غادرت سيتم خصم الكوكيز منك"
                )
                await asyncio.sleep(1)  # تأخير بسيط

                next_channel_id, next_channel_info = await self.get_next_paid_channel(user_id, context)

                if next_channel_id:
                    keyboard = [
                        [
                            InlineKeyboardButton("📺 اشترك", url=next_channel_info['invite_link']),
                            InlineKeyboardButton("تحقق ✅", callback_data=f"check_paid_{next_channel_id}")
                        ],
                        [InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]
                    ]
                    await context.bot.send_message(
                        user_id,
                        f"🛎️|• اشترك في : {next_channel_info['name']}\n"
                        f"▫️|• وأَحصل على :  {self.format_points(next_channel_info['points'])} 🍪\n\n",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        disable_web_page_preview=True
                    )

                else:
                    await context.bot.send_message(
                        user_id,
                        "✅ لقد اشتركت في جميع القنوات المتاحة!\n\n"
                        "🔒 للحفاظ على رصيدك، يُرجى عدم مغادرة القنوات.",
                        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
                    )

            else:
                await update.callback_query.answer()
        else:
            await update.callback_query.answer()

    async def track_mandatory_subscription(self, user_id, channel_id, context=None):
        pass

    async def show_user_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        successful_invites = user.get("referrals_count", 0)

        funded_channels_count = len(user.get("funded_channels", []))

        used_cookies = 0
        if str(user_id) in self.user_channel_subscriptions:
            for sub_info in self.user_channel_subscriptions[str(user_id)].values():
                used_cookies += sub_info.get('points', 0)

        for channel_id in user.get("funded_channels", []):
            if channel_id in self.funded_channels:
                used_cookies += self.funded_channels[channel_id].get('cost_paid', 0)

        try:
            bot_username = (await context.bot.get_me()).username
            invite_link = f"https://t.me/{bot_username}?start={user['invite_link']}"
        except:
            invite_link = "غير متاح"

        text = f"ℹ️ معلوماتك الشخصية:\n\n" \
               f"🆔 الآيدي: `{user_id}`\n" \
               f"🍪 الكوكيز الحالية: {self.format_points(user['points'])}\n" \
               f"🍪 الكوكيز المستخدمة: {self.format_points(used_cookies)}\n" \
               f"💰 القنوات الممولة: {funded_channels_count}\n" \
               f"🔗 الدعوات: {successful_invites}\n" \
               f"📅 تاريخ الانضمام: {user['joined_date'][:10]}\n\n" \
               f"🔗 رابط الدعوة الخاص بك:\n`{invite_link}`"

        share_message = (
            f"@s1x2bot ⌁︙ أنضم الى بوت تيربو فولو  ↫⤈\n"
            f"⌁︙عندما تقوم بتفعيل البوت \n"
            f"⌁︙ سوف تحصل على ↫ 100 كوكيز\n"
            f"⌁︙رشق لايكات مسابقة اشتراك إجباري حسابات عربية\n"
            f"⌁︙يوفر تمويل القنوات والمجموعات والبوتات حقيقي 100%\n"
            f"⌁︙ يمكنك شراء نجوم تسليم تلقائي\n"
            f"⌁︙البوت يمتاز بسرعة تنفيذ الطلب ✓ .\n"
            f"⌁︙ رابط البوت ↫⤈\n"
            f"{invite_link}"
        )

        import urllib.parse
        encoded_message = urllib.parse.quote(share_message)
        share_url = f"https://t.me/share/url?url={encoded_message}"

        keyboard = [
            [InlineKeyboardButton("مشاركة رابط الدعوة 📤", url=share_url)],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_instructions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        text = """📌 تعليمات الاستخدام - يُرجى القراءة بعناية

في سعينا المستمر لتقديم أفضل تجربة ممكنة لجميع مستخدمينا، نؤكد على أهمية الالتزام بسياسات البوت وقواعد استخدامه، وذلك لضمان بيئة عادلة وآمنة للجميع.

🚫 يُمنع بشكل قاطع:

-دعوة أو استخدام حسابات وهمية لأي غرض كان.
-محاولة التحايل على نظام البوت أو إساءة استخدامه.
-مغادرة القنوات المرتبطة بالبوت بعد الاشتراك.

🗳️ ممنوع طلب اكثر من خدمة من خدمات الرشق لنفس الرابط بنفس الوقت 
- السبب :  من الممكن تحدث مشاكل ويتم سحب العدد المطلوب ولا يتم ارجاع رصيدك!
- أن تجاوز الحد الأقصى للرشق باي طريقة كانت سيؤدي هذا الفعل آلى خصم رصيدك بدون تنفيذ أي عملية 

⚠️ إن ارتكاب أي من هذه المخالفات يُعدّ خرقًا صريحًا لشروط الاستخدام، ويؤدي إلى الحظر الدائم من البوت دون سابق إنذار.

نحن نثق بكم ونعتمد على وعيكم في الالتزام، ونعمل باستمرار على تطوير النظام وتحسين جودة الخدمة. تعاونكم معنا هو الأساس الذي نبني عليه هذه المنظومة.

💡 في حال وجود أي استفسار أو شكوى، يمكنكم التواصل مع الإدارة. @cxxov

مع خالص التقدير والاحترام، فريق إدارة    بوت تيربو فولو 🍪"""

        keyboard = [
            [InlineKeyboardButton("تحديثات البوت 🛠", callback_data="bot_updates")],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_my_fundings(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        await self.delete_old_mandatory_message(context, user_id)

        user_fundings = self.get_user_fundings_from_permanent_record(user_id)

        if not user_fundings:
            await update.callback_query.edit_message_text(
                "💼 تمويلاتي\n\n"
                "❌ لم تقم بأي عمليات تمويل بعد\n\n"
                "💡 يمكنك بدء تمويل قناة أو بوت من القائمة الرئيسية",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]])
            )
            return

        keyboard = []
        text = f"💼 تمويلاتي ({len(user_fundings)} تمويل):\n\n"

        keyboard.append([
            InlineKeyboardButton("الحالة", callback_data="header_status"),
            InlineKeyboardButton("العدد", callback_data="header_count"), 
            InlineKeyboardButton("النوع", callback_data="header_type"),
            InlineKeyboardButton("رقم التمويل", callback_data="header_number")
        ])

        for funding in user_fundings:
            if funding['status'] == "مكتمل 🟢":
                status_icon = "🟢 مكتمل"
                status_text = "مكتمل"
            elif funding['status'] == "نشط 🟡":
                status_icon = "🟡 نشط" 
                status_text = "نشط"
            elif funding['status'] == "ملغي 🔴":
                status_icon = "🔴 ملغي"
                status_text = "ملغي"
            else:
                status_icon = "⚪"
                status_text = "غير معروف"

            progress = f"{funding['current_count']}/{funding['required_count']}"
            if funding['type'] == "قناة":
                type_callback = f"funding_channel_link_{funding['id']}"
            else: 
                type_callback = f"funding_bot_link_{funding['id']}"

            keyboard.append([
                InlineKeyboardButton(f"{status_icon}", callback_data=f"funding_status_info_{funding['id']}"),
                InlineKeyboardButton(progress, callback_data=f"funding_progress_{funding['id']}"),
                InlineKeyboardButton(funding['type'], callback_data=type_callback),
                InlineKeyboardButton(f"#{funding['funding_number']}", callback_data=f"funding_details_{funding['id']}_{funding['type']}")
            ])

        keyboard.append([InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")])

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_funding_details(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        parts = data.split("_")
        funding_id = parts[2]
        funding_type_param = parts[3] if len(parts) > 3 else "channel"

        user_id = update.effective_user.id
        user_fundings = self.get_user_fundings_from_permanent_record(user_id)

        selected_funding = None
        for funding in user_fundings:
            if funding['id'] == funding_id:
                selected_funding = funding
                break

        if not selected_funding:
            await update.callback_query.answer("❌ لم يتم العثور على التمويل!")
            return

        status_details = {
            "مكتمل 🟢": "تم إكمال العدد المطلوب بنجاح ✅",
            "نشط 🟡": "التمويل قيد التنفيذ والعمل جاري 🔄", 
            "ملغي 🔴": "تم إلغاء التمويل لأسباب فنية ❌"
        }

        status_detail = status_details.get(selected_funding['status'], "حالة غير معروفة")
        if selected_funding['required_count'] > 0:
            completion_percentage = (selected_funding['current_count'] / selected_funding['required_count']) * 100
        else:
            completion_percentage = 0
        try:
            funding_date = datetime.strptime(selected_funding['date'], '%Y-%m-%d %H:%M:%S.%f')
            formatted_date = funding_date.strftime('%Y-%m-%d %I:%M %p').replace('AM', 'ص').replace('PM', 'م')
        except:
            formatted_date = selected_funding['date'][:16] if selected_funding['date'] else 'غير متاح'

        details_text = f"💼 تفاصيل التمويل #{selected_funding['funding_number']}\n\n"
        details_text += f"📺 الاسم: {selected_funding['name']}\n"
        details_text += f"🏷️ النوع: {selected_funding['type']}\n"
        details_text += f"📊 الحالة: {selected_funding['status']}\n"
        details_text += f"💡 {status_detail}\n\n"
        details_text += f"👥 التقدم: {selected_funding['current_count']}/{selected_funding['required_count']}\n"
        details_text += f"📈 نسبة الإنجاز: {completion_percentage:.1f}%\n"
        details_text += f"💰 التكلفة المدفوعة: {self.format_points(selected_funding['cost'])} 🍪\n"
        details_text += f"📅 تاريخ التمويل: {formatted_date}\n\n"

        if selected_funding['status'] == "نشط 🟡":
            remaining = selected_funding['required_count'] - selected_funding['current_count']
            details_text += f"⏳ متبقي: {remaining} عضو\n"
            details_text += f"🎯 ستحصل على إشعار عند كل اشتراك جديد"
        elif selected_funding['status'] == "مكتمل 🟢":
            details_text += f"🎉 تم إكمال التمويل بنجاح!\n"
            details_text += f"✅ شكراً لك على استخدام خدمة التمويل"

        keyboard = [
            [InlineKeyboardButton("🔙 العودة للتمويلات", callback_data="my_fundings")],
            [InlineKeyboardButton("🏠 القائمة الرئيسية", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            details_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def handle_funding_channel_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        funding_id = data.split("_")[-1]
        user_id = update.effective_user.id
        user_fundings = self.get_user_fundings_from_permanent_record(user_id)
        selected_funding = None
        for funding in user_fundings:
            if funding['id'] == funding_id:
                selected_funding = funding
                break

        if not selected_funding:
            await update.callback_query.answer("❌ لم يتم العثور على التمويل!")
            return

        channel_link = None
        if funding_id in self.paid_channels:
            channel_link = self.paid_channels[funding_id].get('invite_link')
        elif funding_id in self.completed_fundings.get("channels", {}):
            channel_link = self.completed_fundings["channels"][funding_id].get('channel_invite_link')

        if channel_link:
            await update.callback_query.answer(url=channel_link)
        else:
            await update.callback_query.answer("❌ الرابط غير متاح حالياً", show_alert=True)

    async def handle_funding_bot_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        funding_id = data.split("_")[-1]
        user_id = update.effective_user.id
        user_fundings = self.get_user_fundings_from_permanent_record(user_id)
        selected_funding = None
        for funding in user_fundings:
            if funding['id'] == funding_id:
                selected_funding = funding
                break

        if not selected_funding:
            await update.callback_query.answer("❌ لم يتم العثور على التمويل!")
            return

        bot_username = None
        if funding_id in self.paid_bots:
            bot_username = self.paid_bots[funding_id].get('username')
        elif funding_id in self.completed_fundings.get("bots", {}):
            bot_username = self.completed_fundings["bots"][funding_id].get('bot_username')

        if bot_username:
            bot_link = f"https://t.me/{bot_username}"
            await update.callback_query.answer(url=bot_link)
        else:
            await update.callback_query.answer("❌ الرابط غير متاح حالياً", show_alert=True)

    async def show_bot_updates(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        keyboard = [
            [InlineKeyboardButton("القناة الأساسية 📢", url="https://t.me/TurboFollow2")],
            [InlineKeyboardButton("قناة التمويل 💰", url="https://t.me/TurboFollow4"),
            InlineKeyboardButton("قناة النجوم ⭐", url="https://t.me/TurboFollow3")],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]
        ]

        text = """📢 تحديثات البوت"""

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            disable_web_page_preview=True
        )
    async def show_transfer_cookies_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        await update.callback_query.edit_message_text(
            f"🔄 تحويل الكوكيز\n\n"
            f"💰 رصيدك الحالي: {self.format_points(user['points'])} 🍪\n"
            f"⚠️ أقل مبلغ للتحويل: 5000 كوكيز\n\n"
            f"📝 أرسل آيدي المستخدم الذي تريد التحويل إليه:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="back_to_main")]])
        )
        context.user_data['waiting_for'] = 'transfer_target_id'

    async def handle_transfer_target_id(self, update: Update, context: ContextTypes.DEFAULT_TYPE, target_id_text):
        try:
            target_id = int(target_id_text.strip())
            sender_id = update.effective_user.id

            if target_id == sender_id:
                await update.message.reply_text("❌ لا يمكنك تحويل الكوكيز لنفسك!")
                return
            if str(target_id) not in self.users:
                await update.message.reply_text("❌ المستخدم غير موجود في النظام!")
                return
            context.user_data['transfer_target_id'] = target_id
            context.user_data['waiting_for'] = 'transfer_amount'
            sender = self.get_user(sender_id)
            await update.message.reply_text(
                f"✅ تم تأكيد المستخدم المستهدف: {target_id}\n\n"
                f"💰 رصيدك الحالي: {self.format_points(sender['points'])} 🍪\n"
                f"⚠️ أقل مبلغ للتحويل: 5000 كوكيز\n\n"
                f"📝 أرسل عدد الكوكيز التي تريد تحويلها:"
            )
        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال آيدي صحيح (أرقام فقط)!")
    async def handle_transfer_amount(self, update: Update, context: ContextTypes.DEFAULT_TYPE, amount_text):
        try:
            amount = float(amount_text.strip())
            sender_id = update.effective_user.id
            target_id = context.user_data.get('transfer_target_id')

            if amount <= 0:
                await update.message.reply_text("❌ يجب أن يكون المبلغ أكبر من الصفر!")
                return
            if amount < 5000:
                await update.message.reply_text("❌ أقل مبلغ يمكن تحويله هو 5000 كوكيز!")
                return
            sender = self.get_user(sender_id)
            target = self.get_user(target_id)
            if sender['points'] < amount:
                await update.message.reply_text(
                    f"❌ رصيدك غير كافٍ!\n\n"
                    f"💰 رصيدك الحالي: {self.format_points(sender['points'])} 🍪\n"
                    f"📝 المبلغ المطلوب: {self.format_points(amount)} 🍪"
                )
                return
            sender['points'] -= amount
            target['points'] += amount

            context.user_data['waiting_for'] = None
            if 'transfer_target_id' in context.user_data:
                del context.user_data['transfer_target_id']
            await update.message.reply_text(
                f"✅ تم تحويل {self.format_points(amount)} 🍪 بنجاح!\n\n"
                f"👤 إلى المستخدم: {target_id}\n"
                f"💰 رصيدك الحالي: {self.format_points(sender['points'])} 🍪"
            )
            try:
                await context.bot.send_message(
                    target_id,
                    f"🎉 تم استلام تحويل!\n\n"
                    f"💰 المبلغ: {self.format_points(amount)} 🍪\n"
                    f"👤 من المستخدم: {sender_id}\n"
                    f"📊 رصيدك الحالي: {self.format_points(target['points'])} 🍪"
                )
            except:
                pass
            try:
                await context.bot.send_message(
                    ADMIN_ID,
                    f"🔄 عملية تحويل كوكيز\n\n"
                    f"👤 المرسل: {sender_id}\n"
                    f"👤 المستقبل: {target_id}\n"
                    f"💰 المبلغ: {self.format_points(amount)} 🍪\n"
                    f"📅 التاريخ: {self.format_time_12h(datetime.now())}"
                )
            except:
                pass
        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")
    async def show_admin_panel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [
                InlineKeyboardButton("📺 إدارة الإجباري", callback_data="manage_mandatory"),
                InlineKeyboardButton("💰 إدارة المدفوع", callback_data="manage_paid")
            ],
            [InlineKeyboardButton("📢 الإذاعة", callback_data="broadcast")],
            [
                InlineKeyboardButton("➕ إضافة نقاط", callback_data="add_points"),
                InlineKeyboardButton("➖ خصم نقاط", callback_data="remove_points")
            ],
            [
                InlineKeyboardButton("👥 إدارة المستخدمين", callback_data="manage_users"),
                InlineKeyboardButton("🎁 رابط الهدية", callback_data="gift_link")
            ],
            [InlineKeyboardButton("🎫 إنشاء كود هدية", callback_data="create_gift_code")],
            [
                InlineKeyboardButton("🔢 نقاط الدخول", callback_data="entry_points"),
                InlineKeyboardButton("📊 الإحصائيات", callback_data="statistics")
            ],
            [
                InlineKeyboardButton("💰 سعر العضو", callback_data="member_price"),
                InlineKeyboardButton("⚙️ الإعدادات", callback_data="admin_settings")
            ],
            [
                InlineKeyboardButton("🔧 الصيانة", callback_data="maintenance"),
                InlineKeyboardButton("🧬 معلومات", callback_data="user_info_admin")
            ],
            [
                InlineKeyboardButton("💰 سعر اشتراك القنوات", callback_data="subscription_price")
            ],
            [
                InlineKeyboardButton("🔢 أقل عدد يمكن تمويله", callback_data="min_funding_members")
            ],
            [
                InlineKeyboardButton("🎁 عدد الهدية", callback_data="daily_gift_amount"),
                InlineKeyboardButton("👥 معلومات الحسابات", callback_data="accounts_info")
            ],
            [
                InlineKeyboardButton("🤖 إدارة البوتات المدفوعة", callback_data="manage_paid_bots"),
                InlineKeyboardButton("شفاف", callback_data="transparent")
            ],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="back_to_main")]
        ]

        await update.callback_query.edit_message_text(
            "👨‍💼 لوحة الإدارة:\n\n"
            "اختر الإجراء المطلوب:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def user_info_admin_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'user_info_admin_id'
        await update.callback_query.edit_message_text(
            "🧬 معلومات المستخدم:\n\n"
            "أرسل آيدي المستخدم للحصول على معلوماته الكاملة:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )
    async def delivery_username_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'delivery_username_value'
        await update.callback_query.edit_message_text(
            f"👤 اسم مستخدم المرسل:\n\n"
            f"أرسل اسم المستخدم الجديد للمرسل (مثال: @username):",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )
    async def manage_mandatory_channels(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        status_icon = "🟢" if self.mandatory_enabled else "🔴"
        status_text = "مفعل" if self.mandatory_enabled else "معطل"
        toggle_text = "🔴 إيقاف" if self.mandatory_enabled else "🟢 تشغيل"

        keyboard = [
            [InlineKeyboardButton(toggle_text, callback_data="toggle_mandatory")],
            [
                InlineKeyboardButton("➕ أضافة قناة إجبارية", callback_data="add_mandatory_channel"),
                InlineKeyboardButton("🗑️ حذف قناة إجبارية", callback_data="delete_mandatory_channel")
            ],
            [InlineKeyboardButton("🔄 تحديث الإحصائيات", callback_data="update_mandatory_stats")],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")]
        ]
        text = "📺 إدارة القنوات الإجبارية:\n\n"
        text += f"📊 حالة الاشتراك الإجباري: {status_icon} {status_text}\n\n"
        if self.mandatory_channels:
            text += "📋 القنوات الإجبارية الحالية:\n\n"
            for i, (channel_id, info) in enumerate(self.mandatory_channels.items(), 1):
                current_count = info.get('total_subscribers_count', 0)
                required_count = info.get('members_required', 'غير محدد')
                progress_percentage = f"({int((current_count/required_count)*100)}%)" if isinstance(required_count, int) and required_count > 0 else ""
                text += f"🔸 القناة {i}:\n"
                text += f"   📺 الاسم: {info['name']}\n"
                text += f"   👥 العدد: {current_count}/{required_count} {progress_percentage}\n"
                text += f"   🆔 المعرف: {channel_id}\n\n"
        else:
            text += "❌ لا توجد قنوات إجبارية حالياً.\n\n"
            text += "💡 يمكنك إضافة قناة إجبارية باستخدام الزر أدناه."
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def delete_mandatory_channel_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.mandatory_channels:
            await update.callback_query.edit_message_text(
                "❌ لا توجد قنوات إجبارية للحذف!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="manage_mandatory")]])
            )
            return
        keyboard = []
        for channel_id, info in self.mandatory_channels.items():
            keyboard.append([InlineKeyboardButton(f"🗑️ {info['name']}", callback_data=f"del_mandatory_{channel_id}")])
        keyboard.append([InlineKeyboardButton("رجوع (🔙)", callback_data="manage_mandatory")])

        await update.callback_query.edit_message_text(
            "🗑️ اختر القناة الإجبارية المراد حذفها:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def confirm_delete_mandatory_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        channel_id = data.split("_")[2]
        if channel_id in self.mandatory_channels:
            channel_name = self.mandatory_channels[channel_id]['name']
            del self.mandatory_channels[channel_id]
            self.save_data_to_db('mandatory_channels', self.mandatory_channels)
            await update.callback_query.edit_message_text(
                f"✅ تم حذف القناة الإجبارية '{channel_name}' بنجاح!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="manage_mandatory")]])
            )
        else:
            await update.callback_query.edit_message_text(
                "❌ لم يتم العثور على القناة!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="manage_mandatory")]])
            )
    async def manage_paid_channels(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [
                InlineKeyboardButton("➕ إضافة قناة مدفوعة", callback_data="add_paid_channel"),
                InlineKeyboardButton("🗑️ حذف قناة مدفوعة", callback_data="delete_paid_channel")
            ],
            [InlineKeyboardButton("📊 إدارة عدد المدفوع", callback_data="manage_paid_count")],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")]
        ]
        text = "💰 إدارة القنوات المدفوعة:\n\n"
        if self.paid_channels:
            text += "القنوات الحالية:\n"
            for channel_id, info in self.paid_channels.items():
                text += f"• {info['name']} - {self.format_points(info['points'])} 🍪 ({channel_id})\n"
        else:
            text += "لا توجد قنوات مدفوعة حالياً."
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def delete_paid_channel_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.paid_channels:
            await update.callback_query.edit_message_text(
                "❌ لا توجد قنوات مدفوعة للحذف!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="manage_paid")]])
            )
            return

        keyboard = []
        for channel_id, info in self.paid_channels.items():
            keyboard.append([InlineKeyboardButton(f"🗑️ {info['name']}", callback_data=f"del_paid_{channel_id}")])

        keyboard.append([InlineKeyboardButton("رجوع (🔙)", callback_data="manage_paid")])

        await update.callback_query.edit_message_text(
            "🗑️ اختر القناة المدفوعة المراد حذفها:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def confirm_delete_paid_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        channel_id = data.split("_")[2]

        if channel_id in self.paid_channels:
            channel_name = self.paid_channels[channel_id]['name']

            del self.paid_channels[channel_id]
            self.save_data_to_db('paid_channels', self.paid_channels)

            if channel_id in self.monitored_channels:
                del self.monitored_channels[channel_id]
                self.save_json(MONITORED_CHANNELS_FILE, self.monitored_channels)

            if channel_id in self.funded_channels:
                del self.funded_channels[channel_id]
                self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)

            await update.callback_query.edit_message_text(
                f"✅ تم حذف القناة '{channel_name}' بنجاح من جميع الأقسام!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="manage_paid")]])
            )
        else:
            await update.callback_query.edit_message_text(
                "❌ لم يتم العثور على القناة!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="manage_paid")]])
            )
    async def manage_paid_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.paid_channels:
            await update.callback_query.edit_message_text(
                "❌ لا توجد قنوات مدفوعة!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")]])
            )
            return
        keyboard = []
        text = "📊 إدارة عدد المدفوع:\n\n"
        for channel_id, info in self.paid_channels.items():
            total_subscribers = info.get('total_subscribers_count', 0)
            required = info['members_required']
            keyboard.append([
                InlineKeyboardButton(f"📺 {info['name']}", callback_data=f"channel_info_{channel_id}"),       InlineKeyboardButton(f"{total_subscribers}/{required}", callback_data=f"count_info_{channel_id}")
            ])
            text += f"📺 {info['name']}\n"
            text += f"👥 العدد: {total_subscribers}/{required}\n\n"
        keyboard.append([InlineKeyboardButton("🔄 تحديث الحالة", callback_data="update_paid_status")])
        keyboard.append([InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")])
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def update_paid_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.callback_query.edit_message_text("🔄 جاري تحديث الحالة...")
        await asyncio.sleep(1)
        await self.manage_paid_count(update, context)
    async def update_mandatory_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.callback_query.edit_message_text("🔄 جاري تحديث إحصائيات القنوات الإجبارية...")
        total_updated = 0
        for channel_id, channel_info in self.mandatory_channels.items():
            try:
                chat = await context.bot.get_chat(channel_id)
                real_member_count = getattr(chat, 'member_count', None)
                if real_member_count:                channel_info['real_member_count'] = real_member_count
                total_updated += 1
            except Exception as e:
                logger.error(f"فشل في تحديث إحصائيات القناة {channel_id}: {e}")
        self.save_data_to_db('mandatory_channels', self.mandatory_channels)
        await asyncio.sleep(1)
        await self.manage_mandatory_channels(update, context)
    async def add_mandatory_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'mandatory_channel_username'
        await update.callback_query.edit_message_text(
            "📺 إضافة قناة إجبارية:\n\n"
            "أرسل يوزرنيم القناة (يجب أن يبدأ بـ @):\n"
            "مثال: @mychannel",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="manage_mandatory")]])
        )
    async def add_paid_channel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'paid_channel_id'
        await update.callback_query.edit_message_text(
            "💰 إضافة قناة مدفوعة:\n\n"
            "أرسل معرف القناة (يجب أن يبدأ بـ -):\n"
            "مثال: -1001234567890",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="manage_paid")]])
        )
    async def toggle_mandatory_subscription(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        self.mandatory_enabled = not self.mandatory_enabled
        self.db.set_setting('mandatory_enabled', self.mandatory_enabled)

        status = "مفعل" if self.mandatory_enabled else "معطل"
        await update.callback_query.edit_message_text(
            f"✅ تم تغيير حالة الاشتراك الإجباري إلى: {status}",
          reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع", callback_data="manage_mandatory")]])
        )
    async def broadcast_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'broadcast_message'
        await update.callback_query.edit_message_text(
            "📢 الإذاعة:\n\n"
            "أرسل النص الذي تريد إذاعته لجميع المستخدمين:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )
    async def add_points_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'add_points_user_id'
        await update.callback_query.edit_message_text(
            "➕ إضافة نقاط:\n\n"
            "أرسل آيدي المستخدم:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )
    async def remove_points_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'remove_points_user_id'
        await update.callback_query.edit_message_text(
            "➖ خصم نقاط:\n\n"
            "أرسل آيدي المستخدم:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )
    async def manage_users_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        banned_text = "👥 إدارة المستخدمين:\n\n"
        if self.banned_users:
            banned_text += "🚫 المستخدمون المحظورون:\n"
            for user_id in self.banned_users.keys():
                banned_text += f"• {user_id}\n"
        else:
            banned_text += "لا يوجد مستخدمون محظورون حالياً.\n"
        keyboard = [
            [
                InlineKeyboardButton("🚫 حظر", callback_data="ban_user"),
                InlineKeyboardButton("✅ فك", callback_data="unban_user")
            ],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="manage_users")]
        ]
        await update.callback_query.edit_message_text(
            banned_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def ban_user_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'ban_user_id'
        await update.callback_query.edit_message_text(
            "🚫 حظر مستخدم:\n\n"
            "أرسل آيدي المستخدم المراد حظره:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="manage_users")]])
        )
    async def unban_user_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'unban_user_id'
        await update.callback_query.edit_message_text(
            "✅ فك حظر مستخدم:\n\n"
            "أرسل آيدي المستخدم المراد فك حظره:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="manage_users")]])
        )
    async def gift_link_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [InlineKeyboardButton("🎁 إنشاء رابط هدية", callback_data="create_gift_link")],
            [InlineKeyboardButton("📋 إدارة الروابط", callback_data="manage_gift_links")],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")]
        ]
        await update.callback_query.edit_message_text(
            "🎁 إدارة روابط الهدايا:\n\n"
            "اختر الإجراء المطلوب:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def member_price_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'member_price_value'
        await update.callback_query.edit_message_text(
            f"💰 سعر العضو الواحد:\n\n"
            f"🍪 السعر الحالي: {self.member_price} كوكيز\n\n"
            f"أرسل السعر الجديد للعضو الواحد:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )
    async def entry_points_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'entry_points_value'
        await update.callback_query.edit_message_text(
            f"🔢 نقاط الدخول:\n\n"
            f"💰 الكوكيز الحالية للدعوة: {self.format_points(self.invite_points)}\n\n"
            f"أرسل عدد الكوكيز الجديد التي سيحصل عليها الداعي عند دعوة مستخدمين:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )
    async def show_statistics(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        total_users = len(self.users)
        total_invites = sum(user.get("referrals_count", 0) for user in self.users.values())
        now = datetime.now()
        yesterday = now - timedelta(hours=24)
        daily_users = 0
        daily_invites = 0
        for user_id, user_data in self.users.items():
            if user_data.get("joined_date"):
                try:
                    join_date = datetime.strptime(user_data["joined_date"], '%Y-%m-%d %H:%M:%S.%f')
                    if join_date >= yesterday:
                        daily_users += 1
                except:
                    pass
        total_collected_points = 0
        daily_collected_points = 0
        for user_subs in self.user_channel_subscriptions.values():
            for sub_info in user_subs.values():
                points = sub_info.get("points", 0)
                total_collected_points += points
                if sub_info.get("date"):
                    try:
                        sub_date = datetime.strptime(sub_info["date"], '%Y-%m-%d %H:%M:%S.%f')
                        if sub_date >= yesterday:
                            daily_collected_points += points
                    except:
                        pass
        for invite_list in self.invites.values():
            for invite_data in invite_list:
                if invite_data.get("date"):
                    try:
                        invite_date = datetime.strptime(invite_data["date"], '%Y-%m-%d %H:%M:%S.%f')
                        if invite_date >= yesterday:
                            daily_invites += 1
                    except:
                        pass
        total_current_points = sum(user.get("points", 0) for user in self.users.values())
        total_funded_channels = len(self.funded_channels)
        text = f"📊 إحصائيات البوت:\n\n" \
               f"👥 إجمالي المستخدمين: {total_users}\n" \
               f"👤 مستخدمين جدد اليوم: {daily_users}\n\n" \
               f"🔗 إجمالي الدعوات: {total_invites}\n" \
               f"📲 دعوات اليوم: {daily_invites}\n\n" \
               f"💎 الكوكيز المجمعة (إجمالي): {self.format_points(total_collected_points)}\n" \
               f"💰 الكوكيز المجمعة اليوم: {self.format_points(daily_collected_points)}\n" \
               f"🍪 الكوكيز الحالية للمستخدمين: {self.format_points(total_current_points)}\n\n" \
               f"📺 القنوات الإجبارية: {len(self.mandatory_channels)}\n" \
               f"💰 القنوات المدفوعة: {len(self.paid_channels)}\n" \
               f"🏦 القنوات الممولة: {total_funded_channels}\n" \
               f"🚫 المستخدمين المحظورين: {len(self.banned_users)}\n\n" \
               f"📅 آخر تحديث: {self.format_time_12h(datetime.now())}"

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")]])
        )
    async def handle_fund_channel_members_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, members_text):
        try:
            members = int(members_text)
            if members <= 0:
                await update.message.reply_text("❌ يجب أن يكون عدد الأعضاء أكبر من الصفر!")
                return

            if members < self.min_funding_members:
                await update.message.reply_text(f"❌ أقل عدد يمكن تمويله هو {self.min_funding_members} عضو!")
                return

            user_id = update.effective_user.id
            user = self.get_user(user_id)

            total_cost = float(members * self.member_price)

            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"❌ رصيدك غير كافٍ!\n\n"
                    f"💰 تحتاج: {self.format_points(total_cost)} 🍪\n"
                    f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪"
                )
                context.user_data['waiting_for'] = None
                return

            context.user_data['temp_fund_members'] = members
            context.user_data['temp_fund_cost'] = total_cost
            context.user_data['waiting_for'] = 'fund_channel_username'

            bot_info = await update.get_bot().get_me()
            bot_username = f"@{bot_info.username}" if bot_info.username else "البوت"

            await update.message.reply_text(
                f"✅] عدد الأعضاء: {members}\n"
                f"💎| التكلفة الإجمالية: {self.format_points(total_cost)} 🍪\n"
                f"⚠️] ارفع البوت {bot_username} أدمن في قناتك أو مجموعتك\n"
                f"👤]• ثم أرسل يوزر القناة مع @"
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def handle_fund_channel_username_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, username_text):
        try:
            username = username_text.strip()

            if not username.startswith('@'):
                await update.message.reply_text("❌ يجب أن يبدأ يوزر القناة بـ @")
                return

            user_id = update.effective_user.id
            user = self.get_user(user_id)

            members = context.user_data.get('temp_fund_members')
            cost = context.user_data.get('temp_fund_cost')

            if not members or not cost:
                await update.message.reply_text("❌ خطأ في البيانات، يرجى المحاولة مرة أخرى")
                context.user_data['waiting_for'] = None
                return

            try:
                chat = await context.bot.get_chat(username)
                channel_id = str(chat.id)
                channel_name = chat.title or username

                bot_member = await context.bot.get_chat_member(channel_id, context.bot.id)
                if bot_member.status not in ['administrator', 'creator']:
                    await update.message.reply_text(
                        f"❌ البوت ليس مشرفاً في القناة!\n\n"
                        f"⚠️ يرجى رفع البوت مشرفاً في {username} ثم المحاولة مرة أخرى"
                    )
                    return

                user['points'] -= cost
                funding_type = "جديد"
                total_members = members
                is_cumulative = False
                existing_funding = self.funded_channels.get(channel_id)
                is_active_funding = existing_funding and existing_funding.get('status') != 'مكتمل'
                if channel_id in self.paid_channels and is_active_funding:
                    old_members_required = self.paid_channels[channel_id]["members_required"]
                    new_members_required = old_members_required + members
                    self.paid_channels[channel_id]["members_required"] = new_members_required
                    if channel_id in self.funded_channels:
                        self.funded_channels[channel_id]["members_funded"] += members
                        self.funded_channels[channel_id]["cost_paid"] += cost
                        self.funded_channels[channel_id]["last_funding_date"] = str(datetime.now())
                        self.funded_channels[channel_id]["status"] = "نشط"

                    funding_type = "تراكمي"
                    total_members = new_members_required
                    is_cumulative = True
                else:
                    funding_type = "جديد"
                    self.paid_channels[channel_id] = {
                        "name": channel_name,
                        "invite_link": f"https://t.me/{username[1:]}",
                        "members_required": members,
                        "points": 12,
                        "funded_by": user_id,
                        "funded_date": str(datetime.now()),
                        "total_subscribers_count": 0
                    }
                    self.funded_channels[channel_id] = {
                        "owner_id": user_id,
                        "members_funded": members,
                        "cost_paid": cost,
                        "date": str(datetime.now()),
                        "channel_name": channel_name,
                        "status": "نشط"
                    }
                    total_members = members
                    is_cumulative = False
                funding_number = self.generate_funding_number("channel", channel_id, None, is_cumulative)
                if "funded_channels" not in user:
                    user["funded_channels"] = []
                if channel_id not in user["funded_channels"]:
                    user["funded_channels"].append(channel_id)

                self.save_data_to_db('paid_channels', self.paid_channels)
                self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)
                context.user_data['waiting_for'] = None
                if 'temp_fund_members' in context.user_data:
                    del context.user_data['temp_fund_members']
                if 'temp_fund_cost' in context.user_data:
                    del context.user_data['temp_fund_cost']

                await update.message.reply_text(
                    f"✅] تم خصم {self.format_points(cost)} وبدء تمويل قناتك بـ{members} عضو بنجاح!\n"
                    f"📣] القناة : {channel_name}\n"
                    f"🆔] رقم التمويل: #{funding_number}\n"
                    f"🎯| يمكنك مراقبة حالة التمويل عبر زر 'تمويلاتي'"
                )
                try:
                    user_link = f"[{user_id}](tg://user?id={user_id})"
                    funding_status = "💰 عملية تمويل جديدة" if funding_type == "جديد" else "🔄 عملية تمويل تراكمي"
                    funding_icon = "🆕" if funding_type == "جديد" else "🔄"
                    message_text = f"{funding_status} {funding_icon}:\n\n"
                    message_text += f"👤 المستخدم: {user_link}\n"
                    message_text += f"📺 القناة: [{channel_name}](https://t.me/{username[1:]})\n"
                    message_text += f"🔄 نوع التمويل: {funding_type}\n"
                    message_text += f"➕ الأعضاء المضافة: {members}\n"
                    message_text += f"👥 إجمالي الأعضاء المطلوب: {total_members}\n"
                    message_text += f"💰 التكلفة هذه المرة: {self.format_points(cost)} 🍪\n"
                    if funding_type == "تراكمي":
                        total_cost_paid = self.funded_channels[channel_id]["cost_paid"]
                        message_text += f"💎 إجمالي التكلفة المدفوعة: {self.format_points(total_cost_paid)} 🍪\n"
                    message_text += f"📅 التاريخ: {self.format_time_12h(datetime.now())}"
                    await context.bot.send_message(
                        ADMIN_ID,
                        message_text,
                        parse_mode='Markdown'
                    )
                except Exception as e:
                    logger.error(f"فشل في إرسال إشعار التمويل للأدمن: {e}")
            except Exception as e:
                await update.message.reply_text(f"❌ خطأ في التحقق من القناة: {str(e)}")
                context.user_data['waiting_for'] = None
        except Exception as e:
            await update.message.reply_text(f"❌ حدث خطأ: {str(e)}")
            context.user_data['waiting_for'] = None

    async def handle_broadcast_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message_text):
        context.user_data['waiting_for'] = None

        total_users = len(self.users)
        successful = 0
        failed = 0

        progress_msg = await update.message.reply_text(
            f"📡 بدء الإذاعة لـ {total_users} مستخدم...\n"
            f"📊 التقدم: 0/{total_users}"
        )

        for i, user_id in enumerate(self.users.keys()):
            try:
                await context.bot.send_message(
                    int(user_id),
                    f"📢 إذاعة من إدارة البوت:\n\n{message_text}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━\n"
                    f"👨‍💼 إدارة بوت تيربو فولو"
                )
                successful += 1
            except Exception as e:
                failed += 1
                logger.error(f"فشل في إرسال الإذاعة للمستخدم {user_id}: {e}")

            if (i + 1) % 10 == 0 or (i + 1) == total_users:
                try:
                    await progress_msg.edit_text(
                        f"📡 جاري الإذاعة لـ {total_users} مستخدم...\n"
                        f"📊 التقدم: {i + 1}/{total_users}\n"
                        f"✅ نجح: {successful}\n"
                        f"❌ فشل: {failed}"
                    )
                except:
                    pass

            await asyncio.sleep(0.1)

        final_message = (
            f"✅ تم الانتهاء من الإذاعة!\n\n"
            f"📊 النتائج:\n"
            f"👥 إجمالي المستخدمين: {total_users}\n"
            f"✅ تم الإرسال بنجاح: {successful}\n"
            f"❌ فشل في الإرسال: {failed}\n"
            f"📅 وقت الانتهاء: {self.format_time_12h(datetime.now())}"
        )

        await progress_msg.edit_text(final_message)

        await self.handle_unban_user(update, context, text)

        # If no specific handler found, show main menu
        await self.show_main_menu(update, context)

    async def handle_gift_code_usage(self, update: Update, context: ContextTypes.DEFAULT_TYPE, gift_code):
        user_id = update.effective_user.id
        result = self.use_gift_link(gift_code, user_id)

        if result["success"]:
            user_link = f"[{update.effective_user.first_name}](tg://user?id={user_id})"
            await update.message.reply_text(
                f"🎉 تهانينا {user_link}! تم استلام الهدية {self.format_points(result['points'])} كوكيز!\n"
                f"📊 رصيدك الحالي: {self.format_points(self.get_user(user_id)['points'])} 🍪\n\n"
                f"☺️ نشكركم على ثقتكم الكبيرة، ونسعى دوماً لتقديم الأفضل لكم.",
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(f"❌ {result['message']}")

        context.user_data['waiting_for'] = None
        await self.show_main_menu(update, context)

    async def show_use_gift_code_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.callback_query.edit_message_text(
            "🎁 استخدام كود الهدية:\n\n"
            "أرسل كود الهدية الذي تريد استخدامه:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="back_to_main")]])
        )
        context.user_data['waiting_for'] = 'use_gift_code'

    async def handle_ban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            ban_user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(ban_user_id) in self.banned_users:
                await update.message.reply_text("❌ المستخدم محظور بالفعل!")
                return

            self.banned_users[str(ban_user_id)] = {
                "banned_date": str(datetime.now()),
                "banned_by": update.effective_user.id
            }
            self.save_data_to_db('banned_users', self.banned_users)

            await update.message.reply_text(f"✅ تم حظر المستخدم {ban_user_id} بنجاح!")

            try:
                await context.bot.send_message(
                    ban_user_id,
                    "🚫 تم حظرك من استخدام البوت من قبل الإدارة\n"
                    "إذا كنت تعتقد أن هذا الحظر حدث عن طريق الخطأ، تواصل مع الإدارة: @cxxov"
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال آيدي صحيح!")

    async def handle_unban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            unban_user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(unban_user_id) not in self.banned_users:
                await update.message.reply_text("❌ المستخدم غير محظور!")
                return

            del self.banned_users[str(unban_user_id)]
            self.save_data_to_db('banned_users', self.banned_users)

            await update.message.reply_text(f"✅ تم فك حظر المستخدم {unban_user_id} بنجاح!")

            try:
                await context.bot.send_message(
                    unban_user_id,
                    "✅ تم فك حظرك من البوت!\n"
                    "يمكنك الآن استخدام البوت بشكل طبيعي."
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال آيدي صحيح!")

    async def handle_user_info_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(user_id) not in self.users:
                await update.message.reply_text("❌ المستخدم غير موجود في النظام!")
                return

            user = self.get_user(user_id)

            funded_channels_count = len(user.get("funded_channels", []))
            successful_invites = user.get("referrals_count", 0)

            used_cookies = 0
            if str(user_id) in self.user_channel_subscriptions:
                for sub_info in self.user_channel_subscriptions[str(user_id)].values():
                    used_cookies += sub_info.get('points', 0)

            for channel_id in user.get("funded_channels", []):
                if channel_id in self.funded_channels:
                    used_cookies += self.funded_channels[channel_id].get('cost_paid', 0)

            try:
                user_chat = await context.bot.get_chat(user_id)
                user_name = user_chat.first_name or "غير متاح"
                user_username = f"@{user_chat.username}" if user_chat.username else "لا يوجد"
                user_is_bot = "نعم" if user_chat.type == 'bot' else "لا"
            except:
                user_name = "غير متاح"
                user_username = "لا يوجد"
                user_is_bot = "غير معروف"

            ban_status = "محظور ❌" if str(user_id) in self.banned_users else "غير محظور ✅"

            info_text = (
                f"👤 معلومات المستخدم الكاملة:\n\n"
                f"🆔 الآيدي: {user_id}\n"
                f"📝 الاسم: {user_name}\n"
                f"📱 اليوزرنيم: {user_username}\n"
                f"🤖 بوت: {user_is_bot}\n"
                f"🚫 حالة الحظر: {ban_status}\n\n"
                f"💰 الكوكيز الحالية: {self.format_points(user['points'])} 🍪\n"
                f"🔥 الكوكيز المستخدمة: {self.format_points(used_cookies)} 🍪\n"
                f"💎 إجمالي النقاط المكتسبة: {self.format_points(user['points'] + used_cookies)} 🍪\n\n"
                f"📊 إحصائيات النشاط:\n"
                f"🔗 الدعوات الناجحة: {successful_invites}\n"
                f"💰 القنوات الممولة: {funded_channels_count}\n\n"
                f"📅 تاريخ الانضمام: {user['joined_date'][:16] if user.get('joined_date') else 'غير متاح'}\n"
                f"⏰ آخر نشاط: {user.get('last_activity', 'غير متاح')[:16] if user.get('last_activity') else 'غير متاح'}\n"
                f"🎯 استخدم دعوة: {'نعم' if user.get('used_invite') else 'لا'}\n"
                f"✅ أكمل الإجباري: {'نعم' if user.get('completed_mandatory') else 'لا'}"
            )

            await update.message.reply_text(info_text)

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال آيدي صحيح (أرقام فقط)!")
        except Exception as e:
            await update.message.reply_text(f"❌ حدث خطأ: {str(e)}")

    async def handle_ban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(user_id) in self.banned_users:
                await update.message.reply_text("❌ المستخدم محظور مسبقاً!")
                return

            self.banned_users[str(user_id)] = {
                "banned_date": str(datetime.now()),
                "banned_by": update.effective_user.id
            }
            self.save_json(BANNED_USERS_FILE, self.banned_users)

            try:
                user_chat = await context.bot.get_chat(user_id)
                user_name = user_chat.first_name or "مستخدم"
            except:
                user_name = "مستخدم"

            await update.message.reply_text(
                f"✅ تم حظر المستخدم بنجاح!\n\n"
                f"👤 المستخدم: {user_name}\n"
                f"🆔 الآيدي: {user_id}\n"
                f"📅 وقت الحظر: {self.format_time_12h(datetime.now())}"
            )

            try:
                await context.bot.send_message(
                    user_id,
                    "🚫 تم حظرك من استخدام البوت من قبل الإدارة\n"
                    "إذا كنت تعتقد أن هذا الحظر حدث عن طريق الخطأ، لا تقلق، بإمكانك التواصل مع الإدارة لمراجعة الأمر : [@cxxov]\n"
                    "نحن هنا لدعمك ونسعى لتقديم أفضل تجربة ممكنة."
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال آيدي صحيح (أرقام فقط)!")

    async def handle_unban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())
            context.user_data['waiting_for'] = None

            if str(user_id) not in self.banned_users:
                await update.message.reply_text("❌ المستخدم غير محظور!")
                return

            del self.banned_users[str(user_id)]
            self.save_json(BANNED_USERS_FILE, self.banned_users)

            try:
                user_chat = await context.bot.get_chat(user_id)
                user_name = user_chat.first_name or "مستخدم"
            except:
                user_name = "مستخدم"

            await update.message.reply_text(
                f"✅ تم فك حظر المستخدم بنجاح!\n\n"
                f"👤 المستخدم: {user_name}\n"
                f"🆔 الآيدي: {user_id}\n"
                f"📅 وقت فك الحظر: {self.format_time_12h(datetime.now())}"
            )

            try:
                await context.bot.send_message(
                    user_id,
                    "✅ تم فك حظرك من البوت!\n\n"
                    "🎉 يمكنك الآن استخدام جميع ميزات البوت بحرية\n"
                    "نتمنى لك تجربة ممتعة! 🙏"
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال آيدي صحيح (أرقام فقط)!")
    async def transparent_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'transparent_button_text'
        await update.callback_query.edit_message_text(
            "✨ إدارة الزر الشفاف:\n\n"
            "أرسل الرسالة (سيتم إرسالها للأدمن مع الزر الشفاف):",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )

    async def handle_transparent_button_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message_text):
        context.user_data['temp_transparent_text'] = message_text

        if update.message.photo:
            photo = update.message.photo[-1]
            context.user_data['temp_transparent_photo'] = photo.file_id
        else:
            context.user_data['temp_transparent_photo'] = None

        context.user_data['waiting_for'] = 'transparent_button_name'

        await update.message.reply_text(
            "✅ تم حفظ المحتوى!\n\n"
            "🏷️ الآن أرسل اسم الزر الشفاف:"
        )

    async def handle_transparent_button_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE, button_name):
        context.user_data['temp_transparent_button_name'] = button_name
        context.user_data['waiting_for'] = 'transparent_button_url'

        await update.message.reply_text(
            f"✅ اسم الزر: {button_name}\n\n"
            f"🔗 الآن أرسل الرابط الذي سيفتح عند الضغط على الزر\n"
            f"أو أرسل كلمة 'بدون' إذا كنت تريد الزر بدون رابط:"
        )

    async def handle_transparent_button_url(self, update: Update, context: ContextTypes.DEFAULT_TYPE, url_text):
        try:
            text = context.user_data['temp_transparent_text']
            photo_id = context.user_data.get('temp_transparent_photo')
            button_name = context.user_data['temp_transparent_button_name']

            keyboard = []
            if url_text.lower() != "بدون":
                keyboard.append([InlineKeyboardButton(button_name, url=url_text)])
            else:
                keyboard.append([InlineKeyboardButton(button_name, callback_data="transparent_click")])

            reply_markup = InlineKeyboardMarkup(keyboard)

            if photo_id:
                await context.bot.send_photo(
                    ADMIN_ID,
                    photo=photo_id,
                    caption=text,
                    reply_markup=reply_markup
                )
            else:
                await context.bot.send_message(
                    ADMIN_ID,
                    text=text,
                    reply_markup=reply_markup
                )

            context.user_data['waiting_for'] = None
            del context.user_data['temp_transparent_text']
            del context.user_data['temp_transparent_button_name']
            if 'temp_transparent_photo' in context.user_data:
                del context.user_data['temp_transparent_photo']

            await update.message.reply_text(
                "✅ تم إرسال الزر الشفاف بنجاح!\n\n"
                f"🏷️ اسم الزر: {button_name}\n"
                f"🔗 الرابط: {url_text if url_text.lower() != 'بدون' else 'بدون رابط'}\n"
                f"📸 صورة: {'نعم' if photo_id else 'لا'}"
            )

        except Exception as e:
            await update.message.reply_text(f"❌ حدث خطأ: {str(e)}")
            context.user_data['waiting_for'] = None

    async def min_funding_members_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'min_funding_members_value'
        await update.callback_query.edit_message_text(
            f"🔢 أقل عدد يمكن تمويله:\n\n"
            f"📊 العدد الحالي: {self.min_funding_members} عضو\n\n"
            f"أر �ل العدد الجديد لأقل عدد يمكن تمويله:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )





    async def handle_filter_days_threshold(self, update: Update, context: ContextTypes.DEFAULT_TYPE, days_text):
        await update.message.reply_text("❌ نظام التصفية التلقائية معطل في هذا البوت.")

    async def handle_min_funding_members_value(self, update: Update, context: ContextTypes.DEFAULT_TYPE, members_text):
        try:
            members = int(members_text)
            if members < 1:
                await update.message.reply_text("❌ يجب أن يكون العدد أكبر من 0!")
                return

            old_members = self.min_funding_members
            self.min_funding_members = members
            context.user_data['waiting_for'] = None

            await update.message.reply_text(
                f"✅ تم تحديث أقل عدد يمكن تمويله بنجاح!\n\n"
                f"📊 العدد السابق: {old_members} عضو\n"
                f"🔢 العدد الجديد: {members} عضو\n\n"
                f"⚠️ سيتم تطبيق هذا التغيير على عمليات التمويل الجديدة فقط"
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def handle_add_points_user_id(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())

            if str(user_id) not in self.users:
                await update.message.reply_text("❌ المستخدم غير موجود في النظام!")
                return

            context.user_data['add_points_user_id'] = user_id
            context.user_data['waiting_for'] = 'add_points_amount'

            user = self.get_user(user_id)
            await update.message.reply_text(
                f"✅ تم تأكيد المستخدم: {user_id}\n"
                f"💰 رصيده الحالي: {self.format_points(user['points'])} 🍪\n\n"
                f"📝 أرسل عدد النقاط المراد إضافتها:"
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال آيدي صحيح (أرقام فقط)!")

    async def handle_add_points_amount(self, update: Update, context: ContextTypes.DEFAULT_TYPE, amount_text):
        try:
            amount = float(amount_text.strip())
            user_id = context.user_data.get('add_points_user_id')

            if amount <= 0:
                await update.message.reply_text("❌ يجب أن يكون المبلغ أكبر من الصفر!")
                return

            user = self.get_user(user_id)
            old_points = user['points']
            user['points'] += amount



            context.user_data['waiting_for'] = None
            if 'add_points_user_id' in context.user_data:
                del context.user_data['add_points_user_id']

            await update.message.reply_text(
                f"✅ تم إضافة النقاط بنجاح!\n\n"
                f"👤 المستخدم: {user_id}\n"
                f"➕ النقاط المضافة: {self.format_points(amount)} 🍪\n"
                f"📊 الرصيد السابق: {self.format_points(old_points)} 🍪\n"
                f"📊 الرصيد الجديد: {self.format_points(user['points'])} 🍪"
            )

            try:
                await context.bot.send_message(
                    user_id,
                    f"🎉 تم إضافة ن؂اط إلى حسابك!\n\n"
                    f"➕ النقاط المضافة: {self.format_points(amount)} 🍪\n"
                    f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪\n\n"
                    f"من إدارة البوت 👨‍💼"
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def handle_remove_points_user_id(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id_text):
        try:
            user_id = int(user_id_text.strip())

            if str(user_id) not in self.users:
                await update.message.reply_text("❌ المستخدم غير موجود في النظام!")
                return

            context.user_data['remove_points_user_id'] = user_id
            context.user_data['waiting_for'] = 'remove_points_amount'

            user = self.get_user(user_id)
            await update.message.reply_text(
                f"✅ تم تأكيد المستخدم: {user_id}\n"
                f"💰 رصيده الحالي: {self.format_points(user['points'])} 🍪\n\n"
                f"📝 أرسل عدد النقاط المراد خصمها:"
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال آيدي صحيح (أرقام فقط)!")

    async def handle_remove_points_amount(self, update: Update, context: ContextTypes.DEFAULT_TYPE, amount_text):
        try:
            amount = float(amount_text.strip())
            user_id = context.user_data.get('remove_points_user_id')

            if amount <= 0:
                await update.message.reply_text("❌ يجب أن يكون المبلغ أكبر من الصفر!")
                return

            user = self.get_user(user_id)
            old_points = user['points']

            if user['points'] < amount:
                await update.message.reply_text(
                    f"❌ رصيد المستخدم غير كافٍ!\n\n"
                    f"💰 رصيده الحالي: {self.format_points(user['points'])} 🍪\n"
                    f"📝 المبلغ المطلوب خصمه: {self.format_points(amount)} 🍪"
                )
                return

            user['points'] -= amount


            context.user_data['waiting_for'] = None
            if 'remove_points_user_id' in context.user_data:
                del context.user_data['remove_points_user_id']

            await update.message.reply_text(
                f"✅ تم خصم النقاط بنجاح!\n\n"
                f"👤 المستخدم: {user_id}\n"
                f"➖ النقاط المخصومة: {self.format_points(amount)} 🍪\n"
                f"📊 الرصيد السابق: {self.format_points(old_points)} 🍪\n"
                f"📊 الرصيد الجديد: {self.format_points(user['points'])} 🍪"
            )

            try:
                await context.bot.send_message(
                    user_id,
                    f"⚠️ تم خصم نقاط من حسابك!\n\n"
                    f"➖ النقاط المخصومة: {self.format_points(amount)} 🍪\n"
                    f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪\n\n"
                    f"من إدارة البوت 👨‍💼"
                )
            except:
                pass

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")
    async def subscription_price_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'subscription_price_value'
        await update.callback_query.edit_message_text(
            f"💰 سعر اشتراك القنوات:\n\n"
            f"📺 السعر الحالي للعضو الواحد في القناة: {self.member_price} كوكيز\n"
            f"🤖 سعر البوتات ثابت: {self.bot_member_price} كوكيز\n\n"
            f"أرسل السعر الجديد للعضو الواحد في القناة:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )

    async def handle_subscription_price(self, update: Update, context: ContextTypes.DEFAULT_TYPE, price_text):
        try:
            price = float(price_text)
            if price < 1:
                await update.message.reply_text("❌ يجب أن يكون السعر أكبر من 0!")
                return

            old_price = self.member_price
            self.member_price = price
            context.user_data['waiting_for'] = None

            await update.message.reply_text(
                f"✅ تم تحديث سعر اشتراك القنوات بنجاح!\n\n"
                f"📊 السعر السابق للقنوات: {self.format_points(old_price)} كوكيز\n"
                f"💰 السعر الجديد للقنوات: {self.format_points(price)} كوكيز\n"
                f"🤖 سعر البوتات يبقى ثابت: {self.bot_member_price} كوكيز\n\n"
                f"⚠️ سيتم تطبيق هذا التغيير على عمليات التمويل الجديدة فقط"
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def handle_daily_gift(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        await self.delete_old_mandatory_message(context, user_id)

        daily_gift_info = self.get_daily_gift_info(user_id)

        keyboard = self.create_daily_gift_keyboard(daily_gift_info)

        cycle_info = ""
        if daily_gift_info['completed_cycles'] > 0:
            cycle_info = f"\n🏆 الدورات المكتملة: {daily_gift_info['completed_cycles']}"

        if daily_gift_info['can_claim']:
            message_text = (
                "• مرحبا بك في قسم جمع النقاط يومياً 🎁\n\n"
                f"📅 اليوم الحالي: {daily_gift_info['current_day']}/20{cycle_info}\n"
                f"💎 إجمالي الهدايا المستلمة: {daily_gift_info['total_claimed']}\n\n"
                "- قم بتسجيل الدخول ولا تفوت يوماً واحداً 📅\n"
                "- الهدية اليومية يمكنك المطالبة بها 🎁\n"
                "🔄 بعد إكمال 20 يوم متواصل، سيعاد التسلسل من اليوم 1"
            )
        else:
            time_until_next = self.get_time_until_next_day_baghdad()
            message_text = (
                "• مرحبا بك في قسم جمع النقاط يومياً 🎁\n\n"
                f"📅 اليوم الحالي: {daily_gift_info['current_day']}/20{cycle_info}\n"
                f"💎 إجمالي الهدايا المستلمة: {daily_gift_info['total_claimed']}\n\n"
                "- قم بتسجيل الدخول ولا تفوت يوماً واحداً 📅\n"
                f"- الهدية اليومية بعد {time_until_next} حسب ( آسيا / بغداد ) ووقت استلامه⏳\n"
                "🔄 بعد إكمال 20 يوم متواصل، سيعاد التسلسل من اليوم 1"
            )

        keyboard.append([InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")])

        await update.callback_query.edit_message_text(
            message_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    def get_daily_gift_info(self, user_id):
        """الحصول على معلومات الهدية اليومية للمستخدم مع حماية محسنة وإعادة التسلسل"""
        try:
            from pytz import timezone
            baghdad_tz = timezone('Asia/Baghdad')
            now_baghdad = datetime.now(baghdad_tz)
            today_str = now_baghdad.strftime('%Y-%m-%d')

            user_id_str = str(user_id)

            if user_id_str not in self.daily_gifts:
                self.daily_gifts[user_id_str] = {
                    'current_day': 1,
                    'last_claim_date': None,
                    'claimed_today': False,
                    'reset_date': None,
                    'total_claimed': 0,  # عداد إجمالي الهدايا المستلمة
                    'completed_cycles': 0,  # عدد الدورات المكتملة (20 يوم)
                    'cycle_start_date': today_str  # تاريخ بداية الدورة الحالية
                }

            user_gift_data = self.daily_gifts[user_id_str]

            if not isinstance(user_gift_data.get('current_day'), int) or user_gift_data['current_day'] < 1:
                user_gift_data['current_day'] = 1

            if 'completed_cycles' not in user_gift_data:
                user_gift_data['completed_cycles'] = 0
            if 'cycle_start_date' not in user_gift_data:
                user_gift_data['cycle_start_date'] = today_str

            if user_gift_data['current_day'] > 20:
                user_gift_data['completed_cycles'] += 1
                user_gift_data['current_day'] = 1
                user_gift_data['claimed_today'] = False
                user_gift_data['reset_date'] = today_str
                user_gift_data['cycle_start_date'] = today_str
                user_gift_data['last_claim_date'] = None
                self.save_json(DAILY_GIFTS_FILE, self.daily_gifts)
                logger.info(f"User {user_id} completed daily gift cycle {user_gift_data['completed_cycles']}, auto-reset to day 1")

            if user_gift_data['last_claim_date']:
                try:
                    last_claim = datetime.strptime(user_gift_data['last_claim_date'], '%Y-%m-%d')
                    last_claim_baghdad = baghdad_tz.localize(last_claim) if last_claim.tzinfo is None else last_claim
                    days_diff = (now_baghdad.date() - last_claim_baghdad.date()).days

                    if days_diff > 1:  # انقطع التسلسل - إعادة ضبط لليوم 1
                        user_gift_data['current_day'] = 1
                        user_gift_data['claimed_today'] = False
                        user_gift_data['reset_date'] = today_str
                        user_gift_data['cycle_start_date'] = today_str
                        user_gift_data['last_claim_date'] = None
                        self.save_json(DAILY_GIFTS_FILE, self.daily_gifts)
                        logger.info(f"Reset daily gifts for user {user_id} - missed {days_diff-1} days, restarting cycle")
                    elif days_diff == 1:  # يوم جديد صحيح
                        user_gift_data['claimed_today'] = False
                    elif days_diff == 0:  # نفس اليوم
                        pass
                except Exception as date_error:
                    logger.error(f"Error parsing last claim date for user {user_id}: {date_error}")
                    user_gift_data['current_day'] = 1
                    user_gift_data['claimed_today'] = False
                    user_gift_data['last_claim_date'] = None
                    user_gift_data['cycle_start_date'] = today_str

            can_claim = not user_gift_data.get('claimed_today', False) and user_gift_data['current_day'] <= 20

            return {
                'current_day': user_gift_data['current_day'],
                'can_claim': can_claim,
                'claimed_today': user_gift_data.get('claimed_today', False),
                'total_claimed': user_gift_data.get('total_claimed', 0),
                'completed_cycles': user_gift_data.get('completed_cycles', 0)
            }

        except Exception as e:
            logger.error(f"Error getting daily gift info for user {user_id}: {e}")
            return {
                'current_day': 1,
                'can_claim': True,
                'claimed_today': False,
                'total_claimed': 0,
                'completed_cycles': 0
            }

    def create_daily_gift_keyboard(self, daily_gift_info):
        """إنشاء الأزرار للهدية اليومية مع الحماية والأيقونات الصحيحة"""
        daily_rewards = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]
        keyboard = []

        for row in range(5):
            row_buttons = []
            for col in range(4):
                day_index = row * 4 + col
                if day_index < len(daily_rewards):
                    day_number = day_index + 1
                    reward = daily_rewards[day_index]

                    if day_number < daily_gift_info['current_day']:
                        button_text = f"✅ {reward}"
                        callback_data = f"daily_gift_claimed_{day_number}"
                    elif day_number == daily_gift_info['current_day']:
                        if daily_gift_info['can_claim']:
                            button_text = f"🎁 {reward}"
                            callback_data = f"claim_daily_gift_{day_number}_{reward}"
                        else:
                            button_text = f"✅ {reward}"
                            callback_data = f"daily_gift_claimed_today_{day_number}"
                    else:
                        button_text = f"🔒 {reward}"
                        callback_data = f"daily_gift_future_{day_number}"

                    row_buttons.append(InlineKeyboardButton(button_text, callback_data=callback_data))

            if row_buttons:
                keyboard.append(row_buttons)

        return keyboard

    def get_time_until_next_day_baghdad(self):
        """حساب الوقت المتبقي حتى اليوم التالي بتوقيت بغداد"""
        from pytz import timezone
        baghdad_tz = timezone('Asia/Baghdad')
        now_baghdad = datetime.now(baghdad_tz)

        next_day = (now_baghdad + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
        time_diff = next_day - now_baghdad

        hours = time_diff.seconds // 3600
        minutes = (time_diff.seconds % 3600) // 60
        seconds = time_diff.seconds % 60

        return f"({hours} ساعة و {minutes} دقيقة و {seconds} ثانية)"

    async def claim_daily_gift_new(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        """استلام الهدية اليومية مع حماية شاملة ضد العبث ونظام إعادة التسلسل"""
        try:
            parts = data.split('_')
            if len(parts) != 5:
                return

            day_number = int(parts[3])
            reward = int(parts[4])

            daily_rewards = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]
            if day_number < 1 or day_number > 20 or reward != daily_rewards[day_number - 1]:
                logger.warning(f"Invalid daily gift data from user {update.effective_user.id}: day={day_number}, reward={reward}")
                return

            user_id = update.effective_user.id
            user = self.get_user(user_id)
            user_id_str = str(user_id)

            from pytz import timezone
            baghdad_tz = timezone('Asia/Baghdad')
            now_baghdad = datetime.now(baghdad_tz)
            today_str = now_baghdad.strftime('%Y-%m-%d')

            daily_gift_info = self.get_daily_gift_info(user_id)

            if not daily_gift_info['can_claim']:
                return

            if daily_gift_info['current_day'] != day_number:
                return

            if self.daily_gifts[user_id_str].get('claimed_today', False):
                return

            old_points = user['points']
            user['points'] += reward

            self.daily_gifts[user_id_str]['last_claim_date'] = today_str
            self.daily_gifts[user_id_str]['claimed_today'] = True
            self.daily_gifts[user_id_str]['total_claimed'] = self.daily_gifts[user_id_str].get('total_claimed', 0) + 1

            is_cycle_complete = False
            if day_number == 20:
                self.daily_gifts[user_id_str]['current_day'] = 1
                self.daily_gifts[user_id_str]['completed_cycles'] = self.daily_gifts[user_id_str].get('completed_cycles', 0) + 1
                self.daily_gifts[user_id_str]['claimed_today'] = True  # منع استلام أخرى اليوم
                self.daily_gifts[user_id_str]['cycle_start_date'] = today_str
                is_cycle_complete = True

                pass

                logger.info(f"User {user_id} completed daily gift cycle {self.daily_gifts[user_id_str]['completed_cycles']} - auto reset to day 1")
            else:
                pass


            self.save_json(DAILY_GIFTS_FILE, self.daily_gifts)

            await self.handle_daily_gift(update, context)

            try:
                user_link = f"[{user_id}](tg://user?id={user_id})"

                if is_cycle_complete:
                    cycle_number = self.daily_gifts[user_id_str]['completed_cycles']
                    next_day_info = f"🔄 أكمل الدورة #{cycle_number} - سيبدأ من اليوم 1 غداً"
                else:
                    next_day_info = f"اليوم التالي: {day_number + 1}"

                await context.bot.send_message(
                    ADMIN_ID,
                    f"🎁 هدية يومية مستلمة:\n\n"
                    f"👤 المستخدم: {user_link}\n"
                    f"📅 اليوم: {day_number}/20\n"
                    f"💰 الهدية: {reward} 🍪\n"
                    f"📊 النقاط: {old_points} → {user['points']}\n"
                    f"📈 إجمالي الهدايا: {self.daily_gifts[user_id_str]['total_claimed']}\n"
                    f"🔄 {next_day_info}\n"
                    f"📅 التاريخ: {self.format_time_12h(datetime.now())}",
                    parse_mode='Markdown'
                )
            except Exception as e:
                logger.error(f"فشل في إرسال إشعار الهدية اليومية: {e}")

        except ValueError as ve:
            logger.error(f"ValueError in daily gift claim from user {update.effective_user.id}: {ve}")
        except Exception as e:
            logger.error(f"Error in daily gift claim from user {update.effective_user.id}: {e}")

    async def daily_gift_amount_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'daily_gift_amount_value'
        await update.callback_query.edit_message_text(
            f"🎁 مقدار الهدية اليومية:\n\n"
            f"📊 المقدار الحالي: {self.daily_gift_amount} كوكيز\n\n"
            f"أرسل المقدار الجديد للهدية اليومية:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )

    async def handle_daily_gift_amount_value(self, update: Update, context: ContextTypes.DEFAULT_TYPE, amount_text):
        try:
            amount = float(amount_text)
            if amount < 1:
                await update.message.reply_text("❌ يجب أن يكون المقدار أكبر من 0!")
                return

            old_amount = self.daily_gift_amount
            self.daily_gift_amount = amount
            context.user_data['waiting_for'] = None

            await update.message.reply_text(
                f"✅ تم تحديث مقدار الهدية اليومية بنجاح!\n\n"
                f"📊 المقدار السابق: {self.format_points(old_amount)} كوكيز\n"
                f"🎁 المقدار الجديد: {self.format_points(amount)} كوكيز\n\n"
                f"⚠️ سيتم تطبيق هذا التغيير على الهدايا الجديدة فقط"
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def show_use_gift_code_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        mandatory_result = await self.check_mandatory_subscriptions(update, context)
        if not mandatory_result["all_subscribed"]:
            return

        context.user_data['waiting_for'] = 'gift_code_input'
        await update.callback_query.edit_message_text(
            "🎫 استخدام كود الهدية\n\n"
            "📝 أرسل الكود الذي تريد استخدامه:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="back_to_main")]])
        )

    async def handle_gift_code_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, code_text):
        code = code_text.strip()
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        if code not in self.gift_codes:
            await update.message.reply_text("❌ الكود غير صحيح أو منتهي الصلاحية!")
            context.user_data['waiting_for'] = None
            return

        gift_code_data = self.gift_codes[code]

        if not gift_code_data.get("active", True):
            await update.message.reply_text("❌ هذا الكود لم يعد نشطاً!")
            context.user_data['waiting_for'] = None
            return

        if str(user_id) in gift_code_data.get("used_users", []):
            await update.message.reply_text("❌ لقد استخدمت هذا الكود من قبل!")
            context.user_data['waiting_for'] = None
            return

        max_users = gift_code_data.get("max_users", 0)
        used_count = len(gift_code_data.get("used_users", []))

        if used_count >= max_users:
            await update.message.reply_text("❌ تم استنفاد عدد المستخدمين المسموح لهذا الكود!")
            context.user_data['waiting_for'] = None
            return

        if "used_users" not in self.gift_codes[code]:
            self.gift_codes[code]["used_users"] = []

        self.gift_codes[code]["used_users"].append(str(user_id))

        cookies_amount = gift_code_data.get("cookies", 0)
        user["points"] += cookies_amount

        self.save_json(GIFT_CODES_FILE, self.gift_codes)


        context.user_data['waiting_for'] = None

        remaining_users = max_users - len(self.gift_codes[code]["used_users"])

        await update.message.reply_text(
            f"🎉 تهانينا! تم استخدام الكود بنجاح!\n\n"
            f"🎁 حصلت على: {self.format_points(cookies_amount)} 🍪\n"
            f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪\n"
            f"👥 متبقي للكود: {remaining_users} مستخدم\n\n"
            f"شكراً لك على استخدام البوت! 💫"
        )

        try:
            user_link = f"[{user_id}](tg://user?id={user_id})"
            safe_first_name = self.escape_markdown(update.effective_user.first_name)
            safe_username = ""
            if update.effective_user.username:
                safe_username = self.escape_markdown(f"@{update.effective_user.username}")
            else:
                safe_username = "لا يوجد يوزرنيم"

            await context.bot.send_message(
                ADMIN_ID,
                f"🎫 تم استخدام كود هدية\\!\n\n"
                f"👤 الاسم: {safe_first_name}\n"
                f"📝 اليوزر: {safe_username}\n"
                f"🆔 الآيدي: {user_link}\n"
                f"🎁 الكوكيز المحصلة: {self.format_points(cookies_amount)}\n"
                f"🎫 الكود: {code}\n"
                f"👥 متبقي للكود: {remaining_users} مستخدم\n"
                f"📅 التاريخ: {self.format_time_12h(datetime.now())}",
                parse_mode='MarkdownV2'
            )
        except Exception as e:
            logger.error(f"فشل في إرسال إشعار استخدام الكود: {e}")

    async def create_gift_code_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'gift_code_users'
        await update.callback_query.edit_message_text(
            "🎫 إنشاء كود هدية جديد\n\n"
            "👥 أرسل عدد المستخدمين المسموح لهم باستخدام هذا الكود:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="admin_panel")]])
        )

    async def handle_gift_code_users(self, update: Update, context: ContextTypes.DEFAULT_TYPE, users_text):
        try:
            max_users = int(users_text.strip())
            if max_users <= 0:
                await update.message.reply_text("❌ يجب أن يكون عدد المستخدمين أكبر من الصفر!")
                return

            context.user_data['gift_code_max_users'] = max_users
            context.user_data['waiting_for'] = 'gift_code_cookies'

            await update.message.reply_text(
                f"✅ تم حفظ عدد المستخدمين: {max_users}\n\n"
                f"🍪 الآن أرسل عدد الكوكيز التي سيحصل عليها كل مستخدم:"
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def handle_gift_code_cookies(self, update: Update, context: ContextTypes.DEFAULT_TYPE, cookies_text):
        try:
            cookies_amount = float(cookies_text.strip())
            if cookies_amount <= 0:
                await update.message.reply_text("❌ يجب أن يكون عدد الكوكيز أكبر من الصفر!")
                return

            context.user_data['gift_code_cookies'] = cookies_amount
            context.user_data['waiting_for'] = 'gift_code_text'

            await update.message.reply_text(
                f"✅ تم حفظ عدد الكوكيز: {self.format_points(cookies_amount)} 🍪\n\n"
                f"📝 الآن أرسل نص الكود (أحرف وأرقام):"
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def handle_gift_code_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE, code_text):
        code = code_text.strip()

        if not code.replace(' ', '').isalnum():
            await update.message.reply_text("❌ يجب أن يحتوي الكود على أحرف وأرقام فقط!")
            return

        if code in self.gift_codes:
            await update.message.reply_text("❌ هذا الكود موجود مسبقاً! يرجى اختيار كود آخر.")
            return

        max_users = context.user_data.get('gift_code_max_users')
        cookies_amount = context.user_data.get('gift_code_cookies')

        if not max_users or not cookies_amount:
            await update.message.reply_text("❌ خطأ في البيانات، يرجى المحاولة مرة أخرى")
            context.user_data['waiting_for'] = None
            return

        self.gift_codes[code] = {
            "max_users": max_users,
            "cookies": cookies_amount,
            "used_users": [],
            "created_date": str(datetime.now()),
            "created_by": update.effective_user.id,
            "active": True
        }

        self.save_json(GIFT_CODES_FILE, self.gift_codes)

        context.user_data['waiting_for'] = None
        for key in ['gift_code_max_users', 'gift_code_cookies']:
            if key in context.user_data:
                del context.user_data[key]

        total_cookies = max_users * cookies_amount

        await update.message.reply_text(
            f"✅ تم إنشاء كود الهدية بنجاح!\n\n"
            f"🎫 الكود: `{code}`\n"
            f"👥 عدد المستخدمين المسموح: {max_users}\n"
            f"🍪 كوكيز لكل مستخدم: {self.format_points(cookies_amount)}\n"
            f"💰 إجمالي الكوكيز: {self.format_points(total_cookies)}\n"
            f"📅 تاريخ الإنشاء: {self.format_time_12h(datetime.now())}\n\n"
            f"يمكن للمستخدمين استخدام هذا الكود من خلال زر 'استخدام كود' في القائمة الرئيسية.",
            parse_mode='Markdown'
        )

    async def show_accounts_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        from apis import get_accounts, get_working_accounts

        all_accounts = get_accounts()
        working_accounts = get_working_accounts()

        total_accounts = len(all_accounts)
        active_accounts = len(working_accounts)
        inactive_accounts = total_accounts - active_accounts

        first_account_date = "غير متاح"
        last_account_date = "غير متاح"

        if all_accounts:
            accounts_with_dates = []
            for account in all_accounts:
                if account.get('added_date'):
                    try:
                        date_obj = datetime.strptime(account['added_date'], '%Y-%m-%d %H:%M:%S.%f')
                        accounts_with_dates.append((account, date_obj))
                    except:
                        try:
                            date_obj = datetime.strptime(account['added_date'], '%Y-%m-%d %H:%M:%S')
                            accounts_with_dates.append((account, date_obj))
                        except:
                            pass

            if accounts_with_dates:
                accounts_with_dates.sort(key=lambda x: x[1])
                first_account_date= accounts_with_dates[0][1].strftime('%Y-%m-%d')
                last_account_date = accounts_with_dates[-1][1].strftime('%Y-%m-%d')

        active_phones_preview = []
        for account in working_accounts[:5]:
            phone = account.get('phone', 'غير معروف')
            if len(phone) > 5:
                masked_phone = "****" + phone[-4:]
            else:
                masked_phone = phone
            active_phones_preview.append(masked_phone)

        text = f"👥 معلومات الحسابات المضافة:\n\n"
        text += f"📊 إجمالي الحسابات: {total_accounts}\n"
        text += f"✅ الحسابات النشطة: {active_accounts}\n"
        text += f"❌ الحسابات غير النشطة: {inactive_accounts}\n"
        text += f"📈 معدل النشاط: {int((active_accounts/total_accounts)*100) if total_accounts > 0 else 0}%\n\n"

        text += f"📅 أول حساب مُضاف: {first_account_date}\n"
        text += f"📅 آخر حساب مُضاف: {last_account_date}\n\n"

        if active_phones_preview:
            text += f"📱 عينة من الحسابات النشطة:\n"
            for i, phone in enumerate(active_phones_preview, 1):
                text += f"   {i}. {phone}\n"

            if active_accounts > 5:
                text += f"... و {active_accounts - 5} حساب آخر\n"

        text += f"\n🔄 تم التحديث: {self.format_time_12h(datetime.now())}"

        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")]])
        )

    async def show_admin_settings_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [InlineKeyboardButton("🚪 مغادرة جميع المحادثات", callback_data="leave_all_chats")],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")]
        ]

        await update.callback_query.edit_message_text(
            "⚙️ إعدادd�ت البوت:\n\n"
            "اختر الإجراء المطلوب:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def leave_all_chats_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [
                InlineKeyboardButton("❌ إلغاء", callback_data="admin_settings"),
                InlineKeyboardButton("✅ تأكيد المغادرة", callback_data="confirm_leave_all_chats")
            ]
        ]

        accounts = get_working_accounts()
        accounts_count = len(accounts)

        await update.callback_query.edit_message_text(
            f"🚪 مغادرة جميع المحادثات\n\n"
            f"⚠️ تحذير: هذا الإجراء سيقوم بمغادرة جميع المجموعات والقنوات\n"
            f"لجميع الحسابات المضافة في البوت\n\n"
            f"📊 عدد الحسابات: {accounts_count}\n\n"
            f"❗ هذا الإجراء لا يمكن التراجع عنه!",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_fund_bots_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        user_id = update.effective_user.id
        user = self.get_user(user_id)

        keyboard = [[InlineKeyboardButton("رجوع (🔙)", callback_data="funding_section")]]

        max_affordable_members = int(user['points'] // self.bot_member_price)

        await update.callback_query.edit_message_text(
            text=f"*تمويل اعضاء حقيقية 100% 📣\n\n*"
                 f"> • كل 1 عضو 👤 \\= 30 كوكيز\n\n"
                 f"> 🪫 أقل عدد للتمويل: {self.min_funding_members} عضو\n\n"
                 f"> 🎖️ يمكنك تمويل: {max_affordable_members} عضو\n\n"
                 f"*ارسل عدد الاعضاء المراد تمويلها للبوت 📬*\n",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='MarkdownV2'
        )
        context.user_data['waiting_for'] = 'fund_bot_members'

    async def handle_fund_bot_members_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, members_text):
        try:
            members = int(members_text)
            if members <= 0:
                await update.message.reply_text("❌ يجب أن يكون عدد الأعضاء أكبر من الصفر!")
                return

            if members < self.min_funding_members:
                await update.message.reply_text(f"❌ أقل عدد يمكن تمويله هو {self.min_funding_members} عضو!")
                return
            user_id = update.effective_user.id
            user = self.get_user(user_id)

            total_cost = float(members * self.bot_member_price)
            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"❌ رصيدك غير كافٍ!\n\n"
                    f"💰 تحتاج: {self.format_points(total_cost)} 🍪\n"
                    f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪"
                )
                context.user_data['waiting_for'] = None
                return
            context.user_data['temp_fund_bot_members'] = members
            context.user_data['temp_fund_bot_cost'] = total_cost
            context.user_data['waiting_for'] = 'fund_bot_forward'
            await update.message.reply_text(
                f"✅\] عدد الأعضاء: {members}\n"
                f"💰\] السعر: {self.format_points(total_cost)} كوكيز\n\n"
                f"⚠️\] عليك وضع هذا الرمز \\(  `¥`  \\) داخل اسم بوتك للتحقق من ان البوت خاص بك \\(يمكنك ازالته بعد التحقق\\)\n\n"
                f"*\\- ومن ثم قم بتحويل أي رسالة من بوتك إلى هنا*",
                parse_mode='MarkdownV2'
            )
        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")
    async def handle_fund_bot_forward_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        if not hasattr(message, 'forward_origin') or not message.forward_origin:
            await update.message.reply_text("❌ يجب تحويل رسالة من البوت وليس كتابة رسالة!")
            return
        from telegram import MessageOriginUser
        if not isinstance(message.forward_origin, MessageOriginUser):
            await update.message.reply_text("❌ يجب تحويل رسالة من بوت!")
            return
        forward_user = message.forward_origin.sender_user
        if not forward_user.is_bot:
            await update.message.reply_text("❌ يجب أن تكون الرسالة المحولة من بوت!")
            return
        bot_id = forward_user.id
        bot_id_str = str(bot_id)
        bot_username = forward_user.username

        members = context.user_data.get('temp_fund_bot_members')
        cost = context.user_data.get('temp_fund_bot_cost')

        if not members or not cost:
            await update.message.reply_text("❌ خطأ في البيانات، يرجى المحاولة مرة أخرى")
            context.user_data['waiting_for'] = None
            return
        try:
            bot_chat = await context.bot.get_chat(bot_id)
            bot_name = bot_chat.first_name or ""
            bot_description = getattr(bot_chat, 'description', "") or ""
            bot_bio = getattr(bot_chat, 'bio', "") or ""
            symbol_found = False
            if "¥" in bot_name or "¥" in bot_description or "¥" in bot_bio:
                symbol_found = True
            if not symbol_found:
                await update.message.reply_text(
                    f"❌ لم يتم العثور على الرمز المطلوب\\!\n\n"
                    f"🤖 البوت: {bot_name or 'غير متوفر'}\n"
                    f"⚠️ يرجى إضافة الرمز بجانب اسم البوت\n\n"
                    f"*\\- هكذا* : `{bot_name} ¥`\n\n"
                    f"💡 يمكنك ازالة الرمز بعد التحقق من بوتك",
                    parse_mode='MarkdownV2'
                )
                return
            user['points'] -= cost
            funding_type = "جديد"
            total_members = members
            is_cumulative = False

            if bot_id_str in self.paid_bots:
                old_members_required = self.paid_bots[bot_id_str]["members_required"]
                new_members_required = old_members_required + members
                self.paid_bots[bot_id_str]["members_required"] = new_members_required

                if bot_id_str in self.funded_bots:
                    self.funded_bots[bot_id_str]["members_funded"] += members
                    self.funded_bots[bot_id_str]["cost_paid"] += cost
                    self.funded_bots[bot_id_str]["last_funding_date"] = str(datetime.now())

                funding_type = "تراكمي"
                total_members = new_members_required
                is_cumulative = True
            else:
                self.paid_bots[bot_id_str] = {
                    "name": bot_name,
                    "username": bot_username,
                    "members_required": members,
                    "points": 30,
                    "funded_by": user_id,
                    "funded_date": str(datetime.now()),
                    "total_subscribers_count": 0,
                    "bot_name_with_symbol": bot_name
                }
                self.funded_bots[bot_id_str] = {
                    "owner_id": user_id,
                    "members_funded": members,
                    "cost_paid": cost,
                    "date": str(datetime.now()),
                    "bot_name": bot_name
                }
            funding_number = self.generate_funding_number("bot", None, bot_id_str, is_cumulative)
            if "funded_bots" not in user:
                user["funded_bots"] = []
            if bot_id_str not in user["funded_bots"]:
                user["funded_bots"].append(bot_id_str)


            self.save_json(PAID_BOTS_FILE, self.paid_bots)
            self.save_json(FUNDED_BOTS_FILE, self.funded_bots)

            context.user_data['waiting_for'] = None
            if 'temp_fund_bot_members' in context.user_data:
                del context.user_data['temp_fund_bot_members']
            if 'temp_fund_bot_cost' in context.user_data:
                del context.user_data['temp_fund_bot_cost']
            await update.message.reply_text(
                f"✅\] تم خصم {self.format_points(cost)} وبدء تمويل بوتك بـ {members} عضو \!\n"
                f"🤖\] البوت: {bot_name}\n"
                f"🆔\] رقم التمويل: \#{funding_number}\n\n"
    f"\>💡 يمكنك إزالة الرمز من الاسم الآن\n",
                parse_mode="MarkdownV2"
            )
            try:
                user_link = f"[{user_id}](tg://user?id={user_id})"
                funding_status = "🆕 تمويل بوت جديد" if funding_type == "جديد" else "🔄 تمويل بوت تراكمي"
                funding_icon = "🆕" if funding_type == "جديد" else "🔄"
                message_text = f"{funding_status} {funding_icon}:\n\n"
                message_text += f"👤 المستخدم: {user_link}\n"
                message_text += f"🤖 البوت: {bot_name}\n"
                message_text += f"🔄 نوع التمويل: {funding_type}\n"
                message_text += f"➕ الأعضاء المضافة: {members}\n"
                message_text += f"👥 إجمالي الأعضاء المطلوب: {total_members}\n"
                message_text += f"💰 التكلفة هذه المرة: {self.format_points(cost)} 🍪\n"
                if funding_type == "تراكمي":
                    total_cost_paid = self.funded_bots[bot_id_str]["cost_paid"]
                    message_text += f"💎 إجمالي التكلفة المدفوعة: {self.format_points(total_cost_paid)} 🍪\n"

                message_text += f"📅 التاريخ: {self.format_time_12h(datetime.now())}"
                await context.bot.send_message(
                    ADMIN_ID,
                    message_text,
                    parse_mode='Markdown'
                )
            except Exception as e:
                logger.error(f"فشل في إرسال ٥شعار تمويل البوت للأدمن: {e}")
        except Exception as e:
            await update.message.reply_text(
                f"❌ خطأ في التحقق من البوت!\n\n"
                f"🔍 تأكد من:\n"
                f"• وضع الرمز ¥ في اسم البوت\n"
                f"• تحويل رسالة صحيحة من البوت\n"
                f"• أن البوت يعمل بشكل طبيعي\n\n"
                f"💡 إذا استمرت المشكلة، تواصل مع الإدارة: @cxxov"
            )
            context.user_data['waiting_for'] = None
            user['points'] += cost

    async def show_bot_subscription(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        await self.delete_old_mandatory_message(context, user_id)
        if not self.paid_bots:
            await update.callback_query.edit_message_text(
                "⚠️ لا توجد بوتات متاحة حالياً للاشتراك.\n\n"
                "تحقق لاحقاً للحصول على فرص جديدة لكسب الكوكيز!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]])
            )
            return
        bot_id, bot_info = await self.get_next_paid_bot(user_id, context)
        if not bot_id:
            await update.callback_query.edit_message_text(
                "• لا يوجد بوتات في الوقت الحالي , قم يتجميع النقاط بطريقه مختلفه ❕\n",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]])
            )
            return
        user_reports = getattr(self, 'user_reports', {})
        user_id_str = str(user_id)
        report_button = []
        if user_id_str not in user_reports:
            user_reports[user_id_str] = {'bots': set(), 'channels': set()}
        if bot_id not in user_reports[user_id_str]['bots']:
            report_button = [InlineKeyboardButton("ابلاغ ⚠️", callback_data=f"report_bot_{bot_id}")]
        self.user_reports = user_reports
        keyboard = [
            [InlineKeyboardButton("دخول 🤖", url=f"https://t.me/{bot_info['username']}")] + report_button,
            [InlineKeyboardButton("تخطي", callback_data=f"skip_bot_{bot_id}")],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]
        ]
        await update.callback_query.edit_message_text(
            f"• قم بالدخول الى بوت @{bot_info['username']} 🤖\n\n"
            f"- ارسل /start داخل الروبوت ثم قم بتحويل رسالة من الروبوت الي هنا لتحصل على {bot_info['points']} كوكيز 🍪",
            reply_markup=InlineKeyboardMarkup(keyboard),
            disable_web_page_preview=True
        )
        context.user_data['waiting_for'] = 'bot_subscription_forward'
        context.user_data['current_bot_id'] = bot_id
    async def get_next_paid_bot(self, user_id, context=None):
        user_subscriptions = self.user_bot_subscriptions.get(str(user_id), {})
        for bot_id, bot_info in self.paid_bots.items():
            if bot_id not in user_subscriptions:
                return bot_id, bot_info
        return None, None
    async def get_next_paid_bot_after_skip(self, user_id, current_bot_id, context):
        user_subscriptions = self.user_bot_subscriptions.get(str(user_id), {})
        bots_list = list(self.paid_bots.items())

        current_index = -1
        for i, (bot_id, bot_info) in enumerate(bots_list):
            if bot_id == current_bot_id:
                current_index = i
                break
        start_index = current_index + 1 if current_index != -1 else 0
        for i in range(start_index, len(bots_list)):
            bot_id, bot_info = bots_list[i]
            if bot_id not in user_subscriptions:
                return bot_id, bot_info
        for i in range(0, start_index):
            bot_id, bot_info = bots_list[i]
            if bot_id not in user_subscriptions:
                return bot_id, bot_info
        return None, None
    async def handle_bot_subscription_forward(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message):
        user_id = update.effective_user.id
        user = self.get_user(user_id)
        if not hasattr(message, 'forward_origin') or not message.forward_origin:
            await update.message.reply_text("❌ يجب تحويل رسالة من البوت وليس كتابة رسالة!")
            return
        from telegram import MessageOriginUser
        if not isinstance(message.forward_origin, MessageOriginUser):
            await update.message.reply_text("❌ يجب تحويل رسالة من بوت!")
            return
        forward_user = message.forward_origin.sender_user
        if not forward_user.is_bot:
            await update.message.reply_text("❌ يجب أن تكون الرسالة المحولة من بوت!")
            return
        current_bot_id = context.user_data.get('current_bot_id')
        if not current_bot_id or current_bot_id not in self.paid_bots:
            await update.message.reply_text("❌ خطأ في البيانات، يرجى المحاولة مرة أخرى")
            return
        forwarded_bot_id = str(forward_user.id)
        if forwarded_bot_id != current_bot_id:
            bot_info = self.paid_bots[current_bot_id]
            await update.message.reply_text(f"❌ يجب تحويل رسالة من البوت @{bot_info['username']} وليس من بوت آخر!")
            return
        user_id_str = str(user_id)
        if user_id_str not in self.user_bot_subscriptions:
            self.user_bot_subscriptions[user_id_str] = {}
        if current_bot_id not in self.user_bot_subscriptions[user_id_str]:
            bot_info = self.paid_bots[current_bot_id]
            user['points'] += bot_info['points']
            self.user_bot_subscriptions[user_id_str][current_bot_id] = {
                "points": bot_info['points'],
                "date": str(datetime.now())
            }
            if 'total_subscribers_count' not in self.paid_bots[current_bot_id]:
                self.paid_bots[current_bot_id]['total_subscribers_count'] = 0
            self.paid_bots[current_bot_id]['total_subscribers_count'] += 1

            self.save_json(USER_BOT_SUBSCRIPTION_FILE, self.user_bot_subscriptions)
            self.save_json(PAID_BOTS_FILE, self.paid_bots)
            current_count = self.paid_bots[current_bot_id]['total_subscribers_count']
            required_count = bot_info['members_required']
            if current_count >= required_count:
                funded_info = None
                owner_id = None
                funding_number = None
                if current_bot_id in self.funded_bots:
                    funded_info = self.funded_bots[current_bot_id]
                    owner_id = funded_info['owner_id']
                    for fund_num, fund_record in self.funding_numbers["records"].items():
                        if fund_record.get("bot_id") == current_bot_id and fund_record.get("funding_type") == "bot":
                            funding_number = fund_num
                            self.update_funding_status(fund_num, "مكتمل")
                            break
                    self.move_funding_to_completed(current_bot_id, "bot")
                try:
                    await context.bot.send_message(
                        ADMIN_ID,
                        f"🎉 تم إكمال العدد المطلوب لبوت!\n\n"
                        f"🤖 البوت: {bot_info['name']}\n"
                        f"👥 العدد المطلوب: {required_count}\n"
                        f"✅ العدد الحالي: {current_count}\n"
                        f"🔢 رقم التمويل: #{funding_number}\n\n"
                        f"✅ تم حفظ التمويل في الأرشيف وإزالته من القائمة النشطة."
                    )
                except Exception as e:
                    logger.error(f"فشل في إرسال إشعار اكتمال البوت للأدمن: {e}")

                if owner_id and funded_info:
                    try:
                        await context.bot.send_message(
                            owner_id,
                            f"🎉 تهانينا! تم اكتمال تمويل بوتك بنجاح!\n\n"
                            f"🤖 البوت: {bot_info['name']}\n"
                            f"👥 العدد المكتمل: {current_count}\n"
                            f"🆔 رقم التمويل: #{funding_number}\n"
                            f"💰 التكلفة المدفوعة: {self.format_points(funded_info.get('cost_paid', 0))} 🍪\n\n"
                            f"💼 يمكنك مراجعة التمويل في قسم 'تمويلاتي'\n"
                            f"✅ يمكنك التمويل مرة أخرى.\n"
                            f"شكراً لك على استخدام خدمة التمويل!"
                        )
                        try:
                            await context.bot.send_message(
                                ADMIN_ID,
                                f"✅ تم إشعار صاحب التمويل ({owner_id}) بإكتمال تمويل البوت بنجاح"
                            )
                        except Exception as e:
                            logger.error(f"فشل في إرسال تأكيد الإشعار للأدمن: {e}")

                    except Exception as e:
                        logger.error(f"فشل في إرسال إشعار الاكتمال لصاحب التمويل {owner_id}: {e}")
                        try:
                            await context.bot.send_message(
                                ADMIN_ID,
                                f"❌ فشل إشعار صاحب التمويل ({owner_id}) بإكتمال البوت\n"
                                f"السبب: {str(e)}"
                            )
                        except:
                            pass

                if current_bot_id in self.paid_bots:
                    del self.paid_bots[current_bot_id]

                for user_data in self.users.values():
                    if "funded_bots" in user_data and current_bot_id in user_data["funded_bots"]:
                        user_data["funded_bots"].remove(current_bot_id)

                self.save_json(PAID_BOTS_FILE, self.paid_bots)

            else:
                if current_bot_id in self.funded_bots:
                    funded_info = self.funded_bots[current_bot_id]
                    owner_id = funded_info['owner_id']

                    remaining = max(0, required_count - current_count)

                    try:
                        await context.bot.send_message(
                            owner_id,
                            f"🎖️ قام عضو بتفعيل البوت الخاص بك ✅\n\n"
                            f"- العدد المتبقي : {remaining}"
                        )
                    except:
                        pass

            context.user_data['waiting_for'] = None
            if 'current_bot_id' in context.user_data:
                del context.user_data['current_bot_id']

            success_message = (
                f"✅ تم التحقق بنجاح وإضافة النقاط! 🎉\n\n"
                f"💰 تم إضافة {bot_info['points']} كوكيز\n"
                f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪\n\n"
                f"شكراً لك! 🙏"
            )

            try:
                if hasattr(update, 'message') and update.message.reply_to_message:
                    await update.message.reply_to_message.edit_text(
                        success_message,
                        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("🔙 القائمة الرئيسية", callback_data="back_to_main")]])
                    )
                else:
                    await context.bot.send_message(
                        user_id,
                        success_message,
                        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("🔙 القائمة الرئيسية", callback_data="back_to_main")]])
                    )
            except:
                await context.bot.send_message(
                    user_id,
                    success_message,
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("🔙 القائمة الرئيسية", callback_data="back_to_main")]])
                )

            await asyncio.sleep(1)

            next_bot_id, next_bot_info = await self.get_next_paid_bot(user_id, context)

            if next_bot_id:
                user_reports = getattr(self, 'user_reports', {})
                user_id_str = str(user_id)

                report_button = []
                if user_id_str not in user_reports:
                    user_reports[user_id_str] = {'bots': set(), 'channels': set()}

                if next_bot_id not in user_reports[user_id_str]['bots']:
                    report_button = [InlineKeyboardButton("ابلاغ ⚠️", callback_data=f"report_bot_{next_bot_id}")]

                self.user_reports = user_reports

                keyboard = [
                    [InlineKeyboardButton("دخول 🤖", url=f"https://t.me/{next_bot_info['username']}")] + report_button,
                    [InlineKeyboardButton("تخطي", callback_data=f"skip_bot_{next_bot_id}")],
                    [InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]
                ]

                next_bot_message = (
                    f"• قم بالدخول الي بوت @{next_bot_info['username']} 🤖\n\n"
                    f"- ارسل /start داخل الروبوت ثم قم بتحويل رسالة من الروبوت الي هنا لتحصل على {next_bot_info['points']} كوكيز 🍪"
                )

                await context.bot.send_message(
                    user_id,
                    next_bot_message,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    disable_web_page_preview=True
                )

                context.user_data['waiting_for'] = 'bot_subscription_forward'
                context.user_data['current_bot_id'] = next_bot_id
            else:
                no_bots_message = (
                    f"• لا يوجد بوتات في الوقت الحالي, قم بتجميع النقاط بطريقة مختلفة ❕"
                )

                await context.bot.send_message(
                    user_id,
                    no_bots_message,
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("🔙 القائمة الرئيسية", callback_data="back_to_main")]])
                )

        else:
            await update.message.reply_text("✅ لقد حصلت على نقاط من هذا البوت من قبل!")

    async def show_rush_services_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        active_accounts = get_active_accounts_count()

        keyboard = [
            [InlineKeyboardButton("تصويت عرب اشتراك اجباري", callback_data="arab_vote_mandatory")],
            [InlineKeyboardButton("رشق تفاعلات ", callback_data="rush_reactions"),
            InlineKeyboardButton("رشق تعليقات ", callback_data="comments_service")],
            [InlineKeyboardButton("تعليقات 2", callback_data="comments_service_2")],
            [InlineKeyboardButton("رشق استفتاء", callback_data="poll_service")],
            [InlineKeyboardButton("رجوع", callback_data="services_menu")]
        ]

        status_message = ""
        if active_accounts == 0:
            status_message = "\n⚠️ لا توجد حسابات نشطة حالياً"
        else:
            status_message = f"\n✅ متوفر {active_accounts} حساب نشط"

        await update.callback_query.edit_message_text(
            f"• مرحبا بك في قسم الخدمات ، اختر من بين الازرار ادناه 〽️:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def show_arab_vote_mandatory_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        if active_accounts == 0:
            await update.callback_query.edit_message_text(
                "❌ عذراً، لا توجد حسابات نشطة حالياً لتنفيذ خدمة التصويت\n\nيرجى المحاولة لاحقاً",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="rush_services")]])
            )
            return

        context.user_data['waiting_for'] = 'arab_vote_count'
        context.user_data['service_type'] = 'arab_vote_mandatory'

        await update.callback_query.edit_message_text(
            f"⌁︙خدمة تصويت عرب اشتراك اجباري\n"
            f"⌁︙ سعر التصويت الواحد {vote_price} كوكيز\n"
            f"⌁︙ارسل عدد التصويتات المطلوبه ( الحد الأقصى {active_accounts}):\n",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="rush_services")]])
        )

    async def handle_arab_vote_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE, count_text):
        try:
            count = int(count_text.strip())
            user_id = update.effective_user.id
            user = self.get_user(user_id)

            active_accounts = get_active_accounts_count()

            if count <= 0:
                await update.message.reply_text("❌ يجب أن يكون عدد التصويتات أكبر من الصفر!")
                return

            if count > active_accounts:
                await update.message.reply_text(f"❌ العدد المطلوب ({count}) أكبر من الحد الأقصى ({active_accounts})!")
                return

            total_cost = count * vote_price

            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"❌ رصيدك غير كافٍ!\n\n"
                    f"💰 تحتاج: {self.format_points(total_cost)} 🍪\n"
                    f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪"
                )
                context.user_data['waiting_for'] = None
                return

            context.user_data['arab_vote_count'] = count
            context.user_data['arab_vote_cost'] = total_cost
            context.user_data['waiting_for'] = 'arab_vote_link'

            await update.message.reply_text(
                f"⌁︙ العدد: {count} تصويت\n"
                f"⌁︙ التكلفة: {self.format_points(total_cost)} كوكيز\n"
                f"⌁︙ أرسل رابط المنشور للتصويت عليه:\n"
                f"مثال:-\n"
                f"https://t.me/cxxgo/8..."
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def handle_arab_vote_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, link_text):
        link = link_text.strip()

        if not link.startswith(('https://t.me/', 'http://t.me/', 't.me/')):
            await update.message.reply_text("❌ رابط غير صحيح! يجب أن يكون بصيغة: https://t.me/cxxgo/8")
            return

        if link.startswith('t.me/'):
            link = 'https://' + link
        elif link.startswith('http://'):
            link = link.replace('http://', 'https://')

        context.user_data['arab_vote_link'] = link

        await self.show_speed_selection(update, context)

    async def show_speed_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        link = context.user_data.get('arab_vote_link', 'غير محدد')
        count = context.user_data.get('arab_vote_count', 0)
        cost = context.user_data.get('arab_vote_cost', 0)

        keyboard = [            
            [InlineKeyboardButton("تحديد السرعة ⏳", callback_data="arab_vote_speed_custom"),
            InlineKeyboardButton("السرعة القصوى 🚀", callback_data="arab_vote_speed_fast")],
        ]
        message_text = (
            f"⌁︙يرجى اختيار سرعة الرشق:\n"
        )
        if hasattr(update, 'callback_query') and update.callback_query:
            await update.callback_query.edit_message_text(
                message_text,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await update.message.reply_text(
                message_text,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )

        context.user_data['waiting_for'] = 'arab_vote_speed'

    async def handle_arab_vote_speed_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        """معالجة أزرار تحديد السرعة"""
        if data == "arab_vote_speed_fast":
            await self.execute_arab_vote(update, context, 0)
        elif data == "arab_vote_speed_custom":
            await self.show_custom_speed_input(update, context)

    async def show_custom_speed_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """عرض نافذة إدخال السرعة المخصصة"""
        link = context.user_data.get('arab_vote_link', 'غير محدد')
        count = context.user_data.get('arab_vote_count', 0)
        cost = context.user_data.get('arab_vote_cost', 0)

        context.user_data['waiting_for'] = 'arab_vote_speed'

        await update.callback_query.edit_message_text(
             f"⌁︙أرسل وقت الإنتضار بين الرشق (بالثواني).\n"
           f"• ⋯ • ⋯ • ⋯ • ⋯ • ⋯ •• ⋯ • ⋯ • ⋯ • ⋯ • \n"
           f"⌁︙يجب ان لايزيد عن 300",
        )

    async def handle_arab_vote_speed(self, update: Update, context: ContextTypes.DEFAULT_TYPE, speed_text):
        try:
            speed = int(speed_text.strip())
            if speed < 0 or speed > 500:
                await update.message.reply_text("❌ يجب أن تكون السرعة بين 0 و 500 ثانية!")
                return

            await self.execute_arab_vote(update, context, speed)

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def execute_arab_vote(self, update: Update, context: ContextTypes.DEFAULT_TYPE, speed=0):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        count = context.user_data.get('arab_vote_count')
        link = context.user_data.get('arab_vote_link')
        cost = context.user_data.get('arab_vote_cost')

        if not all([count, link, cost]):
            await update.message.reply_text("❌ خطأ في البيانات، يرجى المحاولة مرة أخرى")
            return

        estimated_time_seconds = (speed * count) + (3 * count)
        estimated_time_minutes = estimated_time_seconds / 60

        user['points'] -= cost


        start_message = (
            f"🔄 يتم تنفيذ طلبك...\n"
            f"⏰ الوقت المقدر: {estimated_time_minutes:.1f} د\n\n"
            f"📊 سأخبرك بالنتائج بعد الانتهاء"
        )

        if hasattr(update, 'callback_query') and update.callback_query:
            message = await update.callback_query.edit_message_text(start_message)
        else:
            message = await update.message.reply_text(start_message)

        asyncio.create_task(self.process_arab_vote_async(
            user_id, count, link, speed, message, context
        ))

        context.user_data['waiting_for'] = None
        for key in ['arab_vote_count', 'arab_vote_link', 'arab_vote_cost', 'arab_vote_speed']:
            if key in context.user_data:
                del context.user_data[key]

    async def show_rush_reactions_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        if active_accounts == 0:
            await update.callback_query.edit_message_text(
                "❌ عذراً، لا توجد حسابات نشطة حالياً لتنفيذ خدمة التفاعلات\n\nيرجى المحاولة لاحقاً",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="rush_services")]])
            )
            return
        keyboard = [
            [InlineKeyboardButton("تفاعلات إيجابية", callback_data="positive_reactions"),
            InlineKeyboardButton("تفاعلات سلبية", callback_data="negative_reactions")],
            [InlineKeyboardButton("تفاعلات عشوائية", callback_data="random_reactions")],
            [InlineKeyboardButton("رجوع", callback_data="rush_services")]
        ]
        await update.callback_query.edit_message_text(
            f"مرحباً بك في قسم رشق التفاعلات⌁︙\n",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def handle_positive_reactions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        context.user_data['waiting_for'] = 'positive_reactions_count'
        context.user_data['service_type'] = 'positive_reactions'

        await update.callback_query.edit_message_text(
            f"⌁︙خدمة التفاعلات الأيجابية\n"
            f"⌁︙ سعر التفاعل الواحد {react_price} كوكيز\n"
            f"⌁︙ارسل عدد التصويتات المطلوبه ( الحد الأقصى {active_accounts}):\n",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="rush_reactions")]])
        )

    async def handle_negative_reactions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        context.user_data['waiting_for'] = 'positive_reactions_count'
        context.user_data['service_type'] = 'negative_reactions'

        await update.callback_query.edit_message_text(
             f"⌁︙خدمة التفاعلات السلبية\n"
            f"⌁︙ سعر التفاعل الواحد {react_price} كوكيز\n"
            f"⌁︙ارسل عدد التصويتات المطلوبه ( الحد الأقصى {active_accounts}):\n",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="rush_reactions")]])
        )

    async def handle_random_reactions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        context.user_data['waiting_for'] = 'positive_reactions_count'
        context.user_data['service_type'] = 'random_reactions'

        await update.callback_query.edit_message_text(
             f"⌁︙خدمة التفاعلات العشوائيه\n"
            f"⌁︙ سعر التفاعل الواحد {react_price} كوكيز\n"
            f"⌁︙ارسل عدد التصويتات المطلوبه ( الحد الأقصى {active_accounts}):\n",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="rush_reactions")]])
        )

    async def handle_reactions_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE, count_text):
        try:
            count = int(count_text.strip())
            user_id = update.effective_user.id
            user = self.get_user(user_id)

            active_accounts = get_active_accounts_count()

            if count <= 0:
                await update.message.reply_text("❌ يجب أن يكون عدد التفاعلات أكبر من الصفر!")
                return

            if count > active_accounts:
                await update.message.reply_text(f"❌ العدد المطلوب ({count}) أكبر من الحد الأقصى ({active_accounts})!")
                return

            total_cost = count * react_price

            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"❌ رصيدك غير كافٍ!\n\n"
                    f"💰 تحتاج: {self.format_points(total_cost)} 🍪\n"
                    f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪"
                )
                context.user_data['waiting_for'] = None
                return

            context.user_data['reactions_count'] = count
            context.user_data['reactions_cost'] = total_cost
            context.user_data['waiting_for'] = 'reactions_link'

            await update.message.reply_text(
                f"⌁︙ العدد: {count} تفاعل\n"
                f"⌁︙ التكلفة: {self.format_points(total_cost)} كوكيز\n"
                f"⌁︙ أرسل رابط المنشور للتفاعل عليه:\n"
                f"مثال:-\n"
                f"https://t.me/TurboFollow2/423..."
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def handle_reactions_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, link_text):
        link = link_text.strip()

        if not link.startswith(('https://t.me/', 'http://t.me/', 't.me/')):
            await update.message.reply_text("❌ رابط غير صحيح! يجب أن يكون بصيغة: https://t.me/channel/123")
            return

        if link.startswith('t.me/'):
            link = 'https://' + link
        elif link.startswith('http://'):
            link = link.replace('http://', 'https://')

        context.user_data['reactions_link'] = link

        service_type = context.user_data.get('service_type', 'positive_reactions')
        count = context.user_data.get('reactions_count')
        cost = context.user_data.get('reactions_cost')

        await self.execute_reactions(update, context, service_type, count, cost, link)

    async def execute_reactions(self, update: Update, context: ContextTypes.DEFAULT_TYPE, service_type, count, cost, link):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        user['points'] -= cost


        start_message = (
            f"🔄 يتم تنفيذ طلبك...\n"
            f"❤️ نوع التفاعل: {service_type}\n"
            f"📊 العدد: {count}\n\n"
            f"📍 سأخبرك بالنتائج بعد الانتهاء"
        )

        message = await update.message.reply_text(start_message)

        asyncio.create_task(self.process_reactions_async(
            user_id, service_type, count, link, message, context
        ))

        context.user_data['waiting_for'] = None
        for key in ['reactions_count', 'reactions_link', 'reactions_cost', 'service_type']:
            if key in context.user_data:
                del context.user_data[key]   
    async def skip_current_bot(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        user_id = update.effective_user.id
        current_bot_id = data.split("_")[2]

        next_bot_id, next_bot_info = await self.get_next_paid_bot_after_skip(user_id, current_bot_id, context)

        if next_bot_id:
            user_reports = getattr(self, 'user_reports', {})
            user_id_str = str(user_id)

            report_button = []
            if user_id_str not in user_reports:
                user_reports[user_id_str] = {'bots': set(), 'channels': set()}

            if next_bot_id not in user_reports[user_id_str]['bots']:
                report_button = [InlineKeyboardButton("ابلاغ ⚠️", callback_data=f"report_bot_{next_bot_id}")]

            self.user_reports = user_reports

            keyboard = [
                [InlineKeyboardButton("دخول 🤖", url=f"https://t.me/{next_bot_info['username']}")] + report_button,
                [InlineKeyboardButton("تخطي", callback_data=f"skip_bot_{next_bot_id}")],
                [InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]
            ]

            await update.callback_query.edit_message_text(
                f"• قم بالدخول الى بوت @{next_bot_info['username']} 🤖\n\n"
                f"- ارسل /start داخل الروبوت ثم قم بتحويل رسالة من الروبوت الي هنا لتحصل على {next_bot_info['points']} كوكيز 🍪",
                reply_markup=InlineKeyboardMarkup(keyboard),
                disable_web_page_preview=True
            )

            context.user_data['waiting_for'] = 'bot_subscription_forward'
            context.user_data['current_bot_id'] = next_bot_id
        else:
            await update.callback_query.edit_message_text(
                "✅ لقد مررت بجميع البوتات المتاحة!\n\n"
                "🔒 للحفاظ على رصيدك، يُرجى عدم مغادرة البوتات.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="collect_stars")]])
            )

    async def process_reactions_async(self, user_id, service_type, count, link, message, context):
        try:
            from apis import react_positive_multiple, react_negative_multiple, get_working_accounts

            working_accounts = get_working_accounts()

            if not working_accounts:
                await message.edit_text("❌ لا توجد حسابات نشطة للتفاعل")
                return

            accounts_to_use = working_accounts[:count]

            await message.edit_text(
                f"جار معالجة طلبك...\n\n"
                f"جار رشق {count} تفاعل\n\n"
                f"سأخبرك بالنتائج عند الإنتهاء من معالجة الطلب.\n"
            )

            if service_type == 'positive_reactions':
                results = await react_positive_multiple(accounts_to_use, link, 3, count)
            elif service_type == 'negative_reactions':
                results = await react_negative_multiple(accounts_to_use, link, 3, count)
            else:  # random_reactions
                from apis import reaction
                results = {"successful": 0, "failed": 0, "total": count}

                print(f"🚀 بدء التفاعلات العشوائية باستخدام {len(accounts_to_use)} حساب...")

                for i, session_data in enumerate(accounts_to_use):
                    session = session_data.get('s', '')
                    if session:
                        try:
                            print(f"🔄 تفاعل عشوائي من الحساب {i+1}/{len(accounts_to_use)}")
                            result = await reaction(session, link)
                            if result:
                                results["successful"] += 1
                                print(f"✅ نجح التفاعل من الحساب {i+1}")
                            else:
                                results["failed"] += 1
                                print(f"❌ فشل التفاعل من الحساب {i+1}")
                        except Exception as e:
                            print(f"❌ خطأ في التفاعل للحساب {i+1}: {e}")
                            results["failed"] += 1
                    else:
                        results["failed"] += 1

                    if i < len(accounts_to_use) - 1:
                        await asyncio.sleep(3)

            success_rate = (results["successful"] / count * 100) if count > 0 else 0

            service_names = {
                'positive_reactions': 'التفاعلات الإيجابية ❤️',
                'negative_reactions': 'التفاعلات السلبية 💔',
                'random_reactions': 'التفاعلات العشوائية 🎲'
            }

            final_message = (
                f"⌁︙ تم إكتمال طلبك بنجاح تفاصيل عن طلبك ↯\n"
                f"⌁︙العدد المطلوب ↫ {count} تفاعل\n"
                f"⌁︙العدد المكتمل ↫{results['successful']}\n"
                f"⌁︙ معدل النجاح: {success_rate:.1f}%\n"
                f"⌁︙الرابط ↫{link[:50]}..."
            )

            await message.edit_text(final_message)

            try:
                await context.bot.send_message(
                    ADMIN_ID,
                    f"❤️ تفاعلات مكتملة:\n"
                    f"👤 المستخدم: {user_id}\n"
                    f"🔗 الرابط: {link}\n"
                    f"📊 النتائج: {results['successful']}/{count}\n"
                    f"📅 التاريخ: {self.format_time_12h(datetime.now())}"
                )
            except:
                pass

            try:
                thank_you_message = "🙏 شكراً لاستخدامك #بوت_تيربو_فولو"
                await context.bot.send_message(user_id, thank_you_message)
            except Exception as e:
                logger.error(f"فشل في إرسال رسالة الشكر: {e}")

        except Exception as e:
            logger.error(f"خطأ في تنفيذ التفاعلات: {e}")
            await message.edit_text(f"❌ حدث خطأ في التفاعلات: {str(e)}")

    async def process_arab_vote_async(self, user_id, count, link, speed, message, context):
        try:
            from apis import vote_multiple, get_working_accounts

            working_accounts = get_working_accounts()

            if not working_accounts:
                await message.edit_text("❌ لا توجد حسابات نشطة للتصويت")
                return

            accounts_to_use = working_accounts[:count]

            await message.edit_text(
                f"جار معالجة طلبك...\n\n"
                f"جار رشق {count} تفاعل \n\n"
                f"سأخبرك بالنتائج عند الإنتهاء من معالجة الطلب.\n"

            )

            results = await vote_multiple(accounts_to_use, link, speed, count)

            success_rate = (results["successful"] / count * 100) if count > 0 else 0

            final_message = (
                f"⌁︙ تم إكتمال طلبك بنجاح تفاصيل عن طلبك ↯ \n"
                f"⌁︙العدد المطلوب ↫ {count} تصويت\n"
                f"⌁︙العدد المكتمل ↫{results['successful']}\n"
                f"⌁︙ معدل النجاح: {success_rate:.1f}%\n"
                f"⌁︙الرابط ↫{link[:50]}..."
            )

            await message.edit_text(final_message)

            try:
                await context.bot.send_message(
                    ADMIN_ID,
                    f"🗳️ تصويت عرب مكتمل:\n"
                    f"👤 المستخدم: {user_id}\n"
                    f"🔗 الرابط: {link}\n"
                    f"📊 النتائج: {results['successful']}/{count}\n"
                    f"📅 التاريخ: {self.format_time_12h(datetime.now())}"
                )
            except:
                pass

            try:
                thank_you_message = "🙏 شكراً لاستخدامك #بوت_تيربو_فولو"
                await context.bot.send_message(user_id, thank_you_message)
            except Exception as e:
                logger.error(f"فشل في إرسال رسالة الشكر: {e}")

        except Exception as e:
            logger.error(f"خطأ في تنفيذ التصويت العربي: {e}")
            await message.edit_text(f"❌ حدث خطأ في التصويت: {str(e)}")

    async def show_comments_service_2_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await self.delete_old_mandatory_message(context, update.effective_user.id)

        await update.callback_query.edit_message_text(
            "قريبا 🔴",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="rush_services")]])
        )

    async def show_comments_service_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        active_accounts = get_active_accounts_count()

        if active_accounts == 0:
            await update.callback_query.edit_message_text(
                "❌ عذراً، لا توجد حسابات نشطة حالياً لتنفيذ خدمة التعليقات\n\nيرجى المحاولة لاحقاً",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="rush_services")]])
            )
            return

        context.user_data['waiting_for'] = 'comments_count'
        context.user_data['service_type'] = 'comments_service'

        await update.callback_query.edit_message_text(
            f"💬 خدمة رشق التعليقات\n\n"
            f"💰 رصيدك: {self.format_points(user['points'])} 🍪\n"
            f"📊 الحسابات النشطة: {active_accounts}\n"
            f"💎 سعر التعليق الواحد: {comment_price} كوكيز\n\n"
            f"📝 أرسل عدد التعليقات المطلوبة (الحد الأقصى: {active_accounts}):",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("❌ إلغاء", callback_data="rush_services")]])
        )

    async def handle_comments_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE, count_text):
        try:
            count = int(count_text.strip())
            user_id = update.effective_user.id
            user = self.get_user(user_id)

            active_accounts = get_active_accounts_count()

            if count <= 0:
                await update.message.reply_text("❌ يجب أن يكون عدد التعليقات أكبر من الصفر!")
                return

            if count > active_accounts:
                await update.message.reply_text(f"❌ العدد المطلوب ({count}) أكبر من الحد الأقصى ({active_accounts})!")
                return

            total_cost = count * comment_price

            if user['points'] < total_cost:
                await update.message.reply_text(
                    f"❌ رصيدك غير كافٍ!\n\n"
                    f"💰 تحتاج: {self.format_points(total_cost)} 🍪\n"
                    f"📊 رصيدك الحالي: {self.format_points(user['points'])} 🍪"
                )
                context.user_data['waiting_for'] = None
                return

            context.user_data['comments_count'] = count
            context.user_data['comments_cost'] = total_cost
            context.user_data['waiting_for'] = 'comments_link'

            await update.message.reply_text(
                f"✅ العدد: {count} تعليق\n"
                f"💰 التكلفة: {self.format_points(total_cost)} 🍪\n\n"
                f"📝 أرسل رابط المنشور للتعليق عليه:"
            )

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def handle_comments_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE, link_text):
        link = link_text.strip()

        if not link.startswith(('https://t.me/', 'http://t.me/', 't.me/')):
            await update.message.reply_text("❌ رابط غير صحيح! يجب أن يكون بصيغة: https://t.me/channel/123")
            return

        if link.startswith('t.me/'):
            link = 'https://' + link
        elif link.startswith('http://'):
            link = link.replace('http://', 'https://')

        context.user_data['comments_link'] = link
        context.user_data['waiting_for'] = 'comments_text'

        await update.message.reply_text(
            f"✅ تم حفظ الرابط\n\n"
            f"📝 الآن أرسل نص التعليق (الحد الأقصى 1000 حرف):"
        )

    async def handle_comments_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE, text):
        if len(text) > 1000:
            await update.message.reply_text("❌ النص طويل جداً! الحد الأقصى 1000 حرف")
            return

        context.user_data['comments_text'] = text

        keyboard = [
            [InlineKeyboardButton("سريع (3 ثواني)", callback_data="comments_speed_fast")],
            [InlineKeyboardButton("عادي (10 ثواني)", callback_data="comments_speed_normal")],
            [InlineKeyboardButton("بطيء (20 ثانية)", callback_data="comments_speed_slow")],
            [InlineKeyboardButton("مخصص", callback_data="comments_speed_custom")],
            [InlineKeyboardButton("❌ إلغاء", callback_data="rush_services")]
        ]

        await update.message.reply_text(
            f"⚡ اختر سرعة إرسال التعليقات:\n\n"
            f"💬 نص التعليق: {text[:50]}{'...' if len(text) > 50 else ''}\n"
            f"📊 العدد: {context.user_data.get('comments_count', 0)}\n"
            f"💰 التكلفة: {self.format_points(context.user_data.get('comments_cost', 0))} 🍪",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        context.user_data['waiting_for'] = 'comments_speed'

    async def handle_comments_speed_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        speed_map = {
            "comments_speed_fast": 3,
            "comments_speed_normal": 10,
            "comments_speed_slow": 20
        }

        if data in speed_map:
            await self.execute_comments(update, context, speed_map[data])
        elif data == "comments_speed_custom":
            await self.show_comments_custom_speed_input(update, context)

    async def show_comments_custom_speed_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['waiting_for'] = 'comments_speed'

        await update.callback_query.edit_message_text(
            f"⌁︙أرسل وقت الإنتضار بين الرشق (بالثواني).\n"
           f"• ⋯ • ⋯ • ⋯ • ⋯ • ⋯ •• ⋯ • ⋯ • ⋯ • ⋯ • \n"
           f"⌁︙يجب ان لايزيد عن 300",
        )

    async def handle_comments_speed(self, update: Update, context: ContextTypes.DEFAULT_TYPE, speed_text):
        try:
            speed = int(speed_text.strip())
            if speed < 0 or speed > 300:
                await update.message.reply_text("❌ يجب أن تكون السرعة بين 0 و 300 ثانية!")
                return

            await self.execute_comments(update, context, speed)

        except ValueError:
            await update.message.reply_text("❌ يرجى إرسال رقم صحيح!")

    async def execute_comments(self, update: Update, context: ContextTypes.DEFAULT_TYPE, speed=10):
        user_id = update.effective_user.id
        user = self.get_user(user_id)

        count = context.user_data.get('comments_count')
        link = context.user_data.get('comments_link')
        comment_text = context.user_data.get('comments_text')
        cost = context.user_data.get('comments_cost')

        if not all([count, link, comment_text, cost]):
            await update.message.reply_text("❌ خطأ في البيانات، يرجى المحاولة مرة أخرى")
            return

        user['points'] -= cost


        start_message = (
            f"🔄 يتم تنفيذ طلبك...\n"
            f"💬 عدد التعليقات: {count}\n"
            f"⏰ السرعة: {speed} ثانية\n\n"
            f"📍 سأخبرك بالنتائج بعد الانتهاء"
        )
        if hasattr(update, 'callback_query') and update.callback_query:
            message = await update.callback_query.edit_message_text(start_message)
        else:
            message = await update.message.reply_text(start_message)
        asyncio.create_task(self.process_comments_async(
            user_id, count, link, comment_text, speed, message, context
        ))
        context.user_data['waiting_for'] = None
        for key in ['comments_count', 'comments_link', 'comments_text', 'comments_cost']:
            if key in context.user_data:
                del context.user_data[key]
    async def process_comments_async(self, user_id, count, link, comment_text, speed, message, context):
        try:
            from apis import send_comments_multiple, get_working_accounts_for_comments
            working_accounts = get_working_accounts_for_comments()
            if not working_accounts:
                await message.edit_text("❌ لا توجد حسابات نشطة للتعليق")
                return
            accounts_to_use = working_accounts[:count]
            await message.edit_text(
                f"🚀 بدء إرسال التعليقات...\n"
                f"💬 النص: {comment_text[:30]}{'...' if len(comment_text) > 30 else ''}\n"
                f"📊 العدد المطلوب: {count}\n"
                f"👥 الحسابات المستخدمة: {len(accounts_to_use)}\n"
                f"⏰ السرعة: {speed} ثانية"
            )
            results = await send_comments_multiple(accounts_to_use, link, comment_text, speed, count)

            success_rate = (results["successful"] / count * 100) if count > 0 else 0
            final_message = (
                f"✅ تم الانتهاء من إرسال التعليقات!\n\n"
                f"📊 النتائج:\n"
                f"✅ نجح: {results['successful']}\n"
                f"❌ فشل: {results['failed']}\n"
                f"📈 معدل النجاح: {success_rate:.1f}%\n\n"
                f"🔗 الرابط: {link[:50]}..."
            )
            await message.edit_text(final_message)
            try:
                await context.bot.send_message(
                    ADMIN_ID,
                    f"💬 تعليقات مكتملة:\n"
                    f"👤 المستخدم: {user_id}\n"
                    f"🔗 الرابط: {link}\n"
                    f"💬 النص: {comment_text[:50]}{'...' if len(comment_text) > 50 else ''}\n"
                    f"📊 النتائج: {results['successful']}/{count}\n"
                    f"📅 التاريخ: {self.format_time_12h(datetime.now())}"
                )
            except:
                pass
            try:
                thank_you_message = "🙏 شكراً لاستخدامك #بوت_تيربو_فولو"
                await context.bot.send_message(user_id, thank_you_message)
            except Exception as e:
                logger.error(f"فشل في إرسال رسالة الشكر: {e}")
        except Exception as e:
            logger.error(f"خطأ في تنفيذ التعليقات: {e}")
            await message.edit_text(f"❌ حدث خطأ في إرسال التعليقات: {str(e)}")
    async def manage_paid_bots_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [InlineKeyboardButton("🗑️ حذف بوت مدفوع", callback_data="delete_paid_bot")],
            [InlineKeyboardButton("📊 ادارة عدد البوتات", callback_data="manage_bots_count")],
            [InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")]
        ]
        text = "🤖 إدارة البوتات المدفوعة:\n\n"
        if self.paid_bots:
            text += "البوتات الحالية:\n"
            for bot_id, info in self.paid_bots.items():
                text += f"• {info['name']} - {self.format_points(info['points'])} 🍪 (@{info['username']})\n"
        else:
            text += "لا توجد بوتات مدفوعة حالياً."
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def delete_paid_bot_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.paid_bots:
            await update.callback_query.edit_message_text(
                "❌ لا توجد بوتات مدفوعة للحذف!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="manage_paid_bots")]])
            )
            return
        keyboard = []
        for bot_id, info in self.paid_bots.items():
            keyboard.append([InlineKeyboardButton(f"🗑️ {info['name']}", callback_data=f"del_bot_{bot_id}")])
        keyboard.append([InlineKeyboardButton("رجوع (🔙)", callback_data="manage_paid_bots")])
        await update.callback_query.edit_message_text(
            "🗑️ اختر البوت المراد حذفه:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def confirm_delete_paid_bot(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        bot_id = data.split("_")[2]
        if bot_id in self.paid_bots:
            bot_name = self.paid_bots[bot_id]['name']
            del self.paid_bots[bot_id]
            self.save_json(PAID_BOTS_FILE, self.paid_bots)
            if bot_id in self.funded_bots:
                del self.funded_bots[bot_id]
                self.save_json(FUNDED_BOTS_FILE, self.funded_bots)
            await update.callback_query.edit_message_text(
                f"✅ تم حذف البوت '{bot_name}' بنجاح!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="manage_paid_bots")]])
            )
        else:
            await update.callback_query.edit_message_text(
                "❌ لم يتم العثور على البوت!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="manage_paid_bots")]])
            )
    async def manage_bots_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not self.paid_bots:
            await update.callback_query.edit_message_text(
                "❌ لا توجد بوتات مدفوعة!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")]])
            )
            return
        keyboard = []
        text = "📊 إدارة عدد البوتات:\n\n"
        for bot_id, info in self.paid_bots.items():
            total_subscribers = info.get('total_subscribers_count', 0)
            required = info['members_required']
            keyboard.append([
                InlineKeyboardButton(f"🤖 {info['name']}", callback_data=f"bot_info_{bot_id}"),
                InlineKeyboardButton(f"{total_subscribers}/{required}", callback_data=f"bot_count_info_{bot_id}")
            ])
            text += f"🤖 {info['name']}\n"
            text += f"👥 العدد: {total_subscribers}/{required}\n\n"
        keyboard.append([InlineKeyboardButton("رجوع (🔙)", callback_data="admin_panel")])
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def execute_leave_all_chats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.callback_query.edit_message_text("🔄 بدء عملية مغادرة جميع المحادثات...")
        from apis import get_working_accounts, leave_chats
        accounts = get_working_accounts()
        if not accounts:
            await update.callback_query.edit_message_text(
                "❌ لا توجد حسابات متاحة!",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="admin_settings")]])
            )
            return
        successful = 0
        failed = 0
        total = len(accounts)
        progress_msg = await context.bot.send_message(
            ADMIN_ID,
            f"🔄 جاري معالجة {total} حساب...\n"
            f"📊 التقدم: 0/{total}"
        )
        for i, account in enumerate(accounts):
            session = account.get('s', '')
            phone = account.get('phone', 'غير معروف')
            if not session:
                failed += 1
                continue
            try:
                result = await leave_chats(session)
                if result:
                    successful += 1
                else:
                    failed += 1
            except Exception as e:
                logger.error(f"خطأ في مغادرة المحادثات للحساب {phone}: {e}")
                failed += 1
            if (i + 1) % 5 == 0 or (i + 1) == total:
                try:
                    await progress_msg.edit_text(
                        f"🔄 جاري معالجة {total} حساب...\n"
                        f"📊 التقدم: {i + 1}/{total}\n"
                        f"✅ نجح: {successful}\n"
                        f"❌ فشل: {failed}"
                    )
                except:
                    pass
            await asyncio.sleep(2)
        final_message = (
            f"✅ تم الانتهاء من مغادرة المحادثات!\n\n"
            f"📊 النتائج النهائية:\n"
            f"👥 إجمالي الحسابات: {total}\n"
            f"✅ نجح: {successful}\n"
            f"❌ فشل: {failed}\n"
            f"📅 تاريخ العملية: {self.format_time_12h(datetime.now())}"
        )
        await progress_msg.edit_text(
            final_message,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("رجوع (🔙)", callback_data="admin_settings")]])
        )
    async def handle_channel_report(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        channel_id = data.split("_")[2]
        user_id = update.effective_user.id
        if channel_id not in self.paid_channels:
            return
        channel_info = self.paid_channels[channel_id]
        self.pending_reports[str(user_id)] = {
            "channel_id": channel_id,
            "channel_name": channel_info['name'],
            "reporter_id": user_id
        }
        keyboard = [
            [InlineKeyboardButton("المحادثة غير موجودة🔦", callback_data=f"report_reason_not_found")],
            [InlineKeyboardButton("محتوى اباحي 🔞", callback_data=f"report_reason_adult_content")],
            [InlineKeyboardButton("محتوى طائفي أو عنف ⚠️☣️", callback_data=f"report_reason_sectarian_violence")],
            [InlineKeyboardButton("سبب آخر ✍️", callback_data="report_other_reason")],
            [InlineKeyboardButton("❌ إلغاء", callback_data="collect_bulk")]
        ]
        await update.callback_query.edit_message_text(
            f"⚠️ إبلاغ عن القناة: {channel_info['name']}\n\n"
            f"📝 اختر سبب الإبلاغ:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def handle_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        await self.process_report_reason(update, context, data, is_bot_report=False)
    async def handle_bot_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        await self.process_report_reason(update, context, data, is_bot_report=True)
    async def process_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data, is_bot_report=False):
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        if user_id_str not in self.pending_reports:
            return
        report_data = self.pending_reports[user_id_str]
        reason_map = {
            "report_reason_not_found": "المحادثة غير موجودة",
            "report_bot_reason_not_found": "المحادثة غير موجودة",
            "report_reason_adult_content": "محتوى اباحي",
            "report_bot_reason_adult_content": "محتوى اباحي",
            "report_reason_sectarian_violence": "محتوى طائفي أو عنف",
            "report_bot_reason_sectarian_violence": "محتوى طائفي أو عنف"
        }
        reason = reason_map.get(data, "سبب غير معروف")
        report_data["reason"] = reason
        if is_bot_report:
            await self.send_bot_report_to_admin(update, context, report_data)
        else:
            await self.send_report_to_admin(update, context, report_data)
    async def handle_other_reason_request(self, update: Update, context: ContextTypes.DEFAULT_TYPE, is_bot_report=False):
        cancel_callback = "bot_subscription" if is_bot_report else "collect_bulk"
        waiting_for = 'custom_bot_report_reason' if is_bot_report else 'custom_report_reason'
        keyboard = [
            [InlineKeyboardButton("❌ إلغاء", callback_data=cancel_callback)]
        ]
        await update.callback_query.edit_message_text(
            f"✍️ اكتب سبب الإبلاغ:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        context.user_data['waiting_for'] = waiting_for
    async def handle_custom_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text, is_bot_report=False):
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        if user_id_str not in self.pending_reports:
            await update.message.reply_text("❌ خطأ في البيانات!")
            return
        report_data = self.pending_reports[user_id_str]
        report_data["reason"] = f"سبب آخر: {reason_text}"
        context.user_data['waiting_for'] = None
        if is_bot_report:
            await self.send_bot_report_to_admin(update, context, report_data)
        else:
            await self.send_report_to_admin(update, context, report_data)
    async def handle_custom_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text):
        await self.handle_custom_reason(update, context, reason_text, is_bot_report=False)
    async def handle_custom_bot_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text):
        await self.handle_custom_reason(update, context, reason_text, is_bot_report=True)

    async def send_report_to_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE, report_data):
        try:
            reporter_id = report_data["reporter_id"]
            channel_id = report_data["channel_id"]
            channel_name = report_data["channel_name"]
            reason = report_data["reason"]

            channel_info = self.paid_channels.get(channel_id, {})
            try:
                user_chat = await context.bot.get_chat(reporter_id)
                reporter_name = user_chat.first_name or "مستخدم"
                reporter_username = f"@{user_chat.username}" if user_chat.username else "لا يوجد"
            except:
                reporter_name = "مستخدم"
                reporter_username = "لا يوجد"

            report_id = f"{reporter_id}_{channel_id}_{int(datetime.now().timestamp())}"

            keyboard = [
                [
                    InlineKeyboardButton("دخول 🔗", url=channel_info.get('invite_link', '#')),
                    InlineKeyboardButton("حذف ❌", callback_data=f"admin_report_delete_{report_id}")
                ],
                [
                    InlineKeyboardButton("إبلاغ ناجح وحذف ✅", 
                                       callback_data=f"admin_report_action_delete_{report_id}"),
                    InlineKeyboardButton("إبلاغ ناجح بدون حذف ⚠️", 
                                       callback_data=f"admin_report_action_keep_{report_id}")
                ]
            ]
            self.pending_reports[report_id] = {
                **report_data,
                "report_id": report_id,
                "report_time": str(datetime.now())
            }
            admin_message = (
                f"🚨 تقرير إبلاغ جديد\n\n"
                f"👤 المبلغ: {reporter_name}\n"
                f"📝 اليوزر: {reporter_username}\n"
                f"🆔 آيدي المبلغ: {reporter_id}\n\n"
                f"📺 القناة المبلغ عنها: {channel_name}\n"
                f"🆔 آيدي القناة: {channel_id}\n"
                f"⚠️ سبب الإبلاغ: {reason}\n\n"
                f"📅 وقت الإبلاغ: {self.format_time_12h(datetime.now())}"
            )
            await context.bot.send_message(
                ADMIN_ID,
                admin_message,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            success_message = (
                f"✅ تم إرسال الإبلاغ بنجاح!\n\n"
                f"📺 القناة: {channel_name}\n"
                f"⚠️ السبب: {reason}\n\n"
                f"شكراً لك على مساعدتنا في تحسين المحتوى 🙏"
            )
            if hasattr(update, 'callback_query') and update.callback_query:
                await update.callback_query.edit_message_text(success_message)
            else:
                await update.message.reply_text(success_message)
            if not hasattr(self, 'user_reports'):
                self.user_reports = {}
            reporter_id_str = str(reporter_id)
            if reporter_id_str not in self.user_reports:
                self.user_reports[reporter_id_str] = {'bots': set(), 'channels': set()}
            self.user_reports[reporter_id_str]['channels'].add(channel_id)
            if str(reporter_id) in self.pending_reports:
                del self.pending_reports[str(reporter_id)]
        except Exception as e:
            logger.error(f"خطأ في إرسال التقرير للأدمن: {e}")
            await update.message.reply_text("❌ حدث خطأ في إرسال التقرير!")
    async def handle_admin_report_delete(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        report_id = data.split("admin_report_delete_")[1]
        if report_id not in self.pending_reports:
            await update.callback_query.edit_message_text("❌ التقرير غير موجود!")
            return
        report_data = self.pending_reports[report_id]
        channel_id = report_data["channel_id"]
        channel_name = report_data["channel_name"]
        if channel_id in self.paid_channels:
            del self.paid_channels[channel_id]
            self.save_data_to_db('paid_channels', self.paid_channels)
        if channel_id in self.funded_channels:
            del self.funded_channels[channel_id]
            self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)
        await update.callback_query.edit_message_text(
            f"✅ تم حذف القناة '{channel_name}' من المدفوع!\n\n"
            f"📅 وقت الحذف: {self.format_time_12h(datetime.now())}"
        )
        del self.pending_reports[report_id]
    async def handle_admin_report_action(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        if update.effective_user.id != ADMIN_ID:
            return
        parts = data.split("_")
        action = parts[3]  # delete أو keep
        report_id = "_".join(parts[4:])  # باقي أجزاء المعرف
        if report_id not in self.pending_reports:
            await update.callback_query.edit_message_text("❌ التقرير غير موجود أو تم التعامل معه من قبل!")
            return
        report_data = self.pending_reports[report_id]
        reporter_id = report_data["reporter_id"]
        report_type = report_data.get("type", "channel")
        reason = report_data["reason"]
        reporter_user = self.get_user(reporter_id)
        reporter_user['points'] += 100

        try:
            if report_type == "bot":
                bot_id = report_data["bot_id"]
                bot_name = report_data["bot_name"]
                if action == "delete":
                    if bot_id in self.paid_bots:
                        del self.paid_bots[bot_id]
                        self.save_json(PAID_BOTS_FILE, self.paid_bots)
                    if bot_id in self.funded_bots:
                        del self.funded_bots[bot_id]
                        self.save_json(FUNDED_BOTS_FILE, self.funded_bots)
                    await context.bot.send_message(
                        reporter_id,
                        f"✅ تم قبول إبلاغك وحذف البوت!\n\n"
                        f"🤖 البوت: {bot_name}\n"
                        f"⚠️ السبب: {reason}\n"
                        f"🎁 تم منحك 100 كوكيز كمكافأة!\n"
                        f"💰 رصيدك الحالي: {self.format_points(reporter_user['points'])} 🍪\n\n"
                        f"شكراً لك على مساعدتنا في الحفاظ على جودة المحتوى! 🙏"
                    )
                    await update.callback_query.edit_message_text(
                        f"✅ تم قبول الإبلاغ وحذف البوت!\n\n"
                        f"🤖 البوت المحذوف: {bot_name}\n"
                        f"👤 المبلغ: {reporter_id}\n"
                        f"⚠️ السبب: {reason}\n"
                        f"🎁 تم منح المبلغ 100 كوكيز\n"
                        f"📅 وقت المعالجة: {self.format_time_12h(datetime.now())}"
                    )
                elif action == "keep":
                    await context.bot.send_message(
                        reporter_id,
                        f"✅ تم قبول إبلاغك!\n\n"
                        f"🤖 البوت: {bot_name}\n"
                        f"⚠️ السبب: {reason}\n"
                        f"🎁 تم منحك 100 كوكيز كمكافأة!\n"
                        f"💰 رصيدك الحالي: {self.format_points(reporter_user['points'])} 🍪\n\n"
                        f"تم التعامل مع الموضوع وشكراً لك على اليقظة! 🙏"
                    )
                    await update.callback_query.edit_message_text(
                        f"✅ تم قبول الإبلاغ بدون حذف!\n\n"
                        f"🤖 البوت: {bot_name}\n"
                        f"👤 المبلغ: {reporter_id}\n"
                        f"⚠️ السبب: {reason}\n"
                        f"🎁 تم منح المبلغ 100 كوكيز\n"
                        f"ℹ️ تم الاحتفاظ بالبوت\n"
                        f"📅 وقت المعالجة: {self.format_time_12h(datetime.now())}"
                    )
            else:  # channel report
                channel_id = report_data["channel_id"]
                channel_name = report_data["channel_name"]
                if action == "delete":
                    if channel_id in self.paid_channels:
                        del self.paid_channels[channel_id]
                        self.save_data_to_db('paid_channels', self.paid_channels)
                    if channel_id in self.funded_channels:
                        del self.funded_channels[channel_id]
                        self.save_json(FUNDED_CHANNELS_FILE, self.funded_channels)
                    await context.bot.send_message(
                        reporter_id,
                        f"✅ تم قبول إبلاغك وحذف القناة!\n\n"
                        f"📺 القناة: {channel_name}\n"
                        f"⚠️ السبب: {reason}\n"
                        f"🎁 تم منحك 100 كوكيز كمكافأة!\n"
                        f"💰 رصيدك الحالي: {self.format_points(reporter_user['points'])} 🍪\n\n"
                        f"شكراً لك على مساعدتنا في الحفاظ على جودة المحتوى! 🙏"
                    )
                    await update.callback_query.edit_message_text(
                        f"✅ تم قبول الإبلاغ وحذف القناة!\n\n"
                        f"📺 القناة المحذوفة: {channel_name}\n"
                        f"👤 المبلغ: {reporter_id}\n"
                        f"⚠️ السبب: {reason}\n"
                        f"🎁 تم منح المبلغ 100 كوكيز\n"
                        f"📅 وقت المعالجة: {self.format_time_12h(datetime.now())}"
                    )
                elif action == "keep":
                    await context.bot.send_message(
                        reporter_id,
                        f"✅ تم قبول إبلاغك!\n\n"
                        f"📺 القناة: {channel_name}\n"
                        f"⚠️ السبب: {reason}\n"
                        f"🎁 تم منحك 100 كوكيز كمكافأة!\n"
                        f"💰 رصيدك الحالي: {self.format_points(reporter_user['points'])} 🍪\n\n"
                        f"تم التعامل مع الموضوع وشكراً لك على اليقظة! 🙏"
                    )
                    await update.callback_query.edit_message_text(
                        f"✅ تم قبول الإبلاغ بدون حذف!\n\n"
                        f"📺 القناة: {channel_name}\n"
                        f"👤 المبلغ: {reporter_id}\n"
                        f"⚠️ السبب: {reason}\n"
                        f"🎁 تم منح المبلغ 100 كوكيز\n"
                        f"ℹ️ تم الاحتفاظ بالقناة\n"
                        f"📅 وقت المعالجة: {self.format_time_12h(datetime.now())}"
                    )
            del self.pending_reports[report_id]
        except Exception as e:
            logger.error(f"خطأ في معالجة التقرير: {e}")
            await update.callback_query.edit_message_text(f"❌ حدث خطأ في معالجة التقرير: {str(e)}")
    async def handle_bot_report(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        bot_id = data.split("_")[2]
        user_id = update.effective_user.id
        if bot_id not in self.paid_bots:
            await update.callback_query.answer("❌ البوت غير موجود!", show_alert=True)
            return
        bot_info = self.paid_bots[bot_id]
        self.pending_reports[str(user_id)] = {
            "bot_id": bot_id,
            "bot_name": bot_info['name'],
            "bot_username": bot_info['username'],
            "reporter_id": user_id,
            "type": "bot"
        }
        keyboard = [
            [InlineKeyboardButton("المحادثة غير موجودة🔦", callback_data=f"report_bot_reason_not_found")],
            [InlineKeyboardButton("محتوى اباحي 🔞", callback_data=f"report_bot_reason_adult_content")],
            [InlineKeyboardButton("محتوى طائفي أو عنف ⚠️☣️", callback_data=f"report_bot_reason_sectarian_violence")],
            [InlineKeyboardButton("سبب آخر ✍️", callback_data="report_bot_other_reason")],
            [InlineKeyboardButton("❌ إلغاء", callback_data="bot_subscription")]
        ]
        await update.callback_query.edit_message_text(
            f"⚠️ إبلاغ عن البوت: {bot_info['name']}\n\n"
            f"📝 اختر سبب الإبلاغ:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    async def handle_bot_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data):
        await self.process_report_reason(update, context, data, is_bot_report=True)
    async def handle_other_reason_request(self, update: Update, context: ContextTypes.DEFAULT_TYPE, is_bot_report=False):
        """دالة موحدة لطلب سبب مخصص"""
        cancel_callback = "bot_subscription" if is_bot_report else "collect_bulk"
        waiting_for = 'custom_bot_report_reason' if is_bot_report else 'custom_report_reason'
        keyboard = [
            [InlineKeyboardButton("❌ إلغاء", callback_data=cancel_callback)]
        ]
        await update.callback_query.edit_message_text(
            f"✍️ اكتب سبب الإبلاغ:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        context.user_data['waiting_for'] = waiting_for
    async def handle_custom_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text, is_bot_report=False):
        """دالة موحدة لمعالجة السبب المخصص"""
        user_id = update.effective_user.id
        user_id_str = str(user_id)
        if user_id_str not in self.pending_reports:
            await update.message.reply_text("❌ خطأ في البيانات!")
            return
        report_data = self.pending_reports[user_id_str]
        report_data["reason"] = f"سبب آخر: {reason_text}"
        context.user_data['waiting_for'] = None
        if is_bot_report:
            await self.send_bot_report_to_admin(update, context, report_data)
        else:
            await self.send_report_to_admin(update, context, report_data)
    async def handle_custom_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text):
        await self.handle_custom_reason(update, context, reason_text, is_bot_report=False)
    async def handle_custom_bot_report_reason(self, update: Update, context: ContextTypes.DEFAULT_TYPE, reason_text):
        await self.handle_custom_reason(update, context, reason_text, is_bot_report=True)
    async def send_bot_report_to_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE, report_data):
        try:
            reporter_id = report_data["reporter_id"]
            bot_id = report_data["bot_id"]
            bot_name = report_data["bot_name"]
            bot_username = report_data["bot_username"]
            reason = report_data["reason"]
            try:
                user_chat = await context.bot.get_chat(reporter_id)
                reporter_name = user_chat.first_name or "مستخدم"
                reporter_username = f"@{user_chat.username}" if user_chat.username else "لا يوجد"
            except:
                reporter_name = "مستخدم"
                reporter_username = "لا يوجد"
            report_id = f"{reporter_id}_{bot_id}_{int(datetime.now().timestamp())}"
            keyboard = [
                [
                    InlineKeyboardButton("إبلاغ ناجح وحذف ✅", 
                                       callback_data=f"admin_report_action_delete_{report_id}"),
                    InlineKeyboardButton("إبلاغ ناجح بدون حذف ⚠️", 
                                       callback_data=f"admin_report_action_keep_{report_id}")
                ]
            ]
            self.pending_reports[report_id] = {
                **report_data,
                "report_id": report_id,
                "report_time": str(datetime.now())
            }
            admin_message = (
                f"🚨 تقرير إبلاغ جديد عن بوت\n\n"
                f"👤 المبلغ: {reporter_name}\n"
                f"📝 اليوزر: {reporter_username}\n"
                f"🆔 آيدي المبلغ: {reporter_id}\n\n"
                f"🤖 البوت المبلغ عنه: {bot_name}\n"
                f"📝 يوزرنيم البوت: @{bot_username}\n"
                f"🆔 آيدي البوت: {bot_id}\n"
                f"⚠️ سبب الإبلاغ: {reason}\n\n"
                f"📅 وقت الإبلاغ: {self.format_time_12h(datetime.now())}"
            )
            await context.bot.send_message(
                ADMIN_ID,
                admin_message,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            success_message = (
                f"✅ تم إرسال الإبلاغ بنجاح!\n\n"
                f"🤖 البوت: {bot_name}\n"
                f"⚠️ السبب: {reason}\n\n"
                f"شكراً لك على مساعدتنا في تحسين المحتوى 🙏"
            )
            if hasattr(update, 'callback_query') and update.callback_query:
                await update.callback_query.edit_message_text(success_message)
            else:
                await update.message.reply_text(success_message)
            if not hasattr(self, 'user_reports'):
                self.user_reports = {}
            reporter_id_str = str(reporter_id)
            if reporter_id_str not in self.user_reports:
                self.user_reports[reporter_id_str] = {'bots': set(), 'channels': set()}
            self.user_reports[reporter_id_str]['bots'].add(bot_id)
            if str(reporter_id) in self.pending_reports:
                del self.pending_reports[str(reporter_id)]
        except Exception as e:
            logger.error(f"خطأ في إرسال تقرير البوت للأدمن: {e}")
            await update.message.reply_text("❌ حدث خطأ في إرسال التقرير!")
def main():
    bot = TelegramBot()
    app = Application.builder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", bot.start))
    app.add_handler(CallbackQueryHandler(bot.handle_callback))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_message))
    print("🚀 بدء تشغيل البوت...")
    try:
        app.run_polling(allowed_updates=Update.ALL_TYPES)
    except KeyboardInterrupt:
        print("تم إيقاف البوت...")
        bot.cre+ate_backup()
        bot.stop_auto_backup()
        bot.stop_admin_check() 


    def update_user_activity(self, user_id):
        """تحديث نشاط المستخدم"""
        user_id_str = str(user_id)
        if user_id_str in self.users:
            self.users[user_id_str]["last_activity"] = str(datetime.now())
            self.save_user_to_db(user_id, self.users[user_id_str])

async def delayed_save_data(self):
    """حفظ البيانات المؤجل"""
    if not hasattr(self, '_data_save_pending'):
        self._data_save_pending = True
        await asyncio.sleep(2)
        try:
            await asyncio.gather(
                asyncio.to_thread(self.save_data_to_db, 'users', self.users),
                asyncio.to_thread(self.save_data_to_db, 'user_channel_subscriptions', self.user_channel_subscriptions)
            )
        except Exception as e:
            logger.error(f"خطأ في الحفظ المؤجل: {e}")
        finally:
            if hasattr(self, '_data_save_pending'):
                del self._data_save_pending


async def main():
    """دالة تشغيل البوت الرئيسية"""
    bot = TelegramBot()

    try:
        app = Application.builder().token(BOT_TOKEN).build()

        app.add_handler(CommandHandler("start", bot.start))
        app.add_handler(CallbackQueryHandler(bot.handle_callback))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_message))

        print("🤖 بدء تشغيل البوت...")
        await app.run_polling(drop_pending_updates=True)

    except Exception as e:
        logger.error(f"خطأ في تشغيل البوت: {e}")
        print(f"❌ خطأ في تشغيل البوت: {e}")
    finally:
        if hasattr(bot, 'stop_admin_check'):
            bot.stop_admin_check()
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n🛑 تم إيقاف البوت بواسطة المستخدم")
    except Exception as e:
        print(f"❌ خطأ في تشغيل البوت: {e}")
